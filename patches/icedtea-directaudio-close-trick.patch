--- /home/mark/src/openjdk/jdk/src/share/classes/com/sun/media/sound/DirectAudioDevice.java	2008-04-13 01:05:30.000000000 +0200
+++ openjdk/jdk/src/share/classes/com/sun/media/sound/DirectAudioDevice.java	2008-05-04 18:42:39.000000000 +0200
@@ -394,7 +394,10 @@
         private float leftGain, rightGain;
         protected volatile boolean noService = false; // do not run the nService method
 
-        protected Object lockNative = new Object();
+        // Guards all native calls and the lastOpened static variable.
+        protected static Object lockNative = new Object();
+        // Keeps track of last opened line, see implOpen "trick".
+        protected static DirectDL lastOpened;
 
         // CONSTRUCTOR
         protected DirectDL(DataLine.Info info,
@@ -496,20 +499,47 @@
             // align buffer to full frames
             bufferSize = ((int) bufferSize / format.getFrameSize()) * format.getFrameSize();
 
-            id = nOpen(mixerIndex, deviceID, isSource,
-                       encoding,
-                       hardwareFormat.getSampleRate(),
-                       hardwareFormat.getSampleSizeInBits(),
-                       hardwareFormat.getFrameSize(),
-                       hardwareFormat.getChannels(),
-                       hardwareFormat.getEncoding().equals(AudioFormat.Encoding.PCM_SIGNED),
-                       hardwareFormat.isBigEndian(),
-                       bufferSize);
+	    synchronized(lockNative) {
+	      id = nOpen(mixerIndex, deviceID, isSource,
+			 encoding,
+			 hardwareFormat.getSampleRate(),
+			 hardwareFormat.getSampleSizeInBits(),
+			 hardwareFormat.getFrameSize(),
+			 hardwareFormat.getChannels(),
+			 hardwareFormat.getEncoding().equals(AudioFormat.Encoding.PCM_SIGNED),
+			 hardwareFormat.isBigEndian(),
+			 bufferSize);
+	      
+	      if (id == 0) {
+		// Bah... Dirty trick. The most likely cause is an application
+		// already having a line open for this particular hardware
+		// format and forgetting about it. If so, silently close that
+		// implementation and try again. Unfortuantely we can only
+		// open one line per hardware format currently.
+		if (lastOpened != null
+		    && hardwareFormat.matches(lastOpened.hardwareFormat)) {
+		  lastOpened.implClose();
+		  lastOpened = null;
+		  
+		  id = nOpen(mixerIndex, deviceID, isSource,
+			     encoding,
+			     hardwareFormat.getSampleRate(),
+			     hardwareFormat.getSampleSizeInBits(),
+			     hardwareFormat.getFrameSize(),
+			     hardwareFormat.getChannels(),
+			     hardwareFormat.getEncoding().equals(AudioFormat.Encoding.PCM_SIGNED),
+			     hardwareFormat.isBigEndian(),
+			     bufferSize);
+		}
+		
+		if (id == 0) {
+		    // TODO: nicer error messages...
+		    throw new LineUnavailableException("line with format "+format+" not supported.");
+                }
+	      }
+	      lastOpened = this;
+	    }
 
-            if (id == 0) {
-                // TODO: nicer error messages...
-                throw new LineUnavailableException("line with format "+format+" not supported.");
-            }
             this.bufferSize = nGetBufferSize(id, isSource);
             if (this.bufferSize < 1) {
                 // this is an error!
@@ -616,6 +646,8 @@
             id = 0;
             synchronized (lockNative) {
                 nClose(oldID, isSource);
+                if (lastOpened == this)
+                  lastOpened = null;
             }
             bytePosition = 0;
             softwareConversionSize = 0;
