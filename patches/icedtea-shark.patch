diff -ru openjdk/hotspot/src/share/vm/ci/ciMethod.cpp openjdk/hotspot/src/share/vm/ci/ciMethod.cpp
--- openjdk/hotspot/src/share/vm/ci/ciMethod.cpp	2008-06-20 10:22:10.000000000 +0100
+++ openjdk/hotspot/src/share/vm/ci/ciMethod.cpp	2008-05-19 12:00:23.000000000 +0100
@@ -56,9 +56,9 @@
   _liveness           = NULL;
   _bcea = NULL;
   _method_blocks = NULL;
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
   _flow               = NULL;
-#endif // COMPILER2
+#endif // COMPILER2 || SHARK
 
   if (JvmtiExport::can_hotswap_or_post_breakpoint() && _is_compilable) {
     // 6328518 check hotswap conditions under the right lock.
@@ -124,9 +124,9 @@
   _bcea = NULL;
   _method_blocks = NULL;
   _method_data = NULL;
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
   _flow = NULL;
-#endif // COMPILER2
+#endif // COMPILER2 || SHARK
 }
 
 
@@ -294,34 +294,34 @@
 // ------------------------------------------------------------------
 // ciMethod::get_flow_analysis
 ciTypeFlow* ciMethod::get_flow_analysis() {
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
   if (_flow == NULL) {
     ciEnv* env = CURRENT_ENV;
     _flow = new (env->arena()) ciTypeFlow(env, this);
     _flow->do_flow();
   }
   return _flow;
-#else // COMPILER2
+#else // COMPILER2 || SHARK
   ShouldNotReachHere();
   return NULL;
-#endif // COMPILER2
+#endif // COMPILER2 || SHARK
 }
 
 
 // ------------------------------------------------------------------
 // ciMethod::get_osr_flow_analysis
 ciTypeFlow* ciMethod::get_osr_flow_analysis(int osr_bci) {
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
   // OSR entry points are always place after a call bytecode of some sort
   assert(osr_bci >= 0, "must supply valid OSR entry point");
   ciEnv* env = CURRENT_ENV;
   ciTypeFlow* flow = new (env->arena()) ciTypeFlow(env, this, osr_bci);
   flow->do_flow();
   return flow;
-#else // COMPILER2
+#else // COMPILER2 || SHARK
   ShouldNotReachHere();
   return NULL;
-#endif // COMPILER2
+#endif // COMPILER2 || SHARK
 }
 
 // ------------------------------------------------------------------
diff -ru openjdk/hotspot/src/share/vm/ci/ciMethod.hpp openjdk/hotspot/src/share/vm/ci/ciMethod.hpp
--- openjdk/hotspot/src/share/vm/ci/ciMethod.hpp	2008-06-20 10:22:10.000000000 +0100
+++ openjdk/hotspot/src/share/vm/ci/ciMethod.hpp	2008-05-19 12:10:30.000000000 +0100
@@ -69,7 +69,7 @@
 
   // Optional liveness analyzer.
   MethodLiveness* _liveness;
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
   ciTypeFlow*     _flow;
 #endif
 
diff -ru openjdk/hotspot/src/share/vm/code/nmethod.cpp openjdk/hotspot/src/share/vm/code/nmethod.cpp
--- openjdk/hotspot/src/share/vm/code/nmethod.cpp	2008-06-20 10:22:11.000000000 +0100
+++ openjdk/hotspot/src/share/vm/code/nmethod.cpp	2008-04-07 11:49:27.000000000 +0100
@@ -66,6 +66,11 @@
   assert(compiler() != NULL, "must be");
   return compiler()->is_c2();
 }
+bool nmethod::is_compiled_by_shark() const {
+  if (is_native_method()) return false;
+  assert(compiler() != NULL, "must be");
+  return compiler()->is_shark();
+}
 
 
 
@@ -1883,6 +1888,8 @@
     tty->print("(c1) ");
   } else if (is_compiled_by_c2()) {
     tty->print("(c2) ");
+  } else if (is_compiled_by_shark()) {
+    tty->print("(shark) ");
   } else {
     assert(is_native_method(), "Who else?");
     tty->print("(nm) ");
diff -ru openjdk/hotspot/src/share/vm/code/nmethod.hpp openjdk/hotspot/src/share/vm/code/nmethod.hpp
--- openjdk/hotspot/src/share/vm/code/nmethod.hpp	2008-06-20 10:22:11.000000000 +0100
+++ openjdk/hotspot/src/share/vm/code/nmethod.hpp	2008-04-07 11:48:22.000000000 +0100
@@ -290,6 +290,7 @@
 
   bool is_compiled_by_c1() const;
   bool is_compiled_by_c2() const;
+  bool is_compiled_by_shark() const;
 
   // boundaries for different parts
   address code_begin         () const             { return _entry_point; }
diff -ru openjdk/hotspot/src/share/vm/compiler/abstractCompiler.hpp openjdk/hotspot/src/share/vm/compiler/abstractCompiler.hpp
--- openjdk/hotspot/src/share/vm/compiler/abstractCompiler.hpp	2008-06-20 10:22:11.000000000 +0100
+++ openjdk/hotspot/src/share/vm/compiler/abstractCompiler.hpp	2008-04-07 11:50:35.000000000 +0100
@@ -45,18 +45,26 @@
   // Missing feature tests
   virtual bool supports_native()                 { return true; }
   virtual bool supports_osr   ()                 { return true; }
-#if defined(TIERED) || ( !defined(COMPILER1) && !defined(COMPILER2))
+#if defined(TIERED) || ( !defined(COMPILER1) && !defined(COMPILER2) && !defined(SHARK))
   virtual bool is_c1   ()                        { return false; }
   virtual bool is_c2   ()                        { return false; }
+  virtual bool is_shark()                        { return false; }
 #else
 #ifdef COMPILER1
   bool is_c1   ()                                { return true; }
   bool is_c2   ()                                { return false; }
+  bool is_shark()                                { return false; }
 #endif // COMPILER1
 #ifdef COMPILER2
   bool is_c1   ()                                { return false; }
   bool is_c2   ()                                { return true; }
+  bool is_shark()                                { return false; }
 #endif // COMPILER2
+#ifdef SHARK
+  bool is_c1   ()                                { return false; }
+  bool is_c2   ()                                { return false; }
+  bool is_shark()                                { return true; }
+#endif // SHARK  
 #endif // TIERED
 
   // Customization
diff -ru openjdk/hotspot/src/share/vm/compiler/compileBroker.cpp openjdk/hotspot/src/share/vm/compiler/compileBroker.cpp
--- openjdk/hotspot/src/share/vm/compiler/compileBroker.cpp	2008-06-20 10:22:11.000000000 +0100
+++ openjdk/hotspot/src/share/vm/compiler/compileBroker.cpp	2008-04-15 17:16:38.000000000 +0100
@@ -554,6 +554,14 @@
 #endif
 #endif // COMPILER2
 
+#ifdef SHARK
+#if defined(COMPILER1) || defined(COMPILER2)
+#error "Can't use COMPILER1 or COMPILER2 with shark"
+#endif
+  _compilers[0] = new SharkCompiler();
+  _compilers[1] = _compilers[0];  
+#endif
+  
   // Initialize the CompileTask free list
   _task_free_list = NULL;
 
diff -ru openjdk/hotspot/src/share/vm/memory/cardTableModRefBS.hpp openjdk/hotspot/src/share/vm/memory/cardTableModRefBS.hpp
--- openjdk/hotspot/src/share/vm/memory/cardTableModRefBS.hpp	2008-06-20 10:22:11.000000000 +0100
+++ openjdk/hotspot/src/share/vm/memory/cardTableModRefBS.hpp	2008-05-06 10:43:55.000000000 +0100
@@ -44,6 +44,7 @@
   friend class VMStructs;
   friend class CardTableRS;
   friend class CheckForUnmarkedOops; // Needs access to raw card bytes.
+  friend class SharkBuilder;
 #ifndef PRODUCT
   // For debugging.
   friend class GuaranteeNotModClosure;
diff -ru openjdk/hotspot/src/share/vm/oops/methodOop.cpp openjdk/hotspot/src/share/vm/oops/methodOop.cpp
--- openjdk/hotspot/src/share/vm/oops/methodOop.cpp	2008-06-20 10:22:11.000000000 +0100
+++ openjdk/hotspot/src/share/vm/oops/methodOop.cpp	2008-04-15 10:52:44.000000000 +0100
@@ -730,10 +730,14 @@ void methodOopDesc::set_code(methodHandl
   }
 
   OrderAccess::storestore();
+#ifdef SHARK
+  mh->_from_interpreted_entry = code->instructions_begin();
+#else
   mh->_from_compiled_entry = code->verified_entry_point();
   OrderAccess::storestore();
   // Instantly compiled code can execute.
   mh->_from_interpreted_entry = mh->get_i2c_entry();
+#endif // SHARK
 
 }
 
diff -ru openjdk/hotspot/src/share/vm/runtime/deoptimization.cpp openjdk/hotspot/src/share/vm/runtime/deoptimization.cpp
--- openjdk/hotspot/src/share/vm/runtime/deoptimization.cpp	2008-06-20 10:22:12.000000000 +0100
+++ openjdk/hotspot/src/share/vm/runtime/deoptimization.cpp	2008-05-19 13:19:54.000000000 +0100
@@ -999,7 +999,7 @@
 JRT_END
 
 
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
 void Deoptimization::load_class_by_index(constantPoolHandle constant_pool, int index, TRAPS) {
   // in case of an unresolved klass entry, load the class.
   if (constant_pool->tag_at(index).is_unresolved_klass()) {
@@ -1750,7 +1750,7 @@
     if (xtty != NULL)  xtty->tail("statistics");
   }
 }
-#else // COMPILER2
+#else // COMPILER2 || SHARK
 
 
 // Stubs for C1 only system.
@@ -1786,4 +1786,4 @@
   return buf;
 }
 
-#endif // COMPILER2
+#endif // COMPILER2 || SHARK
diff -ru openjdk/hotspot/src/share/vm/runtime/globals.cpp openjdk/hotspot/src/share/vm/runtime/globals.cpp
--- openjdk/hotspot/src/share/vm/runtime/globals.cpp	2008-06-20 10:22:12.000000000 +0100
+++ openjdk/hotspot/src/share/vm/runtime/globals.cpp	2008-06-19 14:42:50.000000000 +0100
@@ -158,6 +158,18 @@
   #define C2_NOTPRODUCT_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &name, "{C2 notproduct}", DEFAULT },
 #endif
 
+#define SHARK_PRODUCT_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &name, "{Shark product}", DEFAULT },
+#define SHARK_PD_PRODUCT_FLAG_STRUCT(type, name, doc)     { #type, XSTR(name), &name, "{Shark pd product}", DEFAULT },
+#define SHARK_DIAGNOSTIC_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &name, "{Shark diagnostic}", DEFAULT },
+#ifdef PRODUCT
+  #define SHARK_DEVELOP_FLAG_STRUCT(type, name, value, doc) /* flag is constant */
+  #define SHARK_PD_DEVELOP_FLAG_STRUCT(type, name, doc)     /* flag is constant */
+  #define SHARK_NOTPRODUCT_FLAG_STRUCT(type, name, value, doc)
+#else
+  #define SHARK_DEVELOP_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &name, "{Shark}", DEFAULT },
+  #define SHARK_PD_DEVELOP_FLAG_STRUCT(type, name, doc)     { #type, XSTR(name), &name, "{Shark pd}", DEFAULT },
+  #define SHARK_NOTPRODUCT_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &name, "{Shark notproduct}", DEFAULT },
+#endif
 
 static Flag flagTable[] = {
  RUNTIME_FLAGS(RUNTIME_DEVELOP_FLAG_STRUCT, RUNTIME_PD_DEVELOP_FLAG_STRUCT, RUNTIME_PRODUCT_FLAG_STRUCT, RUNTIME_PD_PRODUCT_FLAG_STRUCT, RUNTIME_DIAGNOSTIC_FLAG_STRUCT, RUNTIME_NOTPRODUCT_FLAG_STRUCT, RUNTIME_MANAGEABLE_FLAG_STRUCT, RUNTIME_PRODUCT_RW_FLAG_STRUCT)
@@ -168,6 +180,9 @@
 #ifdef COMPILER2
  C2_FLAGS(C2_DEVELOP_FLAG_STRUCT, C2_PD_DEVELOP_FLAG_STRUCT, C2_PRODUCT_FLAG_STRUCT, C2_PD_PRODUCT_FLAG_STRUCT, C2_DIAGNOSTIC_FLAG_STRUCT, C2_NOTPRODUCT_FLAG_STRUCT)
 #endif
+#ifdef SHARK
+ SHARK_FLAGS(SHARK_DEVELOP_FLAG_STRUCT, SHARK_PD_DEVELOP_FLAG_STRUCT, SHARK_PRODUCT_FLAG_STRUCT, SHARK_PD_PRODUCT_FLAG_STRUCT, SHARK_DIAGNOSTIC_FLAG_STRUCT, SHARK_NOTPRODUCT_FLAG_STRUCT)
+#endif
  {0, NULL, NULL}
 };
 
diff -ru openjdk/hotspot/src/share/vm/runtime/globals.hpp openjdk/hotspot/src/share/vm/runtime/globals.hpp
--- openjdk/hotspot/src/share/vm/runtime/globals.hpp	2008-06-20 10:22:23.000000000 +0100
+++ openjdk/hotspot/src/share/vm/runtime/globals.hpp	2008-03-31 13:32:44.000000000 +0100
@@ -22,7 +22,7 @@
  *
  */
 
-#if !defined(COMPILER1) && !defined(COMPILER2)
+#if !defined(COMPILER1) && !defined(COMPILER2) && !defined(SHARK)
 define_pd_global(bool, BackgroundCompilation,        false);
 define_pd_global(bool, UseTLAB,                      false);
 define_pd_global(bool, CICompileOSR,                 false);
diff -ru openjdk/hotspot/src/share/vm/runtime/vm_version.cpp openjdk/hotspot/src/share/vm/runtime/vm_version.cpp
--- openjdk/hotspot/src/share/vm/runtime/vm_version.cpp	2008-06-20 10:22:21.000000000 +0100
+++ openjdk/hotspot/src/share/vm/runtime/vm_version.cpp	2008-04-15 11:22:07.000000000 +0100
@@ -89,12 +89,16 @@
 #ifdef TIERED
   #define VMTYPE "Server"
 #else
+#ifdef SHARK
+  #define VMTYPE "Shark"
+#else
 #if defined(COMPILER1) || defined(COMPILER2)
-   #define VMTYPE COMPILER1_PRESENT("Client")   \
-                  COMPILER2_PRESENT("Server")
+  #define VMTYPE COMPILER1_PRESENT("Client")   \
+                 COMPILER2_PRESENT("Server")
 #else
   #define VMTYPE "Core"
 #endif // COMPILER1 || COMPILER2
+#endif // SHARK
 #endif // TIERED
 
 #ifndef HOTSPOT_VM_DISTRO
diff -r ef3bb05d21d5 openjdk/hotspot/src/share/vm/code/nmethod.cpp
--- openjdk/hotspot/src/share/vm/code/nmethod.cpp	Fri Aug 08 11:17:59 2008 +0100
+++ openjdk/hotspot/src/share/vm/code/nmethod.cpp	Fri Aug 08 11:35:04 2008 +0100
@@ -1453,6 +1453,7 @@ void nmethod::oops_do(OopClosure* f) {
 // Method that knows how to preserve outgoing arguments at call. This method must be
 // called with a frame corresponding to a Java invoke
 void nmethod::preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) {
+#ifndef SHARK
   if (!method()->is_native()) {
     SimpleScopeDesc ssd(this, fr.pc());
     Bytecode_invoke* call = Bytecode_invoke_at(ssd.method(), ssd.bci());
@@ -1460,6 +1461,7 @@ void nmethod::preserve_callee_argument_o
     symbolOop signature = call->signature();
     fr.oops_compiled_arguments_do(signature, is_static, reg_map, f);
   }
+#endif // !SHARK
 }
 
 
diff -r 70711eb56d8e openjdk/hotspot/src/share/vm/ci/ciTypeFlow.hpp
--- openjdk/hotspot/src/share/vm/ci/ciTypeFlow.hpp	Mon Sep 29 08:47:58 2008 +0100
+++ openjdk/hotspot/src/share/vm/ci/ciTypeFlow.hpp	Mon Sep 29 08:51:58 2008 +0100
@@ -94,9 +94,17 @@ public:
   private:
     GrowableArray<JsrRecord*>* _set;
 
+#ifdef SHARK
+    // XXX This can be removed if it turns out we have to deal
+    // with T_ADDRESS values the same as everything else.
+  public:
+#endif // SHARK
     JsrRecord* record_at(int i) {
       return _set->at(i);
     }
+#ifdef SHARK
+  private:
+#endif // SHARK
 
     // Insert the given JsrRecord into the JsrSet, maintaining the order
     // of the set and replacing any element with the same entry address.
@@ -515,6 +523,13 @@ public:
     ciType* local_type_at(int i) const { return _state->local_type_at(i); }
     ciType* stack_type_at(int i) const { return _state->stack_type_at(i); }
 
+    // access to the JSRs
+#ifdef SHARK
+    // XXX This can be removed if it turns out we have to deal
+    // with T_ADDRESS values the same as everything else.
+    JsrSet* jsrset() const { return _jsrs; }
+#endif // SHARK
+    
     // Get the successors for this Block.
     GrowableArray<Block*>* successors(ciBytecodeStream* str,
 				      StateVector* state,
diff -r 70711eb56d8e openjdk/hotspot/src/share/vm/runtime/deoptimization.cpp
--- openjdk/hotspot/src/share/vm/runtime/deoptimization.cpp	Mon Sep 29 08:47:58 2008 +0100
+++ openjdk/hotspot/src/share/vm/runtime/deoptimization.cpp	Mon Sep 29 08:54:36 2008 +0100
@@ -217,6 +217,7 @@ Deoptimization::UnrollBlock* Deoptimizat
     
   }
 
+#ifndef SHARK
   // Compute the caller frame based on the sender sp of stub_frame and stored frame sizes info.
   CodeBlob* cb = stub_frame.cb();
   // Verify we have the right vframeArray
@@ -227,6 +228,10 @@ Deoptimization::UnrollBlock* Deoptimizat
   assert(cb->is_deoptimization_stub() || cb->is_uncommon_trap_stub(), "just checking");
   Events::log("fetch unroll sp " INTPTR_FORMAT, unpack_sp);
 #endif
+#else
+  intptr_t* unpack_sp = stub_frame.sender(&dummy_map).unextended_sp();
+#endif // !SHARK
+  
   // This is a guarantee instead of an assert because if vframe doesn't match
   // we will unpack the wrong deoptimized frame and wind up in strange places
   // where it will be very difficult to figure out what went wrong. Better
@@ -337,7 +342,9 @@ Deoptimization::UnrollBlock* Deoptimizat
 
   frame_pcs[0] = deopt_sender.raw_pc();
 
+#ifndef SHARK
   assert(CodeCache::find_blob_unsafe(frame_pcs[0]) != NULL, "bad pc");
+#endif // SHARK
 
   UnrollBlock* info = new UnrollBlock(array->frame_size() * BytesPerWord, 
 				      caller_adjustment * BytesPerWord,
@@ -832,7 +839,20 @@ vframeArray* Deoptimization::create_vfra
   // stuff a C2I adapter we can properly fill in the callee-save
   // register locations.
   frame caller = fr.sender(reg_map);
+#ifdef ZERO
+  int frame_size;
+  {
+    // In zero, frame::sp() is the *end* of the frame, so
+    // caller.sp() - fr.sp() is the size of the *caller*.
+    RegisterMap dummy_map(thread, false);
+    frame frame_1 = thread->last_frame();
+    frame frame_2 = frame_1.sender(&dummy_map);
+    assert(frame_2.sp() == fr.sp(), "should be");
+    frame_size = frame_2.sp() - frame_1.sp();
+  }
+#else
   int frame_size = caller.sp() - fr.sp();
+#endif // ZERO
 
   frame sender = caller;
  
diff -r 70711eb56d8e openjdk/hotspot/src/share/vm/runtime/vframeArray.cpp
--- openjdk/hotspot/src/share/vm/runtime/vframeArray.cpp	Mon Sep 29 08:47:58 2008 +0100
+++ openjdk/hotspot/src/share/vm/runtime/vframeArray.cpp	Mon Sep 29 08:56:26 2008 +0100
@@ -64,6 +64,11 @@ void vframeArrayElement::fill_in(compile
       assert(monitor->owner() == NULL || (!monitor->owner()->is_unlocked() && !monitor->owner()->has_bias_pattern()), "object must be null or locked, and unbiased");
       BasicObjectLock* dest = _monitors->at(index);
       dest->set_obj(monitor->owner());
+#ifdef SHARK
+      // XXX This can be removed when Shark knows
+      // which monitors are in use.
+      if (monitor->owner())
+#endif // SHARK
       monitor->lock()->move_to(monitor->owner(), dest->lock());
     }
   }
@@ -262,6 +267,11 @@ void vframeArrayElement::unpack_on_stack
     top = iframe()->previous_monitor_in_interpreter_frame(top);
     BasicObjectLock* src = _monitors->at(index);
     top->set_obj(src->obj());
+#ifdef SHARK
+    // XXX This can be removed when Shark knows
+    // which monitors are in use.
+    if (src->obj())
+#endif // SHARK    
     src->lock()->move_to(src->obj(), top->lock());
   }
   if (ProfileInterpreter) {
