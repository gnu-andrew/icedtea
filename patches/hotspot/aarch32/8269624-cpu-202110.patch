# HG changeset patch
# User mbalao
# Date 1627973851 0
#      Tue Aug 03 06:57:31 2021 +0000
# Node ID 09099f70d11e9688c927b0909fb232c8f09fe89b
# Parent  78565a54a256905583e0994f385e64c3b1321330
8269624: Enhance method selection support
Reviewed-by: andrew

diff --git openjdk.orig/hotspot/src/share/vm/code/dependencies.cpp openjdk/hotspot/src/share/vm/code/dependencies.cpp
--- openjdk.orig/hotspot/src/share/vm/code/dependencies.cpp
+++ openjdk/hotspot/src/share/vm/code/dependencies.cpp
@@ -1552,6 +1552,26 @@
   return NULL;
 }
 
+// This function is used by find_unique_concrete_method(non vtable based)
+// to check whether subtype method overrides the base method.
+static bool overrides(Method* sub_m, Method* base_m) {
+  assert(base_m != NULL, "base method should be non null");
+  if (sub_m == NULL) {
+    return false;
+  }
+  /**
+   *  If base_m is public or protected then sub_m always overrides.
+   *  If base_m is !public, !protected and !private (i.e. base_m is package private)
+   *  then sub_m should be in the same package as that of base_m.
+   *  For package private base_m this is conservative approach as it allows only subset of all allowed cases in
+   *  the jvm specification.
+   **/
+  if (base_m->is_public() || base_m->is_protected() ||
+      base_m->method_holder()->is_same_class_package(sub_m->method_holder())) {
+    return true;
+  }
+  return false;
+}
 
 // Find the set of all non-abstract methods under ctxk that match m.
 // (The method m must be defined or inherited in ctxk.)
@@ -1576,6 +1596,9 @@
   } else if (Dependencies::find_witness_AME(ctxk, fm) != NULL) {
     // Found a concrete subtype which does not override abstract root method.
     return NULL;
+  } else if (!overrides(fm, m)) {
+    // Found method doesn't override abstract root method.
+    return NULL;
   }
   assert(Dependencies::is_concrete_root_method(fm, ctxk) == Dependencies::is_concrete_method(m, ctxk), "mismatch");
 #ifndef PRODUCT
