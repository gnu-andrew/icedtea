# HG changeset patch
# User fyang
# Date 1497949576 -28800
#      Tue Jun 20 17:06:16 2017 +0800
# Node ID f0f4daedeb01647d6b1783a6b75eca97a420bdbe
# Parent  125269abe0e7a552ae4bddcef82993c153b0364e
8182581, PR3423: aarch64: fix for crash caused by earlyret of compiled method
Summary: fix jvm crash caused by earlyret of compiled method for aarch64 port
Reviewed-by: aph
Contributed-by: snazarkin@azul.com

diff --git a/src/cpu/aarch64/vm/templateInterpreter_aarch64.cpp b/src/cpu/aarch64/vm/templateInterpreter_aarch64.cpp
--- openjdk/hotspot/src/cpu/aarch64/vm/templateInterpreter_aarch64.cpp
+++ openjdk/hotspot/src/cpu/aarch64/vm/templateInterpreter_aarch64.cpp
@@ -1638,9 +1638,15 @@
   // for the callee's params we only need to account for the extra
   // locals.
   int size = overhead +
-         (callee_locals - callee_params)*Interpreter::stackElementWords +
+         (callee_locals - callee_params) +
          monitors * frame::interpreter_frame_monitor_size() +
-         temps* Interpreter::stackElementWords + extra_args;
+         // On the top frame, at all times SP <= ESP, and SP is
+         // 16-aligned.  We ensure this by adjusting SP on method
+         // entry and re-entry to allow room for the maximum size of
+         // the expression stack.  When we call another method we bump
+         // SP so that no stack space is wasted.  So, only on the top
+         // frame do we need to allow max_stack words.
+         (is_top_frame ? max_stack : temps + extra_args);
 
   // On AArch64 we always keep the stack pointer 16-aligned, so we
   // must round up here.
