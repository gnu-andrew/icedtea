diff -Nru openjdk.orig/hotspot/src/share/vm/ci/ciMethod.cpp openjdk/hotspot/src/share/vm/ci/ciMethod.cpp
--- openjdk.orig/hotspot/src/share/vm/ci/ciMethod.cpp	2010-04-28 22:16:22.000000000 +0100
+++ openjdk/hotspot/src/share/vm/ci/ciMethod.cpp	2010-05-10 14:38:13.000000000 +0100
@@ -56,9 +56,9 @@
   _liveness           = NULL;
   _bcea = NULL;
   _method_blocks = NULL;
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
   _flow               = NULL;
-#endif // COMPILER2
+#endif // COMPILER2 || SHARK
 
   ciEnv *env = CURRENT_ENV;
   if (env->jvmti_can_hotswap_or_post_breakpoint() && _is_compilable) {
@@ -124,9 +124,9 @@
   _bcea = NULL;
   _method_blocks = NULL;
   _method_data = NULL;
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
   _flow = NULL;
-#endif // COMPILER2
+#endif // COMPILER2 || SHARK
 }
 
 
@@ -228,6 +228,18 @@
   return get_methodOop()->vtable_index();
 }
 
+#ifdef SHARK
+// ------------------------------------------------------------------
+// ciMethod::itable_index
+//
+// Get the position of this method's entry in the itable, if any.
+int ciMethod::itable_index() {
+  check_is_loaded();
+  assert(holder()->is_linked(), "must be linked");
+  VM_ENTRY_MARK;
+  return klassItable::compute_itable_index(get_methodOop());
+}
+#endif // SHARK
 
 // ------------------------------------------------------------------
 // ciMethod::native_entry
@@ -294,34 +306,34 @@
 // ------------------------------------------------------------------
 // ciMethod::get_flow_analysis
 ciTypeFlow* ciMethod::get_flow_analysis() {
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
   if (_flow == NULL) {
     ciEnv* env = CURRENT_ENV;
     _flow = new (env->arena()) ciTypeFlow(env, this);
     _flow->do_flow();
   }
   return _flow;
-#else // COMPILER2
+#else // COMPILER2 || SHARK
   ShouldNotReachHere();
   return NULL;
-#endif // COMPILER2
+#endif // COMPILER2 || SHARK
 }
 
 
 // ------------------------------------------------------------------
 // ciMethod::get_osr_flow_analysis
 ciTypeFlow* ciMethod::get_osr_flow_analysis(int osr_bci) {
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
   // OSR entry points are always place after a call bytecode of some sort
   assert(osr_bci >= 0, "must supply valid OSR entry point");
   ciEnv* env = CURRENT_ENV;
   ciTypeFlow* flow = new (env->arena()) ciTypeFlow(env, this, osr_bci);
   flow->do_flow();
   return flow;
-#else // COMPILER2
+#else // COMPILER2 || SHARK
   ShouldNotReachHere();
   return NULL;
-#endif // COMPILER2
+#endif // COMPILER2 || SHARK
 }
 
 // ------------------------------------------------------------------
diff -Nru openjdk.orig/hotspot/src/share/vm/ci/ciMethod.hpp openjdk/hotspot/src/share/vm/ci/ciMethod.hpp
--- openjdk.orig/hotspot/src/share/vm/ci/ciMethod.hpp	2010-04-28 22:16:22.000000000 +0100
+++ openjdk/hotspot/src/share/vm/ci/ciMethod.hpp	2010-05-10 14:38:13.000000000 +0100
@@ -71,7 +71,7 @@
 
   // Optional liveness analyzer.
   MethodLiveness* _liveness;
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
   ciTypeFlow*     _flow;
 #endif
 
@@ -141,6 +141,9 @@
 
   // Runtime information.
   int           vtable_index();
+#ifdef SHARK
+  int itable_index();
+#endif // SHARK 
   address       native_entry();
   address       interpreter_entry();
 
diff -Nru openjdk.orig/hotspot/src/share/vm/code/nmethod.cpp openjdk/hotspot/src/share/vm/code/nmethod.cpp
--- openjdk.orig/hotspot/src/share/vm/code/nmethod.cpp	2010-04-28 22:16:22.000000000 +0100
+++ openjdk/hotspot/src/share/vm/code/nmethod.cpp	2010-05-10 15:00:13.000000000 +0100
@@ -65,6 +65,11 @@
   if (is_native_method()) return false;
   return compiler()->is_c2();
 }
+bool nmethod::is_compiled_by_shark() const {
+  if (is_native_method()) return false;
+  assert(compiler() != NULL, "must be");
+  return compiler()->is_shark();
+}
 
 
 
@@ -1346,6 +1351,10 @@
     CodeCache::remove_saved_code(this);
   }
 
+#ifdef SHARK
+  ((SharkCompiler *) compiler())->free_compiled_method(instructions_begin());
+#endif // SHARK
+  
   ((CodeBlob*)(this))->flush();
 
   CodeCache::free(this);
@@ -1737,6 +1746,7 @@
 // Method that knows how to preserve outgoing arguments at call. This method must be
 // called with a frame corresponding to a Java invoke
 void nmethod::preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) {
+#ifndef SHARK
   if (!method()->is_native()) {
     SimpleScopeDesc ssd(this, fr.pc());
     Bytecode_invoke* call = Bytecode_invoke_at(ssd.method(), ssd.bci());
@@ -1744,6 +1754,7 @@
     symbolOop signature = call->signature();
     fr.oops_compiled_arguments_do(signature, has_receiver, reg_map, f);
   }
+#endif // !SHARK
 }
 
 
@@ -2247,6 +2258,8 @@
     tty->print("(c1) ");
   } else if (is_compiled_by_c2()) {
     tty->print("(c2) ");
+  } else if (is_compiled_by_shark()) {
+    tty->print("(shark) ");
   } else {
     tty->print("(nm) ");
   }
diff -Nru openjdk.orig/hotspot/src/share/vm/code/nmethod.hpp openjdk/hotspot/src/share/vm/code/nmethod.hpp
--- openjdk.orig/hotspot/src/share/vm/code/nmethod.hpp	2010-04-28 22:16:22.000000000 +0100
+++ openjdk/hotspot/src/share/vm/code/nmethod.hpp	2010-05-10 14:38:13.000000000 +0100
@@ -334,6 +334,7 @@
 
   bool is_compiled_by_c1() const;
   bool is_compiled_by_c2() const;
+  bool is_compiled_by_shark() const;
 
   // boundaries for different parts
   address code_begin            () const          { return _entry_point; }
diff -Nru openjdk.orig/hotspot/src/share/vm/compiler/abstractCompiler.hpp openjdk/hotspot/src/share/vm/compiler/abstractCompiler.hpp
--- openjdk.orig/hotspot/src/share/vm/compiler/abstractCompiler.hpp	2010-04-28 22:16:22.000000000 +0100
+++ openjdk/hotspot/src/share/vm/compiler/abstractCompiler.hpp	2010-05-10 14:38:13.000000000 +0100
@@ -45,18 +45,26 @@
   // Missing feature tests
   virtual bool supports_native()                 { return true; }
   virtual bool supports_osr   ()                 { return true; }
-#if defined(TIERED) || ( !defined(COMPILER1) && !defined(COMPILER2))
+#if defined(TIERED) || ( !defined(COMPILER1) && !defined(COMPILER2) && !defined(SHARK))
   virtual bool is_c1   ()                        { return false; }
   virtual bool is_c2   ()                        { return false; }
+  virtual bool is_shark()                        { return false; }
 #else
 #ifdef COMPILER1
   bool is_c1   ()                                { return true; }
   bool is_c2   ()                                { return false; }
+  bool is_shark()                                { return false; }
 #endif // COMPILER1
 #ifdef COMPILER2
   bool is_c1   ()                                { return false; }
   bool is_c2   ()                                { return true; }
+  bool is_shark()                                { return false; }
 #endif // COMPILER2
+#ifdef SHARK
+  bool is_c1   ()                                { return false; }
+  bool is_c2   ()                                { return false; }
+  bool is_shark()                                { return true; }
+#endif // SHARK  
 #endif // TIERED
 
   // Customization
diff -Nru openjdk.orig/hotspot/src/share/vm/compiler/compileBroker.cpp openjdk/hotspot/src/share/vm/compiler/compileBroker.cpp
--- openjdk.orig/hotspot/src/share/vm/compiler/compileBroker.cpp	2010-04-28 22:16:22.000000000 +0100
+++ openjdk/hotspot/src/share/vm/compiler/compileBroker.cpp	2010-05-10 14:38:13.000000000 +0100
@@ -555,6 +555,14 @@
 #endif
 #endif // COMPILER2
 
+#ifdef SHARK
+#if defined(COMPILER1) || defined(COMPILER2)
+#error "Can't use COMPILER1 or COMPILER2 with shark"
+#endif
+  _compilers[0] = new SharkCompiler();
+  _compilers[1] = _compilers[0];  
+#endif
+  
   // Initialize the CompileTask free list
   _task_free_list = NULL;
 
diff -Nru openjdk.orig/hotspot/src/share/vm/memory/cardTableModRefBS.hpp openjdk/hotspot/src/share/vm/memory/cardTableModRefBS.hpp
--- openjdk.orig/hotspot/src/share/vm/memory/cardTableModRefBS.hpp	2010-04-28 22:16:22.000000000 +0100
+++ openjdk/hotspot/src/share/vm/memory/cardTableModRefBS.hpp	2010-05-10 14:38:13.000000000 +0100
@@ -44,6 +44,7 @@
   friend class VMStructs;
   friend class CardTableRS;
   friend class CheckForUnmarkedOops; // Needs access to raw card bytes.
+  friend class SharkBuilder;
 #ifndef PRODUCT
   // For debugging.
   friend class GuaranteeNotModClosure;
diff -Nru openjdk.orig/hotspot/src/share/vm/oops/methodOop.cpp openjdk/hotspot/src/share/vm/oops/methodOop.cpp
--- openjdk.orig/hotspot/src/share/vm/oops/methodOop.cpp	2010-04-28 22:16:22.000000000 +0100
+++ openjdk/hotspot/src/share/vm/oops/methodOop.cpp	2010-05-10 14:38:13.000000000 +0100
@@ -751,10 +751,14 @@
   }
 
   OrderAccess::storestore();
+#ifdef SHARK
+  mh->_from_interpreted_entry = code->instructions_begin();
+#else
   mh->_from_compiled_entry = code->verified_entry_point();
   OrderAccess::storestore();
   // Instantly compiled code can execute.
   mh->_from_interpreted_entry = mh->get_i2c_entry();
+#endif // SHARK
 
 }
 
diff -Nru openjdk.orig/hotspot/src/share/vm/runtime/deoptimization.cpp openjdk/hotspot/src/share/vm/runtime/deoptimization.cpp
--- openjdk.orig/hotspot/src/share/vm/runtime/deoptimization.cpp	2010-04-28 22:16:22.000000000 +0100
+++ openjdk/hotspot/src/share/vm/runtime/deoptimization.cpp	2010-05-10 14:38:13.000000000 +0100
@@ -254,6 +254,7 @@
 
   }
 
+#ifndef SHARK
   // Compute the caller frame based on the sender sp of stub_frame and stored frame sizes info.
   CodeBlob* cb = stub_frame.cb();
   // Verify we have the right vframeArray
@@ -270,6 +271,10 @@
   assert(cb->is_deoptimization_stub() || cb->is_uncommon_trap_stub(), "just checking");
   Events::log("fetch unroll sp " INTPTR_FORMAT, unpack_sp);
 #endif
+#else
+  intptr_t* unpack_sp = stub_frame.sender(&dummy_map).unextended_sp();
+#endif // !SHARK
+  
   // This is a guarantee instead of an assert because if vframe doesn't match
   // we will unpack the wrong deoptimized frame and wind up in strange places
   // where it will be very difficult to figure out what went wrong. Better
@@ -380,7 +385,9 @@
 
   frame_pcs[0] = deopt_sender.raw_pc();
 
+#ifndef SHARK
   assert(CodeCache::find_blob_unsafe(frame_pcs[0]) != NULL, "bad pc");
+#endif // SHARK
 
   UnrollBlock* info = new UnrollBlock(array->frame_size() * BytesPerWord,
                                       caller_adjustment * BytesPerWord,
@@ -921,7 +928,20 @@
   // stuff a C2I adapter we can properly fill in the callee-save
   // register locations.
   frame caller = fr.sender(reg_map);
+#ifdef ZERO
+  int frame_size;
+  {
+    // In zero, frame::sp() is the *end* of the frame, so
+    // caller.sp() - fr.sp() is the size of the *caller*.
+    RegisterMap dummy_map(thread, false);
+    frame frame_1 = thread->last_frame();
+    frame frame_2 = frame_1.sender(&dummy_map);
+    assert(frame_2.sp() == fr.sp(), "should be");
+    frame_size = frame_2.sp() - frame_1.sp();
+  }
+#else
   int frame_size = caller.sp() - fr.sp();
+#endif // ZERO
 
   frame sender = caller;
 
@@ -1073,7 +1093,7 @@
 JRT_END
 
 
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
 void Deoptimization::load_class_by_index(constantPoolHandle constant_pool, int index, TRAPS) {
   // in case of an unresolved klass entry, load the class.
   if (constant_pool->tag_at(index).is_unresolved_klass()) {
@@ -1835,7 +1855,7 @@
     if (xtty != NULL)  xtty->tail("statistics");
   }
 }
-#else // COMPILER2
+#else // COMPILER2 || SHARK
 
 
 // Stubs for C1 only system.
@@ -1871,4 +1891,4 @@
   return buf;
 }
 
-#endif // COMPILER2
+#endif // COMPILER2 || SHARK
diff -Nru openjdk.orig/hotspot/src/share/vm/runtime/globals.cpp openjdk/hotspot/src/share/vm/runtime/globals.cpp
--- openjdk.orig/hotspot/src/share/vm/runtime/globals.cpp	2010-04-28 22:16:22.000000000 +0100
+++ openjdk/hotspot/src/share/vm/runtime/globals.cpp	2010-05-10 14:38:13.000000000 +0100
@@ -181,6 +181,18 @@
   #define C2_NOTPRODUCT_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &name, "{C2 notproduct}", DEFAULT },
 #endif
 
+#define SHARK_PRODUCT_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &name, "{Shark product}", DEFAULT },
+#define SHARK_PD_PRODUCT_FLAG_STRUCT(type, name, doc)     { #type, XSTR(name), &name, "{Shark pd product}", DEFAULT },
+#define SHARK_DIAGNOSTIC_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &name, "{Shark diagnostic}", DEFAULT },
+#ifdef PRODUCT
+  #define SHARK_DEVELOP_FLAG_STRUCT(type, name, value, doc) /* flag is constant */
+  #define SHARK_PD_DEVELOP_FLAG_STRUCT(type, name, doc)     /* flag is constant */
+  #define SHARK_NOTPRODUCT_FLAG_STRUCT(type, name, value, doc)
+#else
+  #define SHARK_DEVELOP_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &name, "{Shark}", DEFAULT },
+  #define SHARK_PD_DEVELOP_FLAG_STRUCT(type, name, doc)     { #type, XSTR(name), &name, "{Shark pd}", DEFAULT },
+  #define SHARK_NOTPRODUCT_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &name, "{Shark notproduct}", DEFAULT },
+#endif
 
 static Flag flagTable[] = {
  RUNTIME_FLAGS(RUNTIME_DEVELOP_FLAG_STRUCT, RUNTIME_PD_DEVELOP_FLAG_STRUCT, RUNTIME_PRODUCT_FLAG_STRUCT, RUNTIME_PD_PRODUCT_FLAG_STRUCT, RUNTIME_DIAGNOSTIC_FLAG_STRUCT, RUNTIME_EXPERIMENTAL_FLAG_STRUCT, RUNTIME_NOTPRODUCT_FLAG_STRUCT, RUNTIME_MANAGEABLE_FLAG_STRUCT, RUNTIME_PRODUCT_RW_FLAG_STRUCT, RUNTIME_LP64_PRODUCT_FLAG_STRUCT)
@@ -194,6 +206,9 @@
 #ifdef COMPILER2
  C2_FLAGS(C2_DEVELOP_FLAG_STRUCT, C2_PD_DEVELOP_FLAG_STRUCT, C2_PRODUCT_FLAG_STRUCT, C2_PD_PRODUCT_FLAG_STRUCT, C2_DIAGNOSTIC_FLAG_STRUCT, C2_EXPERIMENTAL_FLAG_STRUCT, C2_NOTPRODUCT_FLAG_STRUCT)
 #endif
+#ifdef SHARK
+ SHARK_FLAGS(SHARK_DEVELOP_FLAG_STRUCT, SHARK_PD_DEVELOP_FLAG_STRUCT, SHARK_PRODUCT_FLAG_STRUCT, SHARK_PD_PRODUCT_FLAG_STRUCT, SHARK_DIAGNOSTIC_FLAG_STRUCT, SHARK_NOTPRODUCT_FLAG_STRUCT)
+#endif
  {0, NULL, NULL}
 };
 
diff -Nru openjdk.orig/hotspot/src/share/vm/runtime/globals.hpp openjdk/hotspot/src/share/vm/runtime/globals.hpp
--- openjdk.orig/hotspot/src/share/vm/runtime/globals.hpp	2010-05-10 14:37:37.000000000 +0100
+++ openjdk/hotspot/src/share/vm/runtime/globals.hpp	2010-05-10 14:38:13.000000000 +0100
@@ -22,7 +22,7 @@
  *
  */
 
-#if !defined(COMPILER1) && !defined(COMPILER2)
+#if !defined(COMPILER1) && !defined(COMPILER2) && !defined(SHARK)
 define_pd_global(bool, BackgroundCompilation,        false);
 define_pd_global(bool, UseTLAB,                      false);
 define_pd_global(bool, CICompileOSR,                 false);
diff -Nru openjdk.orig/hotspot/src/share/vm/runtime/vm_version.cpp openjdk/hotspot/src/share/vm/runtime/vm_version.cpp
--- openjdk.orig/hotspot/src/share/vm/runtime/vm_version.cpp	2010-04-28 22:16:22.000000000 +0100
+++ openjdk/hotspot/src/share/vm/runtime/vm_version.cpp	2010-05-10 14:38:13.000000000 +0100
@@ -94,12 +94,16 @@
 #ifdef TIERED
   #define VMTYPE "Server"
 #else // TIERED
+#ifdef SHARK                                                                                                             
+  #define VMTYPE "Shark"
+#else
 #ifdef ZERO
   #define VMTYPE "Zero"
 #else // ZERO
    #define VMTYPE COMPILER1_PRESENT("Client")   \
                   COMPILER2_PRESENT("Server")
 #endif // ZERO
+#endif // SHARK
 #endif // TIERED
 #endif // KERNEL
 
diff -Nru openjdk.orig/hotspot/src/share/vm/utilities/macros.hpp openjdk/hotspot/src/share/vm/utilities/macros.hpp
--- openjdk.orig/hotspot/src/share/vm/utilities/macros.hpp	2010-04-28 22:16:22.000000000 +0100
+++ openjdk/hotspot/src/share/vm/utilities/macros.hpp	2010-05-10 14:38:13.000000000 +0100
@@ -151,9 +151,11 @@
 #if defined(IA32) || defined(AMD64)
 #define X86
 #define X86_ONLY(code) code
+#define NOT_X86(code)
 #else
 #undef X86
 #define X86_ONLY(code)
+#define NOT_X86(code) code
 #endif
 
 #ifdef IA32
