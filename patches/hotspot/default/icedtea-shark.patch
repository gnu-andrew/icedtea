--- openjdk/hotspot/src/share/vm/oops/methodOop.cpp.orig	2008-11-22 00:11:18.000000000 +0000
+++ openjdk/hotspot/src/share/vm/oops/methodOop.cpp	2008-12-03 14:33:48.000000000 +0000
@@ -727,10 +727,14 @@
   }
 
   OrderAccess::storestore();
+#ifdef SHARK
+  mh->_from_interpreted_entry = code->instructions_begin();
+#else
   mh->_from_compiled_entry = code->verified_entry_point();
   OrderAccess::storestore();
   // Instantly compiled code can execute.
   mh->_from_interpreted_entry = mh->get_i2c_entry();
+#endif // SHARK
 
 }
 
--- openjdk/hotspot/src/share/vm/memory/cardTableModRefBS.hpp.orig	2008-11-22 00:11:18.000000000 +0000
+++ openjdk/hotspot/src/share/vm/memory/cardTableModRefBS.hpp	2008-12-03 14:33:48.000000000 +0000
@@ -44,6 +44,7 @@
   friend class VMStructs;
   friend class CardTableRS;
   friend class CheckForUnmarkedOops; // Needs access to raw card bytes.
+  friend class SharkBuilder;
 #ifndef PRODUCT
   // For debugging.
   friend class GuaranteeNotModClosure;
--- openjdk/hotspot/src/share/vm/runtime/globals.cpp.orig	2008-11-22 00:11:18.000000000 +0000
+++ openjdk/hotspot/src/share/vm/runtime/globals.cpp	2008-12-03 14:33:48.000000000 +0000
@@ -176,6 +176,18 @@
   #define C2_NOTPRODUCT_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &name, "{C2 notproduct}", DEFAULT },
 #endif
 
+#define SHARK_PRODUCT_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &name, "{Shark product}", DEFAULT },
+#define SHARK_PD_PRODUCT_FLAG_STRUCT(type, name, doc)     { #type, XSTR(name), &name, "{Shark pd product}", DEFAULT },
+#define SHARK_DIAGNOSTIC_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &name, "{Shark diagnostic}", DEFAULT },
+#ifdef PRODUCT
+  #define SHARK_DEVELOP_FLAG_STRUCT(type, name, value, doc) /* flag is constant */
+  #define SHARK_PD_DEVELOP_FLAG_STRUCT(type, name, doc)     /* flag is constant */
+  #define SHARK_NOTPRODUCT_FLAG_STRUCT(type, name, value, doc)
+#else
+  #define SHARK_DEVELOP_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &name, "{Shark}", DEFAULT },
+  #define SHARK_PD_DEVELOP_FLAG_STRUCT(type, name, doc)     { #type, XSTR(name), &name, "{Shark pd}", DEFAULT },
+  #define SHARK_NOTPRODUCT_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &name, "{Shark notproduct}", DEFAULT },
+#endif
 
 static Flag flagTable[] = {
  RUNTIME_FLAGS(RUNTIME_DEVELOP_FLAG_STRUCT, RUNTIME_PD_DEVELOP_FLAG_STRUCT, RUNTIME_PRODUCT_FLAG_STRUCT, RUNTIME_PD_PRODUCT_FLAG_STRUCT, RUNTIME_DIAGNOSTIC_FLAG_STRUCT, RUNTIME_EXPERIMENTAL_FLAG_STRUCT, RUNTIME_NOTPRODUCT_FLAG_STRUCT, RUNTIME_MANAGEABLE_FLAG_STRUCT, RUNTIME_PRODUCT_RW_FLAG_STRUCT, RUNTIME_LP64_PRODUCT_FLAG_STRUCT)
@@ -189,6 +201,9 @@
 #ifdef COMPILER2
  C2_FLAGS(C2_DEVELOP_FLAG_STRUCT, C2_PD_DEVELOP_FLAG_STRUCT, C2_PRODUCT_FLAG_STRUCT, C2_PD_PRODUCT_FLAG_STRUCT, C2_DIAGNOSTIC_FLAG_STRUCT, C2_NOTPRODUCT_FLAG_STRUCT)
 #endif
+#ifdef SHARK
+ SHARK_FLAGS(SHARK_DEVELOP_FLAG_STRUCT, SHARK_PD_DEVELOP_FLAG_STRUCT, SHARK_PRODUCT_FLAG_STRUCT, SHARK_PD_PRODUCT_FLAG_STRUCT, SHARK_DIAGNOSTIC_FLAG_STRUCT, SHARK_NOTPRODUCT_FLAG_STRUCT)
+#endif
  {0, NULL, NULL}
 };
 
--- openjdk/hotspot/src/share/vm/runtime/vframeArray.cpp.orig	2008-11-22 00:11:18.000000000 +0000
+++ openjdk/hotspot/src/share/vm/runtime/vframeArray.cpp	2008-12-03 14:33:49.000000000 +0000
@@ -64,6 +64,11 @@
       assert(monitor->owner() == NULL || (!monitor->owner()->is_unlocked() && !monitor->owner()->has_bias_pattern()), "object must be null or locked, and unbiased");
       BasicObjectLock* dest = _monitors->at(index);
       dest->set_obj(monitor->owner());
+#ifdef SHARK
+      // XXX This can be removed when Shark knows
+      // which monitors are in use.
+      if (monitor->owner())
+#endif // SHARK
       monitor->lock()->move_to(monitor->owner(), dest->lock());
     }
   }
@@ -262,6 +267,11 @@
     top = iframe()->previous_monitor_in_interpreter_frame(top);
     BasicObjectLock* src = _monitors->at(index);
     top->set_obj(src->obj());
+#ifdef SHARK
+    // XXX This can be removed when Shark knows
+    // which monitors are in use.
+    if (src->obj())
+#endif // SHARK    
     src->lock()->move_to(src->obj(), top->lock());
   }
   if (ProfileInterpreter) {
--- openjdk/hotspot/src/share/vm/runtime/vm_version.cpp.orig	2008-12-03 14:23:37.000000000 +0000
+++ openjdk/hotspot/src/share/vm/runtime/vm_version.cpp	2008-12-03 14:33:48.000000000 +0000
@@ -94,6 +94,9 @@
 #ifdef TIERED
   #define VMTYPE "Server"
 #else
+#ifdef SHARK
+  #define VMTYPE "Shark"
+#else
 #if defined(COMPILER1) || defined(COMPILER2)
    #define VMTYPE COMPILER1_PRESENT("Client")   \
                   COMPILER2_PRESENT("Server")
@@ -104,6 +107,7 @@
   #define VMTYPE "Core"
 #endif // ZERO
 #endif // COMPILER1 || COMPILER2
+#endif // SHARK
 #endif // TIERED
 #endif // KERNEL
 
--- openjdk/hotspot/src/share/vm/runtime/deoptimization.cpp.orig	2008-11-22 00:11:18.000000000 +0000
+++ openjdk/hotspot/src/share/vm/runtime/deoptimization.cpp	2008-12-03 14:33:48.000000000 +0000
@@ -229,6 +229,7 @@
 
   }
 
+#ifndef SHARK
   // Compute the caller frame based on the sender sp of stub_frame and stored frame sizes info.
   CodeBlob* cb = stub_frame.cb();
   // Verify we have the right vframeArray
@@ -239,6 +240,10 @@
   assert(cb->is_deoptimization_stub() || cb->is_uncommon_trap_stub(), "just checking");
   Events::log("fetch unroll sp " INTPTR_FORMAT, unpack_sp);
 #endif
+#else
+  intptr_t* unpack_sp = stub_frame.sender(&dummy_map).unextended_sp();
+#endif // !SHARK
+  
   // This is a guarantee instead of an assert because if vframe doesn't match
   // we will unpack the wrong deoptimized frame and wind up in strange places
   // where it will be very difficult to figure out what went wrong. Better
@@ -349,7 +354,9 @@
 
   frame_pcs[0] = deopt_sender.raw_pc();
 
+#ifndef SHARK
   assert(CodeCache::find_blob_unsafe(frame_pcs[0]) != NULL, "bad pc");
+#endif // SHARK
 
   UnrollBlock* info = new UnrollBlock(array->frame_size() * BytesPerWord,
                                       caller_adjustment * BytesPerWord,
@@ -890,7 +897,20 @@
   // stuff a C2I adapter we can properly fill in the callee-save
   // register locations.
   frame caller = fr.sender(reg_map);
+#ifdef ZERO
+  int frame_size;
+  {
+    // In zero, frame::sp() is the *end* of the frame, so
+    // caller.sp() - fr.sp() is the size of the *caller*.
+    RegisterMap dummy_map(thread, false);
+    frame frame_1 = thread->last_frame();
+    frame frame_2 = frame_1.sender(&dummy_map);
+    assert(frame_2.sp() == fr.sp(), "should be");
+    frame_size = frame_2.sp() - frame_1.sp();
+  }
+#else
   int frame_size = caller.sp() - fr.sp();
+#endif // ZERO
 
   frame sender = caller;
 
@@ -1057,7 +1077,7 @@
 JRT_END
 
 
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
 void Deoptimization::load_class_by_index(constantPoolHandle constant_pool, int index, TRAPS) {
   // in case of an unresolved klass entry, load the class.
   if (constant_pool->tag_at(index).is_unresolved_klass()) {
@@ -1808,7 +1828,7 @@
     if (xtty != NULL)  xtty->tail("statistics");
   }
 }
-#else // COMPILER2
+#else // COMPILER2 || SHARK
 
 
 // Stubs for C1 only system.
@@ -1844,4 +1864,4 @@
   return buf;
 }
 
-#endif // COMPILER2
+#endif // COMPILER2 || SHARK
--- openjdk/hotspot/src/share/vm/runtime/globals.hpp.orig	2008-12-03 14:22:17.000000000 +0000
+++ openjdk/hotspot/src/share/vm/runtime/globals.hpp	2008-12-03 14:33:48.000000000 +0000
@@ -22,7 +22,7 @@
  *
  */
 
-#if !defined(COMPILER1) && !defined(COMPILER2)
+#if !defined(COMPILER1) && !defined(COMPILER2) && !defined(SHARK)
 define_pd_global(bool, BackgroundCompilation,        false);
 define_pd_global(bool, UseTLAB,                      false);
 define_pd_global(bool, CICompileOSR,                 false);
--- openjdk/hotspot/src/share/vm/code/nmethod.hpp.orig	2008-11-22 00:11:18.000000000 +0000
+++ openjdk/hotspot/src/share/vm/code/nmethod.hpp	2008-12-03 14:33:48.000000000 +0000
@@ -318,6 +318,7 @@
 
   bool is_compiled_by_c1() const;
   bool is_compiled_by_c2() const;
+  bool is_compiled_by_shark() const;
 
   // boundaries for different parts
   address code_begin         () const             { return _entry_point; }
--- openjdk/hotspot/src/share/vm/code/nmethod.cpp.orig	2008-11-22 00:11:18.000000000 +0000
+++ openjdk/hotspot/src/share/vm/code/nmethod.cpp	2008-12-03 14:33:48.000000000 +0000
@@ -65,6 +65,11 @@
   assert(compiler() != NULL, "must be");
   return compiler()->is_c2();
 }
+bool nmethod::is_compiled_by_shark() const {
+  if (is_native_method()) return false;
+  assert(compiler() != NULL, "must be");
+  return compiler()->is_shark();
+}
 
 
 
@@ -1567,6 +1572,7 @@
 // Method that knows how to preserve outgoing arguments at call. This method must be
 // called with a frame corresponding to a Java invoke
 void nmethod::preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, OopClosure* f) {
+#ifndef SHARK
   if (!method()->is_native()) {
     SimpleScopeDesc ssd(this, fr.pc());
     Bytecode_invoke* call = Bytecode_invoke_at(ssd.method(), ssd.bci());
@@ -1574,6 +1580,7 @@
     symbolOop signature = call->signature();
     fr.oops_compiled_arguments_do(signature, is_static, reg_map, f);
   }
+#endif // !SHARK
 }
 
 
@@ -2003,6 +2010,8 @@
     tty->print("(c1) ");
   } else if (is_compiled_by_c2()) {
     tty->print("(c2) ");
+  } else if (is_compiled_by_shark()) {
+    tty->print("(shark) ");
   } else {
     tty->print("(nm) ");
   }
--- openjdk/hotspot/src/share/vm/compiler/compileBroker.cpp.orig	2008-11-22 00:11:18.000000000 +0000
+++ openjdk/hotspot/src/share/vm/compiler/compileBroker.cpp	2008-12-03 14:33:48.000000000 +0000
@@ -554,6 +554,14 @@
 #endif
 #endif // COMPILER2
 
+#ifdef SHARK
+#if defined(COMPILER1) || defined(COMPILER2)
+#error "Can't use COMPILER1 or COMPILER2 with shark"
+#endif
+  _compilers[0] = new SharkCompiler();
+  _compilers[1] = _compilers[0];  
+#endif
+  
   // Initialize the CompileTask free list
   _task_free_list = NULL;
 
--- openjdk/hotspot/src/share/vm/compiler/abstractCompiler.hpp.orig	2008-11-22 00:11:18.000000000 +0000
+++ openjdk/hotspot/src/share/vm/compiler/abstractCompiler.hpp	2008-12-03 14:33:48.000000000 +0000
@@ -45,18 +45,26 @@
   // Missing feature tests
   virtual bool supports_native()                 { return true; }
   virtual bool supports_osr   ()                 { return true; }
-#if defined(TIERED) || ( !defined(COMPILER1) && !defined(COMPILER2))
+#if defined(TIERED) || ( !defined(COMPILER1) && !defined(COMPILER2) && !defined(SHARK))
   virtual bool is_c1   ()                        { return false; }
   virtual bool is_c2   ()                        { return false; }
+  virtual bool is_shark()                        { return false; }
 #else
 #ifdef COMPILER1
   bool is_c1   ()                                { return true; }
   bool is_c2   ()                                { return false; }
+  bool is_shark()                                { return false; }
 #endif // COMPILER1
 #ifdef COMPILER2
   bool is_c1   ()                                { return false; }
   bool is_c2   ()                                { return true; }
+  bool is_shark()                                { return false; }
 #endif // COMPILER2
+#ifdef SHARK
+  bool is_c1   ()                                { return false; }
+  bool is_c2   ()                                { return false; }
+  bool is_shark()                                { return true; }
+#endif // SHARK  
 #endif // TIERED
 
   // Customization
--- openjdk/hotspot/src/share/vm/ci/ciMethod.hpp.orig	2008-11-22 00:11:18.000000000 +0000
+++ openjdk/hotspot/src/share/vm/ci/ciMethod.hpp	2008-12-03 14:33:48.000000000 +0000
@@ -69,7 +69,7 @@
 
   // Optional liveness analyzer.
   MethodLiveness* _liveness;
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
   ciTypeFlow*     _flow;
 #endif
 
--- openjdk/hotspot/src/share/vm/ci/ciMethod.cpp.orig	2008-11-22 00:11:18.000000000 +0000
+++ openjdk/hotspot/src/share/vm/ci/ciMethod.cpp	2008-12-03 14:33:48.000000000 +0000
@@ -56,9 +56,9 @@
   _liveness           = NULL;
   _bcea = NULL;
   _method_blocks = NULL;
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
   _flow               = NULL;
-#endif // COMPILER2
+#endif // COMPILER2 || SHARK
 
   if (JvmtiExport::can_hotswap_or_post_breakpoint() && _is_compilable) {
     // 6328518 check hotswap conditions under the right lock.
@@ -124,9 +124,9 @@
   _bcea = NULL;
   _method_blocks = NULL;
   _method_data = NULL;
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
   _flow = NULL;
-#endif // COMPILER2
+#endif // COMPILER2 || SHARK
 }
 
 
@@ -294,34 +294,34 @@
 // ------------------------------------------------------------------
 // ciMethod::get_flow_analysis
 ciTypeFlow* ciMethod::get_flow_analysis() {
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
   if (_flow == NULL) {
     ciEnv* env = CURRENT_ENV;
     _flow = new (env->arena()) ciTypeFlow(env, this);
     _flow->do_flow();
   }
   return _flow;
-#else // COMPILER2
+#else // COMPILER2 || SHARK
   ShouldNotReachHere();
   return NULL;
-#endif // COMPILER2
+#endif // COMPILER2 || SHARK
 }
 
 
 // ------------------------------------------------------------------
 // ciMethod::get_osr_flow_analysis
 ciTypeFlow* ciMethod::get_osr_flow_analysis(int osr_bci) {
-#ifdef COMPILER2
+#if defined(COMPILER2) || defined(SHARK)
   // OSR entry points are always place after a call bytecode of some sort
   assert(osr_bci >= 0, "must supply valid OSR entry point");
   ciEnv* env = CURRENT_ENV;
   ciTypeFlow* flow = new (env->arena()) ciTypeFlow(env, this, osr_bci);
   flow->do_flow();
   return flow;
-#else // COMPILER2
+#else // COMPILER2 || SHARK
   ShouldNotReachHere();
   return NULL;
-#endif // COMPILER2
+#endif // COMPILER2 || SHARK
 }
 
 // ------------------------------------------------------------------
