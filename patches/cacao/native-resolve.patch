
# HG changeset patch
# User Stefan Ring <stefan@complang.tuwien.ac.at>
# Date 1244023392 -7200
# Node ID 8e8a38453f6c1e11e057457daf979a1acb40d9bf
# Parent 5fdb98095047abf89f3d3298417499c2c06f8d56
Fixes PR128 (changed resolution order for native methods).
* src/native/native.c (native_method_resolve): Consider internal
methods before descending into java.lang.ClassLoader.

--- cacao/cacao/src/native/native.c	Wed Jun 03 01:35:48 2009 +0200
+++ cacao/cacao/src/native/native.c	Wed Jun 03 12:03:12 2009 +0200
@@ -1,6 +1,6 @@
 /* src/native/native.c - native library support
 
-   Copyright (C) 1996-2005, 2006, 2007, 2008
+   Copyright (C) 1996-2005, 2006, 2007, 2008, 2009
    CACAOVM - Verein zur Foerderung der freien virtuellen Maschine CACAO
 
    This file is part of CACAO.
@@ -529,39 +529,47 @@
 
 	newname = native_make_overloaded_function(name, m->descriptor);
 
+	/* Try to find the native function symbol in the main program. */
+
+	f = native_method_find(m);
+
+	if (f != NULL)
+		if (opt_verbosejni)
+			printf("internal ]\n");
+
+#if defined(ENABLE_DL)
 	/* check the library hash entries of the classloader of the
 	   methods's class  */
 
-	f = NULL;
+	if (f == NULL) {
+		/* Get the classloader. */
 
-#if defined(ENABLE_DL)
-	/* Get the classloader. */
+		cl = class_get_classloader(m->clazz);
 
-	cl = class_get_classloader(m->clazz);
+		/* normally addresses are aligned to 4, 8 or 16 bytes */
 
-	/* normally addresses are aligned to 4, 8 or 16 bytes */
+		key  = ((u4) (ptrint) cl) >> 4;                       /* align to 16-byte */
+		slot = key & (hashtable_library->size - 1);
+		le   = hashtable_library->ptr[slot];
 
-	key  = ((u4) (ptrint) cl) >> 4;                       /* align to 16-byte */
-	slot = key & (hashtable_library->size - 1);
-	le   = hashtable_library->ptr[slot];
+		/* iterate through loaders in this hash slot */
 
-	/* iterate through loaders in this hash slot */
+		while ((le != NULL) && (f == NULL)) {
+			/* iterate through names in this loader */
 
-	while ((le != NULL) && (f == NULL)) {
-		/* iterate through names in this loader */
+			ne = le->namelink;
 
-		ne = le->namelink;
-			
-		while ((ne != NULL) && (f == NULL)) {
-			f = (functionptr) (ptrint) system_dlsym(ne->handle, name->text);
+			while ((ne != NULL) && (f == NULL)) {
+				f = (functionptr) (ptrint) system_dlsym(ne->handle, name->text);
 
-			if (f == NULL)
-				f = (functionptr) (ptrint) system_dlsym(ne->handle, newname->text);
+				if (f == NULL)
+					f = (functionptr) (ptrint) system_dlsym(ne->handle, newname->text);
 
-			ne = ne->hashlink;
+				ne = ne->hashlink;
+			}
+
+			le = le->hashlink;
 		}
-
-		le = le->hashlink;
 	}
 
 # if defined(WITH_JAVA_RUNTIME_LIBRARY_OPENJDK)
@@ -577,23 +585,22 @@
 									 class_java_lang_ClassLoader,
 									 true);
 
-		if (method_findNative == NULL)
-			return NULL;
+		if (method_findNative != NULL) {
+			/* try the normal name */
 
-		/* try the normal name */
-
-		s = javastring_new(name);
-
-		f = (functionptr) (intptr_t) vm_call_method_long(method_findNative,
-														 NULL, cl, s);
-
-		/* if not found, try the mangled name */
-
-		if (f == NULL) {
-			s = javastring_new(newname);
+			s = javastring_new(name);
 
 			f = (functionptr) (intptr_t) vm_call_method_long(method_findNative,
 															 NULL, cl, s);
+
+			/* if not found, try the mangled name */
+
+			if (f == NULL) {
+				s = javastring_new(newname);
+
+				f = (functionptr) (intptr_t) vm_call_method_long(method_findNative,
+																 NULL, cl, s);
+			}
 		}
 	}
 # endif
@@ -602,17 +609,6 @@
 		if (opt_verbosejni)
 			printf("JNI ]\n");
 #endif
-
-	/* If not found, try to find the native function symbol in the
-	   main program. */
-
-	if (f == NULL) {
-		f = native_method_find(m);
-
-		if (f != NULL)
-			if (opt_verbosejni)
-				printf("internal ]\n");
-	}
 
 #if defined(ENABLE_JVMTI)
 	/* fire Native Method Bind event */

