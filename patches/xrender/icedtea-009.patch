
# HG changeset patch
# User ceisserer
# Date 1228079698 -3600
# Node ID c72b1c0435c0b262a78dea6ee7109634a82eb574
# Parent 0ae86de6889ebd18b1a8f0232c50ce2c3049bc40
- Improved performance of non-solid operations
- Improved performance of GPUs not supporting A8+A8 composition, but are capable of XCopyArea'ing with A8->A8 with their 2D engines (i830, GF6/7)
- X11/XR pipeline initialization in X11GraphicsDevice was mixed up

--- openjdk/jdk/src/solaris/classes/sun/awt/X11GraphicsDevice.java	Thu Oct 23 19:11:45 2008 +0200
+++ openjdk/jdk/src/solaris/classes/sun/awt/X11GraphicsDevice.java	Sun Nov 30 22:14:58 2008 +0100
@@ -151,7 +151,7 @@ public class X11GraphicsDevice
             }
 
             boolean glxSupported = X11GraphicsEnvironment.isGLXAvailable();
-            boolean xrender = X11GraphicsEnvironment.isXRenderAvailable();
+            boolean xrenderSupported = X11GraphicsEnvironment.isXRenderAvailable();
             
             boolean dbeSupported = isDBESupported();
             if (dbeSupported && doubleBufferVisuals == null) {
@@ -169,7 +169,7 @@ public class X11GraphicsDevice
                         (dbeSupported &&
                          doubleBufferVisuals.contains(Integer.valueOf(visNum)));
                     
-                    if(!xrender)
+                    if(xrenderSupported)
                     {
                         ret[i] = XRGraphicsConfig.getConfig(this, visNum, depth,
                                 getConfigColormap(i, screen),
--- openjdk/jdk/src/solaris/classes/sun/java2d/xr/XRMaskFill.java	Thu Oct 23 19:11:45 2008 +0200
+++ openjdk/jdk/src/solaris/classes/sun/java2d/xr/XRMaskFill.java	Sun Nov 30 22:14:58 2008 +0100
@@ -104,6 +104,7 @@ public class XRMaskFill extends MaskFill
 
 	    maskFill(sData.getNativeOps(), x, y, w, h, maskoff, maskscan,
 		    mask != null ? mask.length : 0, mask);
+	
 	} finally {
 	    SunToolkit.awtUnlock();
 	}
--- openjdk/jdk/src/solaris/classes/sun/java2d/xr/XRPMBlitLoops.java	Thu Oct 23 19:11:45 2008 +0200
+++ openjdk/jdk/src/solaris/classes/sun/java2d/xr/XRPMBlitLoops.java	Sun Nov 30 22:14:58 2008 +0100
@@ -211,6 +211,7 @@ class X11PMTransformedBlit extends Trans
 		lastMaskHeight = maskHeight;
 	    } else {
 		int repeat = xrInterpolationType <= XRUtils.FAST ? XRUtils.RepeatNone : XRUtils.RepeatPad;
+		
 		x11sdSrc.validateAsSource(trx, repeat, xrInterpolationType);
 		XRPMBlitLoops.nativeTransformedRenderBlit(src.getNativeOps(), dst.getNativeOps(), 0, 0, bounds.x, bounds.y, bounds.width,
 			bounds.height, 0, 0, 0, 0, 0, 0, -1, -1, 0, 0);
--- openjdk/jdk/src/solaris/classes/sun/java2d/xr/XRSurfaceData.java	Thu Oct 23 19:11:45 2008 +0200
+++ openjdk/jdk/src/solaris/classes/sun/java2d/xr/XRSurfaceData.java	Sun Nov 30 22:14:58 2008 +0100
@@ -399,23 +399,6 @@ public abstract class XRSurfaceData exte
 	this.preferredInterpolation = interpolation;
     }
 
-    /*
-     * For now those shape-clips are used for transformed images, because
-     * transformed image for now would invalidate a much larger area that they
-     * are intended to do. However as soon as the transformed-mask approach I am
-     * working on turns out to work well, those will be dropped.
-     */
-    public void setShapeClip(Shape shape) {
-	Region shapeClip = Region.getInstance(validatedClip, shape, null);
-	XRSetClip(getNativeOps(), shapeClip.getLoX(), shapeClip.getLoY(), shapeClip.getHiX(), shapeClip.getHiY(), shapeClip.isRectangular() ? null
-		: shapeClip);
-    }
-
-    public void resetShapeClip() {
-	XRSetClip(getNativeOps(), validatedClip.getLoX(), validatedClip.getLoY(), validatedClip.getHiX(), validatedClip.getHiY(), validatedClip
-		.isRectangular() ? null : validatedClip);
-    }
-
     /**
      * Validate the source with the preferred interpolation set sometimes
      * earlier.
@@ -432,32 +415,25 @@ public abstract class XRSurfaceData exte
      * applied when used as source as well as destination.
      */
     void validateAsSource(AffineTransform sxForm, int repeat, int interpolation) {
-	// System.out.println("Source:
-	// "+getBounds().width+"/"+getBounds().height);
 
 	if (validatedClip != null) {
 	    validatedClip = null;
 	    XRResetClip(getNativeOps());
-	    // System.out.println("Clip ge-reseted");
 	}
 
 	if (validatedRepeat != repeat) {
 	    validatedRepeat = repeat;
 	    XRSetRepeat(getNativeOps(), repeat);
-	    // System.out.println("Repeat ge-reseted");
 	}
 
 	if (sxForm == null) {
 	    if (transformInUse) {
 		validatedSourceTransform.setToIdentity();
-		// System.out.println("Transform ge-reseted");
 		XRSetTransform(validatedSourceTransform);
 		transformInUse = false;
 	    }
 	} else {
 	    if (!transformInUse || (transformInUse && !sxForm.equals(validatedSourceTransform))) {
-
-		// System.out.println("Setze transform: "+sxForm);
 
 		validatedSourceTransform.setTransform(sxForm.getScaleX(), sxForm.getShearY(), sxForm.getShearX(), sxForm.getScaleY(), sxForm
 			.getTranslateX(), sxForm.getTranslateY());
@@ -677,7 +653,7 @@ public abstract class XRSurfaceData exte
 	} catch (NoninvertibleTransformException ex) {
 	    at.setToIdentity(); /* TODO: Right thing to do in this case? */
 	}
-
+	
 	x11SrcData.validateAsSource(at, XRUtils.RepeatNormal, XRUtils.ATransOpToXRQuality(sg2d.interpolationType));
 
 	XRSetTexturePaint(srcData.getNativeOps());
@@ -739,6 +715,8 @@ public abstract class XRSurfaceData exte
 	// validate clip
 	if (updateClip) {
 	    if (clip != null) {
+		//    System.out.println("Set paint clip: "+getBounds().width+":"+getBounds().height);
+		//    Thread.dumpStack();
 		XRSetClip(getNativeOps(), clip.getLoX(), clip.getLoY(), clip.getHiX(), clip.getHiY(), clip.isRectangular() ? null : clip);
 	    } else {
 		XRResetClip(getNativeOps());
--- openjdk/jdk/src/solaris/native/sun/java2d/x11/MaskBuffer.c	Thu Oct 23 19:11:45 2008 +0200
+++ openjdk/jdk/src/solaris/native/sun/java2d/x11/MaskBuffer.c	Sun Nov 30 22:14:58 2008 +0100
@@ -77,12 +77,14 @@ MaskBuffer* initMaskBuffer(Window window
 
   buffer->validatedGCAlpha = 1.0f;
   XGCValues values;
+  values.graphics_exposures = 0;
+
   values.foreground = 255;
-  buffer->drawLineGC = XCreateGC(awt_display, buffer->lineMaskPixmap, GCForeground, &values);
+  buffer->drawLineGC = XCreateGC(awt_display, buffer->lineMaskPixmap, GCForeground | GCGraphicsExposures, &values);
   /*Invisible GC for readback assistance*/
   values.foreground = 0;
-  buffer->clearLineGC = XCreateGC(awt_display, buffer->lineMaskPixmap, GCForeground, &values);
-  buffer->maskGC = XCreateGC(awt_display, buffer->maskPixmap, 0, &values);
+  buffer->clearLineGC = XCreateGC(awt_display, buffer->lineMaskPixmap, GCForeground | GCGraphicsExposures, &values);
+  buffer->maskGC = XCreateGC(awt_display, buffer->maskPixmap, GCGraphicsExposures, &values);
  
   buffer->alphaData = malloc(32*32);
   buffer->alphaImg = XCreateImage(awt_display, &buffer->maskPixmap, 8, ZPixmap, 0, (char *) buffer->alphaData, 32, 32, 8, 0);
@@ -376,7 +378,11 @@ void fillMask(MaskBuffer* buf, Picture d
             }
 
             if(rectList->used > 0) {
-               XRenderComposite (awt_display, PictOpSrc, buf->lineMaskPicture, None, buf->maskPicture, tile->dirtyLineArea.x, tile->dirtyLineArea.y, 0, 0, tile->dirtyLineArea.x, tile->dirtyLineArea.y, (tile->dirtyLineArea.x2 - tile->dirtyLineArea.x), (tile->dirtyLineArea.y2 - tile->dirtyLineArea.y)); 
+               if(lineList->used > 0) {
+                 XCopyArea(awt_display, buf->lineMaskPixmap, buf->maskPixmap, buf->maskGC, tile->dirtyLineArea.x, tile->dirtyLineArea.y, (tile->dirtyLineArea.x2 - tile->dirtyLineArea.x), (tile->dirtyLineArea.y2 - tile->dirtyLineArea.y), tile->dirtyLineArea.x, tile->dirtyLineArea.y);
+                 //XRenderComposite (awt_display, PictOpSrc, buf->lineMaskPicture, None, buf->maskPicture, tile->dirtyLineArea.x, tile->dirtyLineArea.y, 0, 0, tile->dirtyLineArea.x, tile->dirtyLineArea.y, (tile->dirtyLineArea.x2 - tile->dirtyLineArea.x), (tile->dirtyLineArea.y2 - tile->dirtyLineArea.y)); 
+               }
+
                XRenderFillRectangles (awt_display, PictOpSrc, buf->maskPicture, &maskColor, (XRectangle*) rectList->elements, rectList->used);
                mask = buf->maskPicture;
                clearXRList(rectList);
@@ -389,7 +395,7 @@ void fillMask(MaskBuffer* buf, Picture d
 
              /* Clear diagonal lines with lines again,
                 to avoid the sysmem copy marked "dirty" causing migration for the next lines*/
-             if(lineList->used != 0) {
+             if(lineList->used > 0) {
                XDrawSegments(awt_display, buf->lineMaskPixmap, buf->clearLineGC, (XSegment *) lineList->elements, lineList->used);
                clearXRList(lineList);
 	     }

