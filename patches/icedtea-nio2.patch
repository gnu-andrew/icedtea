diff -Nru openjdk.orig/jdk/make/docs/CORE_PKGS.gmk openjdk/jdk/make/docs/CORE_PKGS.gmk
--- openjdk.orig/jdk/make/docs/CORE_PKGS.gmk	2009-02-05 08:44:13.000000000 +0000
+++ openjdk/jdk/make/docs/CORE_PKGS.gmk	2009-02-11 23:47:38.000000000 +0000
@@ -110,6 +110,9 @@
   java.nio.channels.spi                          \
   java.nio.charset                               \
   java.nio.charset.spi                           \
+  java.nio.file					 \
+  java.nio.file.attribute			 \
+  java.nio.file.spi				 \
   java.rmi                                       \
   java.rmi.activation                            \
   java.rmi.dgc                                   \
diff -Nru openjdk.orig/jdk/make/java/nio/FILES_java.gmk openjdk/jdk/make/java/nio/FILES_java.gmk
--- openjdk.orig/jdk/make/java/nio/FILES_java.gmk	2009-02-11 23:12:43.000000000 +0000
+++ openjdk/jdk/make/java/nio/FILES_java.gmk	2009-02-20 11:03:22.000000000 +0000
@@ -149,7 +149,147 @@
 	java/lang/StringCoding.java \
 	\
 	sun/misc/Cleaner.java \
-	sun/util/PreHashedMap.java
+	sun/util/PreHashedMap.java \
+	\
+	java/net/ProtocolFamily.java \
+	java/net/SocketOption.java \
+	java/net/StandardProtocolFamily.java \
+	java/net/StandardSocketOption.java \
+	java/nio/channels/AsynchronousByteChannel.java \
+	java/nio/channels/AsynchronousChannel.java \
+	java/nio/channels/AsynchronousChannelGroup.java \
+	java/nio/channels/AsynchronousDatagramChannel.java \
+	java/nio/channels/AsynchronousFileChannel.java \
+	java/nio/channels/AsynchronousServerSocketChannel.java \
+	java/nio/channels/AsynchronousSocketChannel.java \
+	java/nio/channels/Channels.java \
+	java/nio/channels/CompletionHandler.java \
+	java/nio/channels/DatagramChannel.java \
+	java/nio/channels/FileChannel.java \
+	java/nio/channels/FileLock.java \
+	java/nio/channels/MembershipKey.java \
+	java/nio/channels/MulticastChannel.java \
+	java/nio/channels/NetworkChannel.java \
+	java/nio/channels/SeekableByteChannel.java \
+	java/nio/channels/spi/AsynchronousChannelProvider.java \
+	java/nio/channels/spi/SelectorProvider.java \
+	java/nio/file/AccessDeniedException.java \
+	java/nio/file/AccessMode.java \
+	java/nio/file/AtomicMoveNotSupportedException.java \
+	java/nio/file/ClosedDirectoryStreamException.java \
+	java/nio/file/ClosedFileSystemException.java \
+	java/nio/file/ClosedWatchServiceException.java \
+	java/nio/file/CopyOption.java \
+	java/nio/file/DirectoryNotEmptyException.java \
+	java/nio/file/DirectoryStream.java \
+	java/nio/file/DirectoryStreamFilters.java \
+	java/nio/file/FileAction.java \
+	java/nio/file/FileAlreadyExistsException.java \
+	java/nio/file/FileRef.java \
+	java/nio/file/FileStore.java \
+	java/nio/file/FileSystem.java \
+	java/nio/file/FileSystemAlreadyExistsException.java \
+	java/nio/file/FileSystemException.java \
+	java/nio/file/FileSystemNotFoundException.java \
+	java/nio/file/FileSystems.java \
+	java/nio/file/FileTreeWalker.java \
+	java/nio/file/FileVisitOption.java \
+	java/nio/file/FileVisitResult.java \
+	java/nio/file/FileVisitor.java \
+	java/nio/file/Files.java \
+	java/nio/file/InvalidPathException.java \
+	java/nio/file/LinkPermission.java \
+	java/nio/file/NoSuchFileException.java \
+	java/nio/file/NotDirectoryException.java \
+	java/nio/file/NotLinkException.java \
+	java/nio/file/OpenOption.java \
+	java/nio/file/Path.java \
+	java/nio/file/PathMatcher.java \
+	java/nio/file/Paths.java \
+	java/nio/file/ProviderMismatchException.java \
+	java/nio/file/ProviderNotFoundException.java \
+	java/nio/file/ReadOnlyFileSystemException.java \
+	java/nio/file/SecureDirectoryStream.java \
+	java/nio/file/SimpleFileVisitor.java \
+	java/nio/file/StandardCopyOption.java \
+	java/nio/file/StandardOpenOption.java \
+	java/nio/file/StandardWatchEventKind.java \
+	java/nio/file/WatchEvent.java \
+	java/nio/file/WatchKey.java \
+	java/nio/file/WatchService.java \
+	java/nio/file/Watchable.java \
+	\
+	java/nio/file/attribute/AclEntry.java \
+	java/nio/file/attribute/AclEntryFlag.java \
+	java/nio/file/attribute/AclEntryPermission.java \
+	java/nio/file/attribute/AclEntryType.java \
+	java/nio/file/attribute/AclFileAttributeView.java \
+	java/nio/file/attribute/AttributeView.java \
+	java/nio/file/attribute/Attributes.java \
+	java/nio/file/attribute/BasicFileAttributeView.java \
+	java/nio/file/attribute/BasicFileAttributes.java \
+	java/nio/file/attribute/DosFileAttributeView.java \
+	java/nio/file/attribute/DosFileAttributes.java \
+	java/nio/file/attribute/FileAttribute.java \
+	java/nio/file/attribute/FileAttributeView.java \
+	java/nio/file/attribute/FileOwnerAttributeView.java \
+	java/nio/file/attribute/FileStoreAttributeView.java \
+	java/nio/file/attribute/FileStoreSpaceAttributeView.java \
+	java/nio/file/attribute/FileStoreSpaceAttributes.java \
+	java/nio/file/attribute/GroupPrincipal.java \
+	java/nio/file/attribute/NamedAttributeView.java \
+	java/nio/file/attribute/PosixFileAttributeView.java \
+	java/nio/file/attribute/PosixFileAttributes.java \
+	java/nio/file/attribute/PosixFilePermission.java \
+	java/nio/file/attribute/PosixFilePermissions.java \
+	java/nio/file/attribute/UserPrincipal.java \
+	java/nio/file/attribute/UserPrincipalLookupService.java \
+	java/nio/file/attribute/UserPrincipalNotFoundException.java \
+	\
+	java/nio/file/spi/AbstractPath.java \
+	java/nio/file/spi/FileSystemProvider.java \
+	java/nio/file/spi/FileTypeDetector.java \
+	\
+	java/util/concurrent/ScheduledThreadPoolExecutor.java \
+	\
+	com/sun/nio/file/ExtendedCopyOption.java \
+	com/sun/nio/file/ExtendedOpenOption.java \
+	com/sun/nio/file/ExtendedWatchEventModifier.java \
+	\
+	sun/nio/ch/AbstractFuture.java \
+	sun/nio/ch/AsynchronousChannelGroupImpl.java \
+	sun/nio/ch/AsynchronousFileChannelImpl.java \
+	sun/nio/ch/AsynchronousServerSocketChannelImpl.java \
+	sun/nio/ch/AsynchronousSocketChannelImpl.java \
+	sun/nio/ch/Cancellable.java \
+	sun/nio/ch/CompletedFuture.java \
+	sun/nio/ch/DefaultAsynchronousChannelProvider.java \
+	sun/nio/ch/FileDispatcher.java \
+	sun/nio/ch/FileLockImpl.java \
+	sun/nio/ch/FileLockTable.java \
+	sun/nio/ch/Groupable.java \
+	sun/nio/ch/Invoker.java \
+	sun/nio/ch/PendingFuture.java \
+	sun/nio/ch/SimpleAsynchronousDatagramChannelImpl.java \
+	sun/nio/ch/ThreadPool.java \
+	\
+	sun/nio/fs/AbstractAclFileAttributeView.java \
+	sun/nio/fs/AbstractBasicFileAttributeView.java \
+	sun/nio/fs/AbstractFileStoreSpaceAttributeView.java \
+	sun/nio/fs/AbstractFileTypeDetector.java \
+	sun/nio/fs/AbstractPoller.java \
+	sun/nio/fs/AbstractNamedAttributeView.java \
+	sun/nio/fs/AbstractWatchKey.java \
+	sun/nio/fs/AbstractWatchService.java \
+	sun/nio/fs/Cancellable.java \
+	sun/nio/fs/DefaultFileSystemProvider.java \
+	sun/nio/fs/DefaultFileTypeDetector.java \
+	sun/nio/fs/FileOwnerAttributeViewImpl.java \
+	sun/nio/fs/Globs.java \
+	sun/nio/fs/MimeType.java \
+	sun/nio/fs/NativeBuffer.java \
+	sun/nio/fs/NativeBuffers.java \
+	sun/nio/fs/Reflect.java \
 
 # Generated coder classes
 #
@@ -267,7 +407,14 @@
 	\
 	java/nio/charset/CharacterCodingException.java \
 	java/nio/charset/IllegalCharsetNameException.java \
-	java/nio/charset/UnsupportedCharsetException.java
+	java/nio/charset/UnsupportedCharsetException.java \
+	\
+	java/nio/channels/AcceptPendingException.java \
+	java/nio/channels/IllegalChannelGroupException.java \
+	java/nio/channels/InterruptedByTimeoutException.java \
+	java/nio/channels/ReadPendingException.java \
+	java/nio/channels/ShutdownChannelGroupException.java \
+	java/nio/channels/WritePendingException.java 
 
 FILES_gen_sbcs = \
 	sun/nio/cs/ISO_8859_2.java \
diff -Nru openjdk.orig/jdk/make/java/nio/Makefile openjdk/jdk/make/java/nio/Makefile
--- openjdk.orig/jdk/make/java/nio/Makefile	2009-02-11 23:12:43.000000000 +0000
+++ openjdk/jdk/make/java/nio/Makefile	2009-02-11 23:35:40.000000000 +0000
@@ -40,6 +40,11 @@
 SNIO_SRC = $(SHARE_SRC)/classes/sun/nio
 SNIO_GEN = $(GENSRCDIR)/sun/nio
 
+INIO_SRC = $(SHARE_SRC)/classes/org/classpath/icedtea/java/nio
+INIO_GEN = $(GENSRCDIR)/org/classpath/icedtea/java/nio
+
+SERVICES = $(CLASSBINDIR)/META-INF/services
+
 #
 # Files to compile
 #
@@ -56,30 +61,128 @@
         sun/nio/ch/DevPollSelectorProvider.java \
 	sun/nio/ch/InheritedChannel.java \
         sun/nio/ch/PollSelectorProvider.java \
-        sun/nio/ch/PollSelectorImpl.java
+        sun/nio/ch/PollSelectorImpl.java \
+	sun/nio/ch/Port.java \
+	sun/nio/ch/SimpleAsynchronousFileChannelImpl.java \
+	sun/nio/ch/SolarisAsynchronousChannelProvider.java \
+	sun/nio/ch/SolarisEventPort.java \
+	sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java \
+	sun/nio/ch/UnixAsynchronousSocketChannelImpl.java \
+	\
+	sun/nio/fs/GnomeFileTypeDetector.java \
+	sun/nio/fs/PollingWatchService.java \
+	sun/nio/fs/SolarisAclFileAttributeView.java \
+	sun/nio/fs/SolarisFileStore.java \
+	sun/nio/fs/SolarisFileSystem.java \
+	sun/nio/fs/SolarisFileSystemProvider.java \
+	sun/nio/fs/SolarisNamedAttributeView.java \
+	sun/nio/fs/SolarisNativeDispatcher.java \
+	sun/nio/fs/SolarisWatchService.java \
+	sun/nio/fs/UnixChannelFactory.java \
+	sun/nio/fs/UnixCopyFile.java \
+	sun/nio/fs/UnixDirectoryStream.java \
+	sun/nio/fs/UnixException.java \
+	sun/nio/fs/UnixFileAttributeViews.java \
+	sun/nio/fs/UnixFileAttributes.java \
+	sun/nio/fs/UnixFileKey.java \
+	sun/nio/fs/UnixFileModeAttribute.java \
+	sun/nio/fs/UnixFileStore.java \
+	sun/nio/fs/UnixFileStoreAttributes.java \
+	sun/nio/fs/UnixFileSystem.java \
+	sun/nio/fs/UnixFileSystemProvider.java \
+	sun/nio/fs/UnixMountEntry.java \
+	sun/nio/fs/UnixNativeDispatcher.java \
+	sun/nio/fs/UnixPath.java \
+	sun/nio/fs/UnixSecureDirectoryStream.java \
+	sun/nio/fs/UnixUriUtils.java \
+	sun/nio/fs/UnixUserPrincipals.java
 
 FILES_c += \
         DevPollArrayWrapper.c \
 	InheritedChannel.c \
 	NativeThread.c \
-        PollArrayWrapper.c
+        PollArrayWrapper.c \
+	SolarisEventPort.c \
+	UnixAsynchronousServerSocketChannelImpl.c \
+	UnixAsynchronousSocketChannelImpl.c \
+	\
+	GnomeFileTypeDetector.c \
+	SolarisNativeDispatcher.c \
+	SolarisWatchService.c \
+	UnixCopyFile.c \
+	UnixNativeDispatcher.c
 
 FILES_export += \
 	sun/nio/ch/DevPollArrayWrapper.java \
 	sun/nio/ch/InheritedChannel.java \
-	sun/nio/ch/NativeThread.java
+	sun/nio/ch/NativeThread.java \
+	sun/nio/ch/SolarisEventPort.java \
+	sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java \
+	sun/nio/ch/UnixAsynchronousSocketChannelImpl.java \
+	\
+	sun/nio/fs/GnomeFileTypeDetector.java \
+	sun/nio/fs/SolarisNativeDispatcher.java \
+	sun/nio/fs/SolarisWatchService.java \
+	sun/nio/fs/UnixCopyFile.java \
+	sun/nio/fs/UnixNativeDispatcher.java
+
+FILES_gen += \
+	sun/nio/fs/SolarisConstants.java \
+	sun/nio/fs/UnixConstants.java
 endif # PLATFORM = solaris
 
 ifeq ($(PLATFORM), windows)
 FILES_java += \
+	sun/nio/ch/Iocp.java \
+	sun/nio/ch/PendingIoCache.java \
+	sun/nio/ch/WindowsAsynchronousChannelProvider.java \
+	sun/nio/ch/WindowsAsynchronousFileChannelImpl.java \
+	sun/nio/ch/WindowsAsynchronousServerSocketChannelImpl.java \
+	sun/nio/ch/WindowsAsynchronousSocketChannelImpl.java \
         sun/nio/ch/WindowsSelectorImpl.java \
-        sun/nio/ch/WindowsSelectorProvider.java
+        sun/nio/ch/WindowsSelectorProvider.java \
+	\
+	sun/nio/fs/RegistryFileTypeDetector.java \
+	sun/nio/fs/WindowsAclFileAttributeView.java \
+	sun/nio/fs/WindowsChannelFactory.java \
+	sun/nio/fs/WindowsConstants.java \
+	sun/nio/fs/WindowsDirectoryStream.java \
+	sun/nio/fs/WindowsException.java \
+	sun/nio/fs/WindowsFileAttributeViews.java \
+	sun/nio/fs/WindowsFileAttributes.java \
+	sun/nio/fs/WindowsFileCopy.java \
+	sun/nio/fs/WindowsFileStore.java \
+	sun/nio/fs/WindowsFileSystem.java \
+	sun/nio/fs/WindowsFileSystemProvider.java \
+	sun/nio/fs/WindowsLinkSupport.java \
+	sun/nio/fs/WindowsNamedAttributeView.java \
+	sun/nio/fs/WindowsNativeDispatcher.java \
+	sun/nio/fs/WindowsPath.java \
+	sun/nio/fs/WindowsPathParser.java \
+	sun/nio/fs/WindowsPathType.java \
+	sun/nio/fs/WindowsSecurity.java \
+	sun/nio/fs/WindowsSecurityDescriptor.java \
+	sun/nio/fs/WindowsUriSupport.java \
+	sun/nio/fs/WindowsUserPrincipals.java \
+	sun/nio/fs/WindowsWatchService.java
 
 FILES_c += \
+	Iocp.c \
+	RegistryFileTypeDetector.c \
+	WindowsAsynchronousFileChannelImpl.c \
+	WindowsAsynchronousServerSocketChannelImpl.c \
+	WindowsAsynchronousSocketChannelImpl.c \
+	WindowsNativeDispatcher.c \
         WindowsSelectorImpl.c
 
 FILES_export += \
+	sun/nio/ch/Iocp.java \
+	sun/nio/ch/WindowsAsynchronousFileChannelImpl.java \
+	sun/nio/ch/WindowsAsynchronousServerSocketChannelImpl.java \
+	sun/nio/ch/WindowsAsynchronousSocketChannelImpl.java \
 	sun/nio/ch/WindowsSelectorImpl.java
+	sun/nio/fs/WindowsNativeDispatcher.java \
+	sun/nio/fs/RegistryFileTypeDetector.java
 endif # PLATFORM = windows
 
 ifeq ($(PLATFORM), linux)
@@ -89,27 +192,83 @@
 	sun/nio/ch/DevPollSelectorImpl.java \
 	sun/nio/ch/DevPollSelectorProvider.java \
 	sun/nio/ch/EPollArrayWrapper.java \
+	sun/nio/ch/EPollPort.java \
 	sun/nio/ch/EPollSelectorProvider.java \
 	sun/nio/ch/EPollSelectorImpl.java \
 	sun/nio/ch/InheritedChannel.java \
+	sun/nio/ch/LinuxAsynchronousChannelProvider.java \
         sun/nio/ch/PollSelectorProvider.java \
-        sun/nio/ch/PollSelectorImpl.java
+        sun/nio/ch/PollSelectorImpl.java \
+	sun/nio/ch/Port.java \
+	sun/nio/ch/SimpleAsynchronousFileChannelImpl.java \
+	sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java \
+	sun/nio/ch/UnixAsynchronousSocketChannelImpl.java \
+	\
+	sun/nio/fs/GnomeFileTypeDetector.java \
+	sun/nio/fs/LinuxDosFileAttributeView.java \
+	sun/nio/fs/LinuxFileStore.java \
+	sun/nio/fs/LinuxFileSystem.java \
+	sun/nio/fs/LinuxFileSystemProvider.java \
+	sun/nio/fs/LinuxNamedAttributeView.java \
+	sun/nio/fs/LinuxNativeDispatcher.java \
+	sun/nio/fs/LinuxWatchService.java \
+	sun/nio/fs/PollingWatchService.java \
+	sun/nio/fs/UnixChannelFactory.java \
+	sun/nio/fs/UnixCopyFile.java \
+	sun/nio/fs/UnixDirectoryStream.java \
+	sun/nio/fs/UnixException.java \
+	sun/nio/fs/UnixFileAttributeViews.java \
+	sun/nio/fs/UnixFileAttributes.java \
+	sun/nio/fs/UnixFileKey.java \
+	sun/nio/fs/UnixFileModeAttribute.java \
+	sun/nio/fs/UnixFileStore.java \
+	sun/nio/fs/UnixFileStoreAttributes.java \
+	sun/nio/fs/UnixFileSystem.java \
+	sun/nio/fs/UnixFileSystemProvider.java \
+	sun/nio/fs/UnixMountEntry.java \
+	sun/nio/fs/UnixNativeDispatcher.java \
+	sun/nio/fs/UnixPath.java \
+	sun/nio/fs/UnixSecureDirectoryStream.java \
+	sun/nio/fs/UnixUriUtils.java \
+	sun/nio/fs/UnixUserPrincipals.java
 
 FILES_c += \
 	EPollArrayWrapper.c \
+	EPollPort.c \
 	InheritedChannel.c \
 	NativeThread.c \
-        PollArrayWrapper.c
+        PollArrayWrapper.c \
+	UnixAsynchronousServerSocketChannelImpl.c \
+	UnixAsynchronousSocketChannelImpl.c \
+	\
+	GnomeFileTypeDetector.c \
+	LinuxNativeDispatcher.c \
+	LinuxWatchService.c \
+	UnixCopyFile.c \
+	UnixNativeDispatcher.c
 
 FILES_export += \
 	sun/nio/ch/DevPollArrayWrapper.java \
         sun/nio/ch/EPollArrayWrapper.java \
+	sun/nio/ch/EPollPort.java \
 	sun/nio/ch/InheritedChannel.java \
-	sun/nio/ch/NativeThread.java
+	sun/nio/ch/NativeThread.java \
+	sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java \
+	sun/nio/ch/UnixAsynchronousSocketChannelImpl.java \
+	\
+	sun/nio/fs/GnomeFileTypeDetector.java \
+	sun/nio/fs/LinuxNativeDispatcher.java \
+	sun/nio/fs/LinuxWatchService.java \
+	sun/nio/fs/UnixCopyFile.java \
+	sun/nio/fs/UnixNativeDispatcher.java
+
+FILES_gen += \
+	sun/nio/fs/UnixConstants.java
 endif # PLATFORM = linux
 
 # Find platform-specific C source files
 #
+vpath %.c $(PLATFORM_SRC)/native/sun/nio/fs
 vpath %.c $(PLATFORM_SRC)/native/sun/nio/ch
 vpath %.c $(SHARE_SRC)/native/sun/nio/ch
 
@@ -152,7 +311,7 @@
 build: sources
 
 clean clobber::
-	$(RM) -r $(NIO_GEN) $(SNIO_GEN)
+	$(RM) -r $(NIO_GEN) $(SNIO_GEN) $(INIO_GEN)
 	$(RM) -r $(CLASSDESTDIR)/java/nio
 	$(RM) -r $(CLASSDESTDIR)/sun/nio
 
@@ -179,12 +338,16 @@
 CS_SRC=$(NIO_SRC)/charset
 SCH_SRC=$(SNIO_SRC)/ch
 SCS_SRC=$(SNIO_SRC)/cs
+SFS_SRC=$(SNIO_SRC)/fs
+ICH_SRC=$(INIO_SRC)/channels
 
 BUF_GEN=$(NIO_GEN)
 CH_GEN=$(NIO_GEN)/channels
 CS_GEN=$(NIO_GEN)/charset
 SCH_GEN=$(SNIO_GEN)/ch
 SCS_GEN=$(SNIO_GEN)/cs
+SFS_GEN=$(SNIO_GEN)/fs
+ICH_GEN=$(INIO_GEN)/channels
 
 FILES_gensbcs_out = $(FILES_gen_sbcs:%.java=$(GENSRCDIR)/%.java)
 
@@ -624,6 +787,11 @@
 	@$(RM) $@.temp
 	$(GEN_EX_CMD) $(BUF_SRC)/exceptions $(BUF_GEN)
 
+$(ICH_GEN)/%Exception.java: genExceptions.sh $(ICH_SRC)/exceptions
+	$(prep-target)
+	@$(RM) $@.temp
+	$(GEN_EX_CMD) $(ICH_SRC)/exceptions $(ICH_GEN)
+
 #
 # Generated charset-provider classes
 #
@@ -674,4 +842,48 @@
 	$(BOOT_JAVA_CMD) -cp $(CHARSETMAPPING_JARFILE) build.tools.charsetmapping.GenerateSBCS \
 		$(GENCSSRC) $(SCS_GEN) sbcs
 
+# 
+# Generated file system implementation classes (Unix only)
+#
+
+GENUC_SRC = $(PLATFORM_SRC)/native/sun/nio/fs/genUnixConstants.c
+
+GENUC_EXE = $(TEMPDIR)/genUnixConstants
+
+GENUC_COPYRIGHT_YEARS = $(shell $(CAT) $(GENUC_SRC) | \
+	$(NAWK) '/^.*Copyright.*Sun/ { print $$3 }')
+
+$(GENUC_EXE) : $(GENUC_SRC)
+	$(prep-target)
+	$(CC) $(CPPFLAGS) -o $@ $(GENUC_SRC)
+
+$(SFS_GEN)/UnixConstants.java: $(GENUC_EXE)
+	$(prep-target)
+	NAWK="$(NAWK)" SH="$(SH)" $(SH) -e addNotices.sh $(GENUC_COPYRIGHT_YEARS) > $@
+	$(GENUC_EXE) >> $@
+
+GENSC_SRC = $(PLATFORM_SRC)/native/sun/nio/fs/genSolarisConstants.c
+
+GENSC_EXE = $(TEMPDIR)/genSolarisConstants
+
+GENSC_COPYRIGHT_YEARS = $(shell $(CAT) $(GENSC_SRC) | \
+	$(NAWK) '/^.*Copyright.*Sun/ { print $$3 }')
+
+$(GENSC_EXE) : $(GENSC_SRC)
+	$(prep-target)
+	$(CC) $(CPPFLAGS) -o $@ $(GENSC_SRC)
+
+$(SFS_GEN)/SolarisConstants.java: $(GENSC_EXE)
+	$(prep-target)
+	NAWK="$(NAWK)" SH="$(SH)" $(SH) -e addNotices.sh $(GENSC_COPYRIGHT_YEARS) > $@
+	$(GENSC_EXE) >> $@
+
+#
+# Files to copy
+#
+
+$(SERVICES)/%: $(PLATFORM_SRC)/classes/sun/nio/fs/META-INF/services/%
+	$(install-file)
+
+
 .PHONY: sources 
diff -Nru openjdk.orig/jdk/make/java/nio/mapfile-linux openjdk/jdk/make/java/nio/mapfile-linux
--- openjdk.orig/jdk/make/java/nio/mapfile-linux	2009-02-05 08:44:13.000000000 +0000
+++ openjdk/jdk/make/java/nio/mapfile-linux	2009-02-11 23:39:12.000000000 +0000
@@ -44,6 +44,14 @@
 		Java_sun_nio_ch_EPollArrayWrapper_interrupt;
 		Java_sun_nio_ch_EPollArrayWrapper_offsetofData;
 		Java_sun_nio_ch_EPollArrayWrapper_sizeofEPollEvent;
+		Java_sun_nio_ch_EPollPort_init;
+		Java_sun_nio_ch_EPollPort_close0;
+		Java_sun_nio_ch_EPollPort_epollCreate;
+		Java_sun_nio_ch_EPollPort_epollCtl;
+		Java_sun_nio_ch_EPollPort_epollWait;
+		Java_sun_nio_ch_EPollPort_drain1;
+		Java_sun_nio_ch_EPollPort_interrupt;
+		Java_sun_nio_ch_EPollPort_socketpair;
                 Java_sun_nio_ch_FileChannelImpl_close0;
                 Java_sun_nio_ch_FileChannelImpl_force0;
                 Java_sun_nio_ch_FileChannelImpl_initIDs;
@@ -108,6 +116,74 @@
                 Java_sun_nio_ch_ServerSocketChannelImpl_accept0;
                 Java_sun_nio_ch_ServerSocketChannelImpl_initIDs;
                 Java_sun_nio_ch_SocketChannelImpl_checkConnect;
+		Java_sun_nio_ch_UnixAsynchronousServerSocketChannelImpl_accept0;
+		Java_sun_nio_ch_UnixAsynchronousServerSocketChannelImpl_initIDs;
+		Java_sun_nio_ch_UnixAsynchronousSocketChannelImpl_checkConnect;
+		Java_sun_nio_fs_GnomeFileTypeDetector_initializeGio;
+		Java_sun_nio_fs_GnomeFileTypeDetector_probeUsingGio;
+		Java_sun_nio_fs_GnomeFileTypeDetector_initializeGnomeVfs;
+		Java_sun_nio_fs_GnomeFileTypeDetector_probeUsingGnomeVfs;
+		Java_sun_nio_fs_LinuxWatchService_init;
+		Java_sun_nio_fs_LinuxWatchService_inotifyInit;
+		Java_sun_nio_fs_LinuxWatchService_inotifyAddWatch;
+		Java_sun_nio_fs_LinuxWatchService_inotifyRmWatch;
+		Java_sun_nio_fs_LinuxWatchService_configureBlocking;
+		Java_sun_nio_fs_LinuxWatchService_socketpair;
+		Java_sun_nio_fs_LinuxWatchService_poll;
+		Java_sun_nio_fs_LinuxNativeDispatcher_init;
+		Java_sun_nio_fs_LinuxNativeDispatcher_fgetxattr0;
+		Java_sun_nio_fs_LinuxNativeDispatcher_flistxattr;
+		Java_sun_nio_fs_LinuxNativeDispatcher_fsetxattr0;
+		Java_sun_nio_fs_LinuxNativeDispatcher_fremovexattr0;
+		Java_sun_nio_fs_LinuxNativeDispatcher_setmntent0;
+		Java_sun_nio_fs_LinuxNativeDispatcher_endmntent;
+		Java_sun_nio_fs_UnixNativeDispatcher_initIDs;
+		Java_sun_nio_fs_UnixNativeDispatcher_getcwd;
+		Java_sun_nio_fs_UnixNativeDispatcher_strerror;
+		Java_sun_nio_fs_UnixNativeDispatcher_dup;
+		Java_sun_nio_fs_UnixNativeDispatcher_access0;
+		Java_sun_nio_fs_UnixNativeDispatcher_stat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_lstat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fstat;
+		Java_sun_nio_fs_UnixNativeDispatcher_fstatat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_chmod0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fchmod;
+		Java_sun_nio_fs_UnixNativeDispatcher_chown0;
+		Java_sun_nio_fs_UnixNativeDispatcher_lchown0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fchown;
+		Java_sun_nio_fs_UnixNativeDispatcher_utimes0;
+		Java_sun_nio_fs_UnixNativeDispatcher_futimes;
+		Java_sun_nio_fs_UnixNativeDispatcher_open0;
+		Java_sun_nio_fs_UnixNativeDispatcher_openat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_close;
+		Java_sun_nio_fs_UnixNativeDispatcher_read;
+		Java_sun_nio_fs_UnixNativeDispatcher_write;
+		Java_sun_nio_fs_UnixNativeDispatcher_fopen0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fclose;
+		Java_sun_nio_fs_UnixNativeDispatcher_opendir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fdopendir;
+		Java_sun_nio_fs_UnixNativeDispatcher_readdir;
+		Java_sun_nio_fs_UnixNativeDispatcher_closedir;
+		Java_sun_nio_fs_UnixNativeDispatcher_link0;
+		Java_sun_nio_fs_UnixNativeDispatcher_unlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_unlinkat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_rename0;
+		Java_sun_nio_fs_UnixNativeDispatcher_renameat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_mkdir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_rmdir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_symlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_readlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_realpath0;
+		Java_sun_nio_fs_UnixNativeDispatcher_statvfs0;
+		Java_sun_nio_fs_UnixNativeDispatcher_pathconf0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fpathconf;
+		Java_sun_nio_fs_UnixNativeDispatcher_mknod0;
+		Java_sun_nio_fs_UnixNativeDispatcher_getpwuid;
+		Java_sun_nio_fs_UnixNativeDispatcher_getgrgid;
+		Java_sun_nio_fs_UnixNativeDispatcher_getpwnam0;
+		Java_sun_nio_fs_UnixNativeDispatcher_getgrnam0;
+		Java_sun_nio_fs_UnixNativeDispatcher_getextmntent;
+		Java_sun_nio_fs_UnixCopyFile_transfer;
 
 	local:
 		*;
diff -Nru openjdk.orig/jdk/make/java/nio/mapfile-solaris openjdk/jdk/make/java/nio/mapfile-solaris
--- openjdk.orig/jdk/make/java/nio/mapfile-solaris	2009-02-05 08:44:13.000000000 +0000
+++ openjdk/jdk/make/java/nio/mapfile-solaris	2009-02-11 23:38:28.000000000 +0000
@@ -106,6 +106,75 @@
                 Java_sun_nio_ch_ServerSocketChannelImpl_accept0;
                 Java_sun_nio_ch_ServerSocketChannelImpl_initIDs;
                 Java_sun_nio_ch_SocketChannelImpl_checkConnect;
+		Java_sun_nio_ch_UnixAsynchronousServerSocketChannelImpl_accept0;
+		Java_sun_nio_ch_UnixAsynchronousServerSocketChannelImpl_initIDs;
+		Java_sun_nio_ch_UnixAsynchronousSocketChannelImpl_checkConnect;
+		Java_sun_nio_ch_SolarisEventPort_init;
+		Java_sun_nio_ch_SolarisEventPort_portCreate;
+		Java_sun_nio_ch_SolarisEventPort_portClose;
+		Java_sun_nio_ch_SolarisEventPort_portAssociate;
+		Java_sun_nio_ch_SolarisEventPort_portGet;
+		Java_sun_nio_ch_SolarisEventPort_portGetn;
+		Java_sun_nio_ch_SolarisEventPort_portSend;
+		Java_sun_nio_fs_GnomeFileTypeDetector_initializeGio;
+		Java_sun_nio_fs_GnomeFileTypeDetector_probeUsingGio;
+		Java_sun_nio_fs_GnomeFileTypeDetector_initializeGnomeVfs;
+		Java_sun_nio_fs_GnomeFileTypeDetector_probeUsingGnomeVfs;
+		Java_sun_nio_fs_UnixNativeDispatcher_initIDs;
+		Java_sun_nio_fs_UnixNativeDispatcher_getcwd;
+		Java_sun_nio_fs_UnixNativeDispatcher_strerror;
+		Java_sun_nio_fs_UnixNativeDispatcher_dup;
+		Java_sun_nio_fs_UnixNativeDispatcher_access0;
+		Java_sun_nio_fs_UnixNativeDispatcher_stat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_lstat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fstat;
+		Java_sun_nio_fs_UnixNativeDispatcher_fstatat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_chmod0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fchmod;
+		Java_sun_nio_fs_UnixNativeDispatcher_chown0;
+		Java_sun_nio_fs_UnixNativeDispatcher_lchown0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fchown;
+		Java_sun_nio_fs_UnixNativeDispatcher_utimes0;
+		Java_sun_nio_fs_UnixNativeDispatcher_futimes;
+		Java_sun_nio_fs_UnixNativeDispatcher_open0;
+		Java_sun_nio_fs_UnixNativeDispatcher_openat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_close;
+		Java_sun_nio_fs_UnixNativeDispatcher_read;
+		Java_sun_nio_fs_UnixNativeDispatcher_write;
+		Java_sun_nio_fs_UnixNativeDispatcher_fopen0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fclose;
+		Java_sun_nio_fs_UnixNativeDispatcher_opendir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fdopendir;
+		Java_sun_nio_fs_UnixNativeDispatcher_readdir;
+		Java_sun_nio_fs_UnixNativeDispatcher_closedir;
+		Java_sun_nio_fs_UnixNativeDispatcher_link0;
+		Java_sun_nio_fs_UnixNativeDispatcher_unlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_unlinkat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_rename0;
+		Java_sun_nio_fs_UnixNativeDispatcher_renameat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_mkdir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_rmdir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_symlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_readlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_realpath0;
+		Java_sun_nio_fs_UnixNativeDispatcher_statvfs0;
+		Java_sun_nio_fs_UnixNativeDispatcher_pathconf0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fpathconf;
+		Java_sun_nio_fs_UnixNativeDispatcher_mknod0;
+		Java_sun_nio_fs_UnixNativeDispatcher_getpwuid;
+		Java_sun_nio_fs_UnixNativeDispatcher_getgrgid;
+		Java_sun_nio_fs_UnixNativeDispatcher_getpwnam0;
+		Java_sun_nio_fs_UnixNativeDispatcher_getgrnam0;
+		Java_sun_nio_fs_UnixNativeDispatcher_getextmntent;
+		Java_sun_nio_fs_UnixCopyFile_transfer;
+		Java_sun_nio_fs_SolarisNativeDispatcher_init;
+		Java_sun_nio_fs_SolarisNativeDispatcher_facl;
+		Java_sun_nio_fs_SolarisWatchService_init;
+ 		Java_sun_nio_fs_SolarisWatchService_portCreate;
+		Java_sun_nio_fs_SolarisWatchService_portAssociate;
+		Java_sun_nio_fs_SolarisWatchService_portDissociate;
+		Java_sun_nio_fs_SolarisWatchService_portSend;
+		Java_sun_nio_fs_SolarisWatchService_portGetn;
 
 	local:
 		*;
diff -Nru openjdk.orig/jdk/make/mkdemo/Makefile openjdk/jdk/make/mkdemo/Makefile
--- openjdk.orig/jdk/make/mkdemo/Makefile	2009-02-05 08:44:13.000000000 +0000
+++ openjdk/jdk/make/mkdemo/Makefile	2009-02-11 23:14:46.000000000 +0000
@@ -31,7 +31,7 @@
 PRODUCT = demos
 include $(BUILDDIR)/common/Defs.gmk
 
-SUBDIRS = applets jfc jvmti management jni scripting jpda
+SUBDIRS = applets jfc jvmti management jni scripting jpda nio
 
 all build:: nbproject
 	$(SUBDIRS-loop)
diff -Nru openjdk.orig/jdk/make/mksample/nio/Makefile openjdk/jdk/make/mksample/nio/Makefile
--- openjdk.orig/jdk/make/mksample/nio/Makefile	2009-02-05 08:44:13.000000000 +0000
+++ openjdk/jdk/make/mksample/nio/Makefile	2009-02-11 23:42:20.000000000 +0000
@@ -31,7 +31,7 @@
 PRODUCT = java
 include $(BUILDDIR)/common/Defs.gmk
 
-SUBDIRS = multicast server
+SUBDIRS = aio file multicast server
 all build clean clobber::
 	$(SUBDIRS-loop)
 
diff -Nru openjdk.orig/jdk/src/share/classes/java/io/File.java openjdk/jdk/src/share/classes/java/io/File.java
--- openjdk.orig/jdk/src/share/classes/java/io/File.java	2009-02-13 21:09:13.000000000 +0000
+++ openjdk/jdk/src/share/classes/java/io/File.java	2009-02-14 01:11:10.000000000 +0000
@@ -31,13 +31,28 @@
 import java.net.MalformedURLException;
 import java.net.URISyntaxException;
 import java.util.ArrayList;
+import java.util.EnumSet;
 import java.util.Map;
 import java.util.Hashtable;
+import java.util.Random;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.security.AccessController;
 import java.security.AccessControlException;
+import java.security.PrivilegedAction;
 import java.security.SecureRandom;
 import sun.security.action.GetPropertyAction;
 
+import java.nio.file.FileAlreadyExistsException;
+import java.nio.file.FileSystems;
+import java.nio.file.InvalidPathException;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+import java.nio.file.attribute.FileAttribute;
+import java.nio.file.attribute.FileAttributeView;
+import java.nio.file.attribute.PosixFilePermission;
+import java.nio.file.attribute.PosixFilePermissions;
 
 /**
  * An abstract representation of file and directory pathnames.
@@ -131,6 +146,19 @@
  * created, the abstract pathname represented by a <code>File</code> object
  * will never change.
  *
+ * <h4>Interoperability with {@code java.nio.file} package</h4>
+ *
+ * <p> {@note new}
+ * The <a href="../../java/nio/file/package-summary.html">{@code java.nio.file}</a>
+ * package defines interfaces and classes for the Java virtual machine to access
+ * files, file attributes, and file systems. This API may be used to overcome
+ * many of the limitations of the {@code java.io.File} class.
+ * The {@link #toPath toPath} method may be used to obtain a {@link
+ * Path} that uses the abstract path represented by a {@code File} object to
+ * locate a file. The resulting {@code Path} provides more efficient and
+ * extensive access to file attributes, additional file operations, and I/O
+ * exceptions to help diagnose errors when an operation on a file fails.
+ *
  * @author  unascribed
  * @since   JDK1.0
  */
@@ -401,6 +429,203 @@
         this.prefixLength = fs.prefixLength(this.path);
     }
 
+    /* -- Temporary files -- */
+ 
+    private static class TemporaryDirectory {
+        private TemporaryDirectory() { }
+
+        static final File valueAsFile =
+            new File(AccessController.doPrivileged(new GetPropertyAction("java.io.tmpdir")));
+
+        // file name generation
+        private static final AtomicInteger counter =
+            new AtomicInteger(new Random().nextInt() & 0xffff);
+        static File generateFile(String prefix, String suffix, File dir) {
+            int n = counter.getAndIncrement();
+            return new File(dir, prefix + Integer.toString(n) + suffix);
+        }
+
+        // default file permissions
+        static final FileAttribute<Set<PosixFilePermission>> defaultPosixFilePermissions =
+            PosixFilePermissions.asFileAttribute(EnumSet
+                .of(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE));
+        static final boolean isPosix = isPosix();
+        static boolean isPosix() {
+            return AccessController.doPrivileged(
+                new PrivilegedAction<Boolean>() {
+                    public Boolean run() {
+                        try {
+			  return FileSystems.getDefault().getPath(valueAsFile.getPath())
+                                .getFileStore().supportsFileAttributeView("posix");
+                        } catch (IOException e) {
+                            throw new IOError(e);
+                        }
+                    }
+                });
+	}
+    }
+
+    /**
+     * {@note new}
+     * Creates an empty file in the default temporary-file directory, using
+     * the given prefix and suffix to generate its name. This method is
+     * equivalent to invoking the {@link #createTempFile(String,String)
+     * createTempFile(prefix,&nbsp;suffix)} method with the addition that the
+     * resulting pathname may be requested to be deleted when the Java virtual
+     * machine terminates, and the initial file attributes to set atomically
+     * when creating the file may be specified.
+     *
+     * <p> When the value of the {@code deleteOnExit} method is {@code true}
+     * then the resulting file is requested to be deleted when the Java virtual
+     * machine terminates as if by invoking the {@link #deleteOnExit deleteOnExit}
+     * method.
+     *
+     * <p> The {@code attrs} parameter is an optional array of {@link FileAttribute
+     * attributes} to set atomically when creating the file. Each attribute is
+     * identified by its {@link FileAttribute#name name}. If more than one attribute
+     * of the same name is included in the array then all but the last occurrence
+     * is ignored.
+     *
+     * @param   prefix
+     *          The prefix string to be used in generating the file's
+     *          name; must be at least three characters long
+     * @param   suffix
+     *          The suffix string to be used in generating the file's
+     *          name; may be {@code null}, in which case the suffix
+     *          {@code ".tmp"} will be used
+     * @param   deleteOnExit
+     *          {@code true} if the file denoted by resulting pathname be
+     *          deleted when the Java virtual machine terminates
+     * @param   attrs
+     *          An optional list of file attributes to set atomically when creating
+     *          the file
+     * @return  An abstract pathname denoting a newly-created empty file
+     *
+     * @throws  IllegalArgumentException
+     *          If the <code>prefix</code> argument contains fewer than three
+     *          characters
+     * @throws  UnsupportedOperationException
+     *          If the array contains an attribute that cannot be set atomically
+     *          when creating the file
+     * @throws  IOException
+     *          If a file could not be created
+     * @throws  SecurityException
+     *          If a security manager exists and its <code>{@link
+     *          java.lang.SecurityManager#checkWrite(java.lang.String)}</code>
+     *          method does not allow a file to be created. When the {@code
+     *          deleteOnExit} parameter has the value {@code true} then the
+     *          security manager's {@link
+     *          java.lang.SecurityManager#checkDelete(java.lang.String)} is
+     *          invoked to check delete access to the file.
+     * @since 1.7
+     */
+    public static File createTempFile(String prefix,
+                                      String suffix,
+                                      boolean deleteOnExit,
+                                      FileAttribute<?>... attrs)
+        throws IOException
+    {
+        if (prefix.length() < 3)
+            throw new IllegalArgumentException("Prefix string too short");
+        suffix = (suffix == null) ? ".tmp" : suffix;
+ 
+        // special case POSIX environments so that 0600 is used as the file mode
+        if (TemporaryDirectory.isPosix) {
+            if (attrs.length == 0) {
+                // no attributes so use default permissions
+                attrs = new FileAttribute<?>[1];
+                attrs[0] = TemporaryDirectory.defaultPosixFilePermissions;
+            } else {
+                // check if posix permissions given; if not use default
+                boolean hasPermissions = false;
+                for (int i=0; i<attrs.length; i++) {
+                    if (attrs[i].name().equals("posix:permissions")) {
+                        hasPermissions = true;
+                        break;
+                    }
+                }
+                if (!hasPermissions) {
+                    FileAttribute<?>[] copy = new FileAttribute<?>[attrs.length+1];
+                    System.arraycopy(attrs, 0, copy, 0, attrs.length);
+                    attrs = copy;
+                    attrs[attrs.length-1] =
+                        TemporaryDirectory.defaultPosixFilePermissions;
+                }
+            }
+         }
+ 
+        // use Path#createFile to create file
+        SecurityManager sm = System.getSecurityManager();
+        for (;;) {
+            File f = TemporaryDirectory
+                .generateFile(prefix, suffix, TemporaryDirectory.valueAsFile);
+            if (sm != null && deleteOnExit)
+                sm.checkDelete(f.getPath());
+            try {
+                f.toPath().createFile(attrs);
+                if (deleteOnExit)
+		  DeleteOnExitHook.add(f.getPath());
+                return f;
+            } catch (InvalidPathException e) {
+                // don't reveal temporary directory location
+                if (sm != null)
+                    throw new IllegalArgumentException("Invalid prefix or suffix");
+                throw e;
+            } catch (SecurityException e) {
+                // don't reveal temporary directory location
+                if (sm != null)
+                    throw new SecurityException("Unable to create temporary file");
+                throw e;
+            } catch (FileAlreadyExistsException e) {
+                // ignore
+            }
+         }
+     }
+ 
+    // -- Integration with java.nio.file --
+ 
+    private volatile transient Path filePath;
+ 
+     /**
+     * {@note new}
+     * Returns a {@link Path java.nio.file.Path} object constructed from the
+     * this abstract path. The first invocation of this method works as if
+     * invoking it were equivalent to evaluating the expression:
+     * <blockquote><pre>
+     * {@link FileSystems#getDefault FileSystems.getDefault}().{@link FileSystem#getPath getPath}(this.{@link #getPath getPath}());
+     * </pre></blockquote>
+     * Subsequent invocations of this method return the same {@code Path}.
+     *
+     * <p> If this abstract pathname is the empty abstract pathname then this
+     * method returns a {@code Path} that may be used to access to the current
+     * user directory.
+     *
+     * @return  A {@code Path} constructed from this abstract path. The resulting
+     *          {@code Path} is associated with the {@link FileSystems#getDefault
+     *          default-filesystem}.
+     *
+     * @throws  InvalidPathException
+     *          If a {@code Path} object cannot be constructed from the abstract
+     *          path (see {@link java.nio.file.FileSystem#getPath FileSystem.getPath})
+     *
+     * @since   1.7
+     */
+    public Path toPath() {
+        if (filePath == null) {
+            synchronized (this) {
+                if (filePath == null) {
+		    String path = getPath();
+                    if (path.length() == 0) {
+                        // assume default file system treats "." as current directory
+                        filePath = Paths.get(".");
+                    } else {
+                        filePath = Paths.get(path);
+                    }
+                }
+            }
+         }
+        return filePath;
+     }
 
     /* -- Path-component accessors -- */
 
diff -Nru openjdk.orig/jdk/src/share/classes/java/io/FilePermission.java openjdk/jdk/src/share/classes/java/io/FilePermission.java
--- openjdk.orig/jdk/src/share/classes/java/io/FilePermission.java	2009-02-13 21:09:13.000000000 +0000
+++ openjdk/jdk/src/share/classes/java/io/FilePermission.java	2009-02-13 22:03:14.000000000 +0000
@@ -29,13 +29,13 @@
 import java.util.Enumeration;
 import java.util.List;
 import java.util.ArrayList;
-import java.util.StringTokenizer;
 import java.util.Vector;
 import java.util.Collections;
+import java.io.IOException;
 import java.io.ObjectStreamField;
 import java.io.ObjectOutputStream;
 import java.io.ObjectInputStream;
-import java.io.IOException;
+import java.io.Serializable;
 import sun.security.util.SecurityConstants;
 
 /**
@@ -56,9 +56,11 @@
  * (recursively) all files and subdirectories contained in the current
  * directory.
  * <P>
+ * {@note revised}
  * The actions to be granted are passed to the constructor in a string containing
  * a list of one or more comma-separated keywords. The possible keywords are
- * "read", "write", "execute", and "delete". Their meaning is defined as follows:
+ * "read", "write", "execute", "delete", and "readlink". Their meaning is
+ * defined as follows:
  * <P>
  * <DL>
  *    <DT> read <DD> read permission
@@ -69,6 +71,11 @@
  *    <DT> delete
  *    <DD> delete permission. Allows <code>File.delete</code> to
  *         be called. Corresponds to <code>SecurityManager.checkDelete</code>.
+ *    <DT> readlink
+ *    <DD> read link permission. Allows the target of a
+ *         <a href="../nio/file/package-summary.html#links">symbolic link</a>
+ *         to be read by invoking the {@link java.nio.file.Path#readSymbolicLink
+ *         readSymbolicLink } method.
  * </DL>
  * <P>
  * The actions string is converted to lowercase before processing.
@@ -114,11 +121,15 @@
      * Delete action.
      */
     private final static int DELETE  = 0x8;
+    /**
+     * Read link action.
+     */
+    private final static int READLINK    = 0x10;
 
     /**
-     * All actions (read,write,execute,delete)
+     * All actions (read,write,execute,delete,readlink)
      */
-    private final static int ALL     = READ|WRITE|EXECUTE|DELETE;
+    private final static int ALL     = READ|WRITE|EXECUTE|DELETE|READLINK;
     /**
      * No actions.
      */
@@ -235,7 +246,7 @@
      * <i>path</i> is the pathname of a file or directory, and <i>actions</i>
      * contains a comma-separated list of the desired actions granted on the
      * file or directory. Possible actions are
-     * "read", "write", "execute", and "delete".
+     * "read", "write", "execute", "delete", and "readlink".
      *
      * <p>A pathname that ends in "/*" (where "/" is
      * the file separator character, <code>File.separatorChar</code>)
@@ -425,6 +436,8 @@
             return EXECUTE;
         } else if (actions == SecurityConstants.FILE_DELETE_ACTION) {
             return DELETE;
+        } else if (actions == SecurityConstants.FILE_READLINK_ACTION) {
+            return READLINK;
         }
 
         char[] a = actions.toCharArray();
@@ -485,6 +498,18 @@
                 matchlen = 6;
                 mask |= DELETE;
 
+            } else if (i >= 7 && (a[i-7] == 'r' || a[i-7] == 'R') &&
+                                 (a[i-6] == 'e' || a[i-6] == 'E') &&
+                                 (a[i-5] == 'a' || a[i-5] == 'A') &&
+                                 (a[i-4] == 'd' || a[i-4] == 'D') &&
+                                 (a[i-3] == 'l' || a[i-3] == 'L') &&
+                                 (a[i-2] == 'i' || a[i-2] == 'I') &&
+                                 (a[i-1] == 'n' || a[i-1] == 'N') &&
+                                 (a[i] == 'k' || a[i] == 'K'))
+            {
+                matchlen = 8;
+                mask |= READLINK;
+
             } else {
                 // parse error
                 throw new IllegalArgumentException(
@@ -529,7 +554,7 @@
     /**
      * Return the canonical string representation of the actions.
      * Always returns present actions in the following order:
-     * read, write, execute, delete.
+     * read, write, execute, delete, readlink.
      *
      * @return the canonical string representation of the actions.
      */
@@ -561,14 +586,20 @@
             sb.append("delete");
         }
 
+        if ((mask & READLINK) == READLINK) {
+            if (comma) sb.append(',');
+            else comma = true;
+            sb.append("readlink");
+        }
+
         return sb.toString();
     }
 
     /**
      * Returns the "canonical string representation" of the actions.
      * That is, this method always returns present actions in the following order:
-     * read, write, execute, delete. For example, if this FilePermission object
-     * allows both write and read actions, a call to <code>getActions</code>
+     * read, write, execute, delete, readlink. For example, if this FilePermission
+     * object allows both write and read actions, a call to <code>getActions</code>
      * will return the string "read,write".
      *
      * @return the canonical string representation of the actions.
@@ -678,7 +709,7 @@
 implements Serializable {
 
     // Not serialized; see serialization section at end of class
-    private transient List perms;
+    private transient List<Permission> perms;
 
     /**
      * Create an empty FilePermissions object.
@@ -686,7 +717,7 @@
      */
 
     public FilePermissionCollection() {
-        perms = new ArrayList();
+        perms = new ArrayList<Permission>();
     }
 
     /**
@@ -791,7 +822,7 @@
         // Don't call out.defaultWriteObject()
 
         // Write out Vector
-        Vector permissions = new Vector(perms.size());
+        Vector<Permission> permissions = new Vector<Permission>(perms.size());
         synchronized (this) {
             permissions.addAll(perms);
         }
@@ -804,6 +835,7 @@
     /*
      * Reads in a Vector of FilePermissions and saves them in the perms field.
      */
+    @SuppressWarnings("unchecked")
     private void readObject(ObjectInputStream in) throws IOException,
     ClassNotFoundException {
         // Don't call defaultReadObject()
@@ -812,8 +844,8 @@
         ObjectInputStream.GetField gfields = in.readFields();
 
         // Get the one we want
-        Vector permissions = (Vector)gfields.get("permissions", null);
-        perms = new ArrayList(permissions.size());
+        Vector<Permission> permissions = (Vector<Permission>)gfields.get("permissions", null);
+        perms = new ArrayList<Permission>(permissions.size());
         perms.addAll(permissions);
     }
 }
diff -Nru openjdk.orig/jdk/src/share/classes/java/net/StandardProtocolFamily.java openjdk/jdk/src/share/classes/java/net/StandardProtocolFamily.java
--- openjdk.orig/jdk/src/share/classes/java/net/StandardProtocolFamily.java	2009-02-13 21:09:28.000000000 +0000
+++ openjdk/jdk/src/share/classes/java/net/StandardProtocolFamily.java	2009-02-13 22:04:11.000000000 +0000
@@ -26,7 +26,7 @@
 package java.net;
 
 /**
- * Defines the standard family of communication protocols.
+ * Defines the standard families of communication protocols.
  *
  * @since 1.7
  */
diff -Nru openjdk.orig/jdk/src/share/classes/java/net/StandardSocketOption.java openjdk/jdk/src/share/classes/java/net/StandardSocketOption.java
--- openjdk.orig/jdk/src/share/classes/java/net/StandardSocketOption.java	2009-02-13 21:09:28.000000000 +0000
+++ openjdk/jdk/src/share/classes/java/net/StandardSocketOption.java	2009-02-13 22:04:28.000000000 +0000
@@ -59,6 +59,7 @@
      *
      * @see <a href="http://www.ietf.org/rfc/rfc919.txt">RFC&nbsp;929:
      * Broadcasting Internet Datagrams</a>
+     * @see DatagramSocket#setBroadcast
      */
     public static final SocketOption<Boolean> SO_BROADCAST =
         new StdSocketOption<Boolean>("SO_BROADCAST", Boolean.class);
@@ -78,6 +79,7 @@
      *
      * @see <a href="http://www.ietf.org/rfc/rfc1122.txt">RFC&nbsp;1122
      * Requirements for Internet Hosts -- Communication Layers</a>
+     * @see Socket#setKeepAlive
      */
     public static final SocketOption<Boolean> SO_KEEPALIVE =
         new StdSocketOption<Boolean>("SO_KEEPALIVE", Boolean.class);
@@ -107,6 +109,8 @@
      * socket is bound or connected. Whether an implementation allows the
      * socket send buffer to be changed after the socket is bound is system
      * dependent.
+     *
+     * @see Socket#setSendBufferSize
      */
     public static final SocketOption<Integer> SO_SNDBUF =
         new StdSocketOption<Integer>("SO_SNDBUF", Integer.class);
@@ -145,6 +149,8 @@
      *
      * @see <a href="http://www.ietf.org/rfc/rfc1323.txt">RFC&nbsp;1323: TCP
      * Extensions for High Performance</a>
+     * @see Socket#setReceiveBufferSize
+     * @see ServerSocket#setReceiveBufferSize
      */
     public static final SocketOption<Integer> SO_RCVBUF =
         new StdSocketOption<Integer>("SO_RCVBUF", Integer.class);
@@ -175,6 +181,7 @@
      *
      * @see <a href="http://www.ietf.org/rfc/rfc793.txt">RFC&nbsp;793: Transmission
      * Control Protocol</a>
+     * @see ServerSocket#setReuseAddress
      */
     public static final SocketOption<Boolean> SO_REUSEADDR =
         new StdSocketOption<Boolean>("SO_REUSEADDR", Boolean.class);
@@ -205,6 +212,8 @@
      * is system dependent. Setting the linger interval to a value that is
      * greater than its maximum value causes the linger interval to be set to
      * its maximum value.
+     *
+     * @see Socket#setSoLinger
      */
     public static final SocketOption<Integer> SO_LINGER =
         new StdSocketOption<Integer>("SO_LINGER", Integer.class);
@@ -215,15 +224,15 @@
     /**
      * The Type of Service (ToS) octet in the Internet Protocol (IP) header.
      *
-     * <p> The value of this socket option is an {@code Integer}, the least
-     * significant 8 bits of which represents the value of the ToS octet in IP
-     * packets sent by sockets to an {@link StandardProtocolFamily#INET IPv4}
-     * socket. The interpretation of the ToS octet is network specific and
-     * is not defined by this class. Further information on the ToS octet can be
-     * found in <a href="http://www.ietf.org/rfc/rfc1349.txt">RFC&nbsp;1349</a>
-     * and <a href="http://www.ietf.org/rfc/rfc2474.txt">RFC&nbsp;2474</a>. The
-     * value of the socket option is a <em>hint</em>. An implementation may
-     * ignore the value, or ignore specific values.
+     * <p> The value of this socket option is an {@code Integer} representing
+     * the value of the ToS octet in IP packets sent by sockets to an {@link
+     * StandardProtocolFamily#INET IPv4} socket. The interpretation of the ToS
+     * octet is network specific and is not defined by this class. Further
+     * information on the ToS octet can be found in <a
+     * href="http://www.ietf.org/rfc/rfc1349.txt">RFC&nbsp;1349</a> and <a
+     * href="http://www.ietf.org/rfc/rfc2474.txt">RFC&nbsp;2474</a>. The value
+     * of the socket option is a <em>hint</em>. An implementation may ignore the
+     * value, or ignore specific values.
      *
      * <p> The initial/default value of the TOS field in the ToS octet is
      * implementation specific but will typically be {@code 0}. For
@@ -235,6 +244,8 @@
      * <p> The behavior of this socket option on a stream-oriented socket, or an
      * {@link StandardProtocolFamily#INET6 IPv6} socket, is not defined in this
      * release.
+     *
+     * @see DatagramSocket#setTrafficClass
      */
     public static final SocketOption<Integer> IP_TOS =
         new StdSocketOption<Integer>("IP_TOS", Integer.class);
@@ -257,6 +268,7 @@
      * is system dependent.
      *
      * @see java.nio.channels.MulticastChannel
+     * @see MulticastSocket#setInterface
      */
     public static final SocketOption<NetworkInterface> IP_MULTICAST_IF =
         new StdSocketOption<NetworkInterface>("IP_MULTICAST_IF", NetworkInterface.class);
@@ -283,6 +295,7 @@
      * prior to binding the socket is system dependent.
      *
      * @see java.nio.channels.MulticastChannel
+     * @see MulticastSocket#setTimeToLive
      */
     public static final SocketOption<Integer> IP_MULTICAST_TTL =
         new StdSocketOption<Integer>("IP_MULTICAST_TTL", Integer.class);
@@ -307,6 +320,7 @@
      * binding the socket is system dependent.
      *
      * @see java.nio.channels.MulticastChannel
+     *  @see MulticastSocket#setLoopbackMode
      */
     public static final SocketOption<Boolean> IP_MULTICAST_LOOP =
         new StdSocketOption<Boolean>("IP_MULTICAST_LOOP", Boolean.class);
@@ -328,11 +342,12 @@
      * coalescing impacts performance. The socket option may be enabled at any
      * time. In other words, the Nagle Algorithm can be disabled. Once the option
      * is enabled, it is system dependent whether it can be subsequently
-     * disabled. In that case, invoking the {@code setOption} method to disable
-     * the option has no effect.
+     * disabled. If it cannot, then invoking the {@code setOption} method to
+     * disable the option has no effect.
      *
      * @see <a href="http://www.ietf.org/rfc/rfc1122.txt">RFC&nbsp;1122:
      * Requirements for Internet Hosts -- Communication Layers</a>
+     * @see Socket#setTcpNoDelay
      */
     public static final SocketOption<Boolean> TCP_NODELAY =
         new StdSocketOption<Boolean>("TCP_NODELAY", Boolean.class);
diff -Nru openjdk.orig/jdk/src/share/classes/java/nio/channels/Channels.java openjdk/jdk/src/share/classes/java/nio/channels/Channels.java
--- openjdk.orig/jdk/src/share/classes/java/nio/channels/Channels.java	2009-02-13 21:10:32.000000000 +0000
+++ openjdk/jdk/src/share/classes/java/nio/channels/Channels.java	2009-02-14 01:20:16.000000000 +0000
@@ -42,6 +42,7 @@
 import java.nio.charset.CoderResult;
 import java.nio.charset.UnsupportedCharsetException;
 import java.nio.channels.spi.AbstractInterruptibleChannel;
+import java.util.concurrent.ExecutionException;
 import sun.nio.ch.ChannelInputStream;
 import sun.nio.cs.StreamDecoder;
 import sun.nio.cs.StreamEncoder;
@@ -469,4 +470,151 @@
         return newWriter(ch, Charset.forName(csName).newEncoder(), -1);
     }
 
+    /**
+     * {@note new}
+     * Constructs a stream that reads bytes from the given channel.
+     *
+     * <p> The stream will not be buffered, and it will not support the {@link
+     * InputStream#mark mark} or {@link InputStream#reset reset} methods.  The
+     * stream will be safe for access by multiple concurrent threads.  Closing
+     * the stream will in turn cause the channel to be closed.  </p>
+     *
+     * @param  ch
+     *         The channel from which bytes will be read
+     *
+     * @return  A new input stream
+     *
+     * @since 1.7
+     */
+    public static InputStream newInputStream(final AsynchronousByteChannel ch) {
+        return new InputStream() {
+            private ByteBuffer bb = null;
+            private byte[] bs = null;           // Invoker's previous array
+            private byte[] b1 = null;
+
+
+            public synchronized int read() throws IOException {
+                if (b1 == null)
+                    b1 = new byte[1];
+                int n = this.read(b1);
+                if (n == 1)
+                    return b1[0] & 0xff;
+                return -1;
+            }
+ 
+            public synchronized int read(byte[] bs, int off, int len)
+                throws IOException
+            {
+                if ((off < 0) || (off > bs.length) || (len < 0) ||
+                    ((off + len) > bs.length) || ((off + len) < 0)) {
+                    throw new IndexOutOfBoundsException();
+                } else if (len == 0)
+                    return 0;
+
+                ByteBuffer bb = ((this.bs == bs)
+                                 ? this.bb
+                                 : ByteBuffer.wrap(bs));
+                bb.position(off);
+                bb.limit(Math.min(off + len, bb.capacity()));
+                this.bb = bb;
+                this.bs = bs;
+
+                boolean interrupted = false;
+                try {
+                    for (;;) {
+                        try {
+                            return ch.read(bb).get();
+                        } catch (ExecutionException ee) {
+                            throw new IOException(ee.getCause());
+                        } catch (InterruptedException ie) {
+                            interrupted = true;
+                        }
+                     }
+                } finally {
+                    if (interrupted)
+                        Thread.currentThread().interrupt();
+                 }
+            }
+ 
+ 
+            public void close() throws IOException {
+                ch.close();
+            }
+        };
+     }
+ 
+    /**
+     * {@note new}
+     * Constructs a stream that writes bytes to the given channel.
+     *
+     * <p> The stream will not be buffered. The stream will be safe for access
+     * by multiple concurrent threads.  Closing the stream will in turn cause
+     * the channel to be closed.  </p>
+     *
+     * @param  ch
+     *         The channel to which bytes will be written
+     *
+     * @return  A new output stream
+     *
+     * @since 1.7
+     */
+    public static OutputStream newOutputStream(final AsynchronousByteChannel ch) {
+        return new OutputStream() {
+ 
+            private ByteBuffer bb = null;
+            private byte[] bs = null;   // Invoker's previous array
+            private byte[] b1 = null;
+ 
+            public synchronized void write(int b) throws IOException {
+               if (b1 == null)
+                    b1 = new byte[1];
+                b1[0] = (byte)b;
+                this.write(b1);
+             }
+ 
+ 
+            public synchronized void write(byte[] bs, int off, int len)
+                throws IOException
+            {
+                if ((off < 0) || (off > bs.length) || (len < 0) ||
+                    ((off + len) > bs.length) || ((off + len) < 0)) {
+                    throw new IndexOutOfBoundsException();
+                } else if (len == 0) {
+                    return;
+                }
+                ByteBuffer bb = ((this.bs == bs)
+                                 ? this.bb
+                                 : ByteBuffer.wrap(bs));
+                bb.limit(Math.min(off + len, bb.capacity()));
+                bb.position(off);
+                this.bb = bb;
+                this.bs = bs;
+
+                boolean interrupted = false;
+                try {
+                    while (bb.remaining() > 0) {
+                        try {
+                            ch.write(bb).get();
+                        } catch (ExecutionException ee) {
+                            throw new IOException(ee.getCause());
+                        } catch (InterruptedException ie) {
+                            interrupted = true;
+                        }
+                     } 
+                } finally {
+                    if (interrupted)
+                        Thread.currentThread().interrupt();
+                 }
+             }
+ 
+ 
+            public void close() throws IOException {
+                ch.close();
+            }
+        };
+     }
+ 
+ 
 }
+
+
diff -Nru openjdk.orig/jdk/src/share/classes/java/nio/channels/DatagramChannel.java openjdk/jdk/src/share/classes/java/nio/channels/DatagramChannel.java
--- openjdk.orig/jdk/src/share/classes/java/nio/channels/DatagramChannel.java	2009-02-13 21:10:32.000000000 +0000
+++ openjdk/jdk/src/share/classes/java/nio/channels/DatagramChannel.java	2009-02-14 01:15:49.000000000 +0000
@@ -31,12 +31,13 @@
 import java.net.SocketOption;
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
-import java.nio.channels.spi.*;
+import java.nio.channels.spi.AbstractSelectableChannel;
+import java.nio.channels.spi.SelectorProvider;
 
 /**
  * A selectable channel for datagram-oriented sockets.
  *
- * <p> A datagram channel is created by invoking one of the {@link #open open} methods
+ * <p> {@note revised} A datagram channel is created by invoking one of the {@link #open open} methods
  * of this class. It is not possible to create a channel for an arbitrary,
  * pre-existing datagram socket. A newly-created datagram channel is open but not
  * connected. A datagram channel need not be connected in order for the {@link #send
@@ -53,7 +54,8 @@
  * be determined by invoking its {@link #isConnected isConnected} method.
  *
  * <p> Socket options are configured using the {@link #setOption(SocketOption,Object)
- * setOption} method. Datagram channels support the following options:
+ * setOption} method. A datagram channel to an Internet Protocol socket supports
+ * the following options:
  * <blockquote>
  * <table border>
  *   <tr>
@@ -106,6 +108,7 @@
  * @author Mark Reinhold
  * @author JSR-51 Expert Group
  * @since 1.4
+ * @updated 1.7
  */
 
 public abstract class DatagramChannel
diff -Nru openjdk.orig/jdk/src/share/classes/java/nio/channels/exceptions openjdk/jdk/src/share/classes/java/nio/channels/exceptions
--- openjdk.orig/jdk/src/share/classes/java/nio/channels/exceptions	2009-02-13 21:10:40.000000000 +0000
+++ openjdk/jdk/src/share/classes/java/nio/channels/exceptions	2009-02-13 22:29:15.000000000 +0000
@@ -150,6 +150,20 @@
 
 SINCE=1.7
 
+SUPER=java.io.IOException
+
+gen InterruptedByTimeoutException "
+ * Checked exception received by a thread when a timeout elapses before an
+ * asynchronous operation completes." \
+ -4268008601014042947L
+
+SUPER=IllegalArgumentException
+
+gen IllegalChannelGroupException "
+ * Unchecked exception thrown when an attempt is made to open a channel
+ * in a group that was not created by the same provider. " \
+ -2495041211157744253L
+ 
 SUPER=IllegalStateException
 
 gen AlreadyBoundException "
@@ -157,3 +171,23 @@
  * network oriented channel that is already bound." \
  6796072983322737592L
 
+gen AcceptPendingException "
+ * Unchecked exception thrown when an attempt is made to initiate an accept
+ * operation on a channel and a previous accept operation has not completed." \
+ 2721339977965416421L
+
+gen ReadPendingException "
+ * Unchecked exception thrown when an attempt is made to read from an
+ * asynchronous socket channel and a previous read has not completed." \
+ 1986315242191227217L
+
+gen WritePendingException "
+ * Unchecked exception thrown when an attempt is made to write to an
+ * asynchronous socket channel and a previous write has not completed." \
+ 7031871839266032276L
+
+gen ShutdownChannelGroupException "
+ * Unchecked exception thrown when an attempt is made to construct a channel in 
+ * a group that is shutdown or the completion handler for an I/O operation 
+ * cannot be invoked because the channel group is shutdown." \
+ -3903801676350154157L
diff -Nru openjdk.orig/jdk/src/share/classes/java/nio/channels/FileChannel.java openjdk/jdk/src/share/classes/java/nio/channels/FileChannel.java
--- openjdk.orig/jdk/src/share/classes/java/nio/channels/FileChannel.java	2009-02-13 21:10:32.000000000 +0000
+++ openjdk/jdk/src/share/classes/java/nio/channels/FileChannel.java	2009-02-14 01:14:05.000000000 +0000
@@ -30,17 +30,27 @@
 import java.nio.MappedByteBuffer;
 import java.nio.channels.spi.AbstractInterruptibleChannel;
 
+import java.nio.file.OpenOption;
+import java.nio.file.Path;
+import java.nio.file.attribute.FileAttribute;
+import java.nio.file.spi.FileSystemProvider;
+
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
 
 /**
  * A channel for reading, writing, mapping, and manipulating a file.
  *
- * <p> A file channel has a current <i>position</i> within its file which can
- * be both {@link #position() </code>queried<code>} and {@link #position(long)
- * </code>modified<code>}.  The file itself contains a variable-length sequence
+ * <p> {@note revised}
+ * A file channel is a {@link SeekableByteChannel} that is connected to
+ * a file. It has a current <i>position</i> within its file which can
+ * be both {@link #position() <i>queried</i>} and {@link #position(long)
+ * <i>modified</i>}.  The file itself contains a variable-length sequence
  * of bytes that can be read and written and whose current {@link #size
- * </code><i>size</i><code>} can be queried.  The size of the file increases
+ * <i>size</i>} can be queried.  The size of the file increases
  * when bytes are written beyond its current size; the size of the file
- * decreases when it is {@link #truncate </code><i>truncated</i><code>}.  The
+ * decreases when it is {@link #truncate <i>truncated</i>}.  The
  * file may also have some associated <i>metadata</i> such as access
  * permissions, content type, and last-modification time; this class does not
  * define methods for metadata access.
@@ -50,12 +60,12 @@
  *
  * <ul>
  *
- *   <li><p> Bytes may be {@link #read(ByteBuffer, long) </code>read<code>} or
- *   {@link #write(ByteBuffer, long) </code>written<code>} at an absolute
+ *   <li><p> Bytes may be {@link #read(ByteBuffer, long) read} or
+ *   {@link #write(ByteBuffer, long) <i>written</i>} at an absolute
  *   position in a file in a way that does not affect the channel's current
  *   position.  </p></li>
  *
- *   <li><p> A region of a file may be {@link #map </code>mapped<code>}
+ *   <li><p> A region of a file may be {@link #map <i>mapped</i>}
  *   directly into memory; for large files this is often much more efficient
  *   than invoking the usual <tt>read</tt> or <tt>write</tt> methods.
  *   </p></li>
@@ -64,13 +74,13 @@
  *   out<code>} to the underlying storage device, ensuring that data are not
  *   lost in the event of a system crash.  </p></li>
  *
- *   <li><p> Bytes can be transferred from a file {@link #transferTo </code>to
- *   some other channel<code>}, and {@link #transferFrom </code>vice
- *   versa<code>}, in a way that can be optimized by many operating systems
+ *   <li><p> Bytes can be transferred from a file {@link #transferTo <i>to
+ *   some other channel</i>}, and {@link #transferFrom <i>vice
+ *   versa</i>}, in a way that can be optimized by many operating systems
  *   into a very fast transfer directly to or from the filesystem cache.
  *   </p></li>
  *
- *   <li><p> A region of a file may be {@link FileLock </code>locked<code>}
+ *   <li><p> A region of a file may be {@link FileLock <i>locked</i>}
  *   against access by other programs.  </p></li>
  *
  * </ul>
@@ -96,25 +106,23 @@
  * machine.  The exact nature of any such inconsistencies are system-dependent
  * and are therefore unspecified.
  *
- * <p> This class does not define methods for opening existing files or for
- * creating new ones; such methods may be added in a future release.  In this
- * release a file channel can be obtained from an existing {@link
- * java.io.FileInputStream#getChannel FileInputStream}, {@link
+ * <p> A file channel is created by invoking one of the {@link #open open}
+ * methods defined by this class. A file channel can also be obtained from an
+ * existing {@link java.io.FileInputStream#getChannel FileInputStream}, {@link
  * java.io.FileOutputStream#getChannel FileOutputStream}, or {@link
  * java.io.RandomAccessFile#getChannel RandomAccessFile} object by invoking
  * that object's <tt>getChannel</tt> method, which returns a file channel that
- * is connected to the same underlying file.
+ * is connected to the same underlying file. Where the file channel is obtained
+ * from an existing stream or random access file then the state of the file
+ * channel is intimately connected to that of the object whose <tt>getChannel</tt>
+ * method returned the channel.  Changing the channel's position, whether
+ * explicitly or by reading or writing bytes, will change the file position of
+ * the originating object, and vice versa. Changing the file's length via the
+ * file channel will change the length seen via the originating object, and vice
+ * versa.  Changing the file's content by writing bytes will change the content
+ * seen by the originating object, and vice versa.
  *
- * <p> The state of a file channel is intimately connected to that of the
- * object whose <tt>getChannel</tt> method returned the channel.  Changing the
- * channel's position, whether explicitly or by reading or writing bytes, will
- * change the file position of the originating object, and vice versa.
- * Changing the file's length via the file channel will change the length seen
- * via the originating object, and vice versa.  Changing the file's content by
- * writing bytes will change the content seen by the originating object, and
- * vice versa.
- *
- * <a name="open-mode"><p> At various points this class specifies that an
+ * <a name="open-mode"></a> <p> At various points this class specifies that an
  * instance that is "open for reading," "open for writing," or "open for
  * reading and writing" is required.  A channel obtained via the {@link
  * java.io.FileInputStream#getChannel getChannel} method of a {@link
@@ -127,7 +135,7 @@
  * was created with mode <tt>"r"</tt> and will be open for reading and writing
  * if the instance was created with mode <tt>"rw"</tt>.
  *
- * <a name="append-mode"><p> A file channel that is open for writing may be in
+ * <a name="append-mode"></a><p> A file channel that is open for writing may be in
  * <i>append mode</i>, for example if it was obtained from a file-output stream
  * that was created by invoking the {@link
  * java.io.FileOutputStream#FileOutputStream(java.io.File,boolean)
@@ -147,11 +155,12 @@
  * @author Mike McCloskey
  * @author JSR-51 Expert Group
  * @since 1.4
+ * @updated 1.7
  */
 
 public abstract class FileChannel
     extends AbstractInterruptibleChannel
-    implements ByteChannel, GatheringByteChannel, ScatteringByteChannel
+    implements ByteChannel, GatheringByteChannel, ScatteringByteChannel, SeekableByteChannel
 {
 
     /**
@@ -978,4 +987,176 @@
         return tryLock(0L, Long.MAX_VALUE, false);
     }
 
+    /**
+     * {@note new}
+     * Opens or creates a file, returning a file channel to access the file.
+     *
+     * <p> The {@code options} parameter determines how the file is opened.
+     * The {@link StandardOpenOption#READ READ} and {@link StandardOpenOption#WRITE
+     * WRITE} options determine if the file should be opened for reading and/or
+     * writing. If neither option (or the {@link StandardOpenOption#APPEND APPEND}
+     * option) is contained in the array then the file is opened for reading.
+     * By default reading or writing commences at the beginning of the file.
+     *
+     * <p> In the addition to {@code READ} and {@code WRITE}, the following
+     * options may be present:
+     *
+     * <table border=1 cellpadding=5 summary="">
+     * <tr> <th>Option</th> <th>Description</th> </tr>
+     * <tr>
+     *   <td> {@link StandardOpenOption#APPEND APPEND} </td>
+     *   <td> If this option is present then the file is opened for writing and
+     *     each invocation of the channel's {@code write} method first advances
+     *     the position to the end of the file and then writes the requested
+     *     data. Whether the advancement of the position and the writing of the
+     *     data are done in a single atomic operation is system-dependent and
+     *     therefore unspecified. This option may not be used in conjunction
+     *     with the {@code READ} or {@code TRUNCATE_EXISTING} options. </td>
+     * </tr>
+     * <tr>
+     *   <td> {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} </td>
+     *   <td> If this option is present then the existing file is truncated to
+     *   a size of 0 bytes. This option is ignored when the file is opened only
+     *   for reading. </td>
+     * </tr>
+     * <tr>
+     *   <td> {@link StandardOpenOption#CREATE_NEW CREATE_NEW} </td>
+     *   <td> If this option is present then a new file is created, failing if
+     *   the file already exists. When creating a file the check for the
+     *   existence of the file and the creation of the file if it does not exist
+     *   is atomic with respect to other file system operations. This option is
+     *   ignored when the file is opened only for reading. </td>
+     * </tr>
+     * <tr>
+     *   <td > {@link StandardOpenOption#CREATE CREATE} </td>
+     *   <td> If this option is present then an existing file is opened if it
+     *   exists, otherwise a new file is created. When creating a file the check
+     *   for the existence of the file and the creation of the file if it does
+     *   not exist is atomic with respect to other file system operations. This
+     *   option is ignored if the {@code CREATE_NEW} option is also present or
+     *   the file is opened only for reading. </td>
+     * </tr>
+     * <tr>
+     *   <td > {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} </td>
+     *   <td> When this option is present then the implementation makes a
+     *   <em>best effort</em> attempt to delete the file when closed by the
+     *   the {@link #close close} method. If the {@code close} method is not
+     *   invoked then a <em>best effort</em> attempt is made to delete the file
+     *   when the Java virtual machine terminates. </td>
+     * </tr>
+     * <tr>
+     *   <td>{@link StandardOpenOption#SPARSE SPARSE} </td>
+     *   <td> When creating a new file this option is a <em>hint</em> that the
+     *   new file will be sparse. This option is ignored when not creating
+     *   a new file. </td>
+     * </tr>
+     * <tr>
+     *   <td> {@link StandardOpenOption#SYNC SYNC} </td>
+     *   <td> Requires that every update to the file's content or metadata be
+     *   written synchronously to the underlying storage device. (see <a
+     *   href="../file/package-summary.html#integrity"> Synchronized I/O file
+     *   integrity</a>). </td>
+     * <tr>
+     * <tr>
+     *   <td> {@link StandardOpenOption#DSYNC DSYNC} </td>
+     *   <td> Requires that every update to the file's content be written
+     *   synchronously to the underlying storage device. (see <a
+     *   href="../file/package-summary.html#integrity"> Synchronized I/O file
+     *   integrity</a>). </td>
+     * </tr>
+     * </table>
+     *
+     * <p> An implementation may also support additional options.
+     *
+     * <p> The {@code attrs} parameter is an optional array of file {@link
+     * FileAttribute file-attributes} to set atomically when creating the file.
+     *
+     * <p> The new channel is created by invoking the {@link
+     * FileSystemProvider#newFileChannel newFileChannel} method on the
+     * provider that created the {@code Path}.
+     *
+     * @param   file
+     *          The path of the file to open or create
+     * @param   options
+     *          Options specifying how the file is opened
+     * @param   attrs
+     *          An optional list of file attributes to set atomically when
+     *          creating the file
+     *
+     * @return  A new file channel
+     *
+     * @throws  IllegalArgumentException
+     *          If the set contains an invalid combination of options
+     * @throws  UnsupportedOperationException
+     *          If the {@code file} is associated with a provider that does not
+     *          support creating file channels, or an unsupported open option is
+     *          specified, or the array contains an attribute that cannot be set
+     *          atomically when creating the file
+     * @throws  IOException
+     *          If an I/O error occurs
+     * @throws  SecurityException
+     *          If a security manager is installed and it denies an
+     *          unspecified permission required by the implementation.
+     *          In the case of the default provider, the {@link
+     *          SecurityManager#checkRead(String)} method is invoked to check
+     *          read access if the file is opened for reading. The {@link
+     *          SecurityManager#checkWrite(String)} method is invoked to check
+     *          write access if the file is opened for writing
+     *
+     * @since   1.7
+     */
+    public static FileChannel open(Path file,
+				   Set<? extends OpenOption> options,
+				   FileAttribute<?>... attrs)
+        throws IOException
+    {
+        FileSystemProvider provider = file.getFileSystem().provider();
+        return provider.newFileChannel(file, options, attrs);
+     }
+ 
+    private static final FileAttribute<?>[] NO_ATTRIBUTES = new FileAttribute[0];
+ 
+     /**
+     * {@note new}
+     * Opens or creates a file, returning a file channel to access the file.
+     *
+     * <p> An invocation of this method behaves in exactly the same way as the
+     * invocation
+     * <pre>
+     *     fc.{@link #open(Path,Set,FileAttribute[]) open}(file, options, new FileAttribute&lt;?&gt;[0]);
+     * </pre>
+     *
+     * @param   file
+     *          The path of the file to open or create
+     * @param   options
+     *          Options specifying how the file is opened
+     *
+     * @return  A new file channel
+     *
+     * @throws  IllegalArgumentException
+     *          If the set contains an invalid combination of options
+     * @throws  UnsupportedOperationException
+     *          If the {@code file} is associated with a provider that does not
+     *          support creating file channels, or an unsupported open option is
+     *          specified
+     * @throws  IOException
+     *          If an I/O error occurs
+     * @throws  SecurityException
+     *          If a security manager is installed and it denies an
+     *          unspecified permission required by the implementation.
+     *          In the case of the default provider, the {@link
+     *          SecurityManager#checkRead(String)} method is invoked to check
+     *          read access if the file is opened for reading. The {@link
+     *          SecurityManager#checkWrite(String)} method is invoked to check
+     *          write access if the file is opened for writing
+     *
+     * @since   1.7
+     */
+    public static FileChannel open(Path file, OpenOption... options)
+        throws IOException
+    {
+        Set<OpenOption> set = new HashSet<OpenOption>(options.length);
+        Collections.addAll(set, options);
+        return open(file, set, NO_ATTRIBUTES);
+    }
 }
diff -Nru openjdk.orig/jdk/src/share/classes/java/nio/channels/FileLock.java openjdk/jdk/src/share/classes/java/nio/channels/FileLock.java
--- openjdk.orig/jdk/src/share/classes/java/nio/channels/FileLock.java	2009-02-13 21:10:32.000000000 +0000
+++ openjdk/jdk/src/share/classes/java/nio/channels/FileLock.java	2009-02-13 22:22:43.000000000 +0000
@@ -27,14 +27,16 @@
 
 import java.io.IOException;
 
-
 /**
  * A token representing a lock on a region of a file.
  *
  * <p> A file-lock object is created each time a lock is acquired on a file via
  * one of the {@link FileChannel#lock(long,long,boolean) lock} or {@link
- * FileChannel#tryLock(long,long,boolean) tryLock} methods of the {@link
- * FileChannel} class.
+ * FileChannel#tryLock(long,long,boolean) tryLock} methods of the
+ * {@link FileChannel} class, or the {@link
+ * AsynchronousFileChannel#lock(long,long,boolean,Object,CompletionHandler) lock}
+ * or {@link AsynchronousFileChannel#tryLock(long,long,boolean) tryLock}
+ * methods of the {@link AsynchronousFileChannel} class.
  *
  * <p> A file-lock object is initially valid.  It remains valid until the lock
  * is released by invoking the {@link #release release} method, by closing the
@@ -70,8 +72,7 @@
  * <p> File-lock objects are safe for use by multiple concurrent threads.
  *
  *
- * <a name="pdep">
- * <h4> Platform dependencies </h4>
+ * <a name="pdep"><h4> Platform dependencies </h4></a>
  *
  * <p> This file-locking API is intended to map directly to the native locking
  * facility of the underlying operating system.  Thus the locks held on a file
@@ -93,7 +94,7 @@
  *
  * <p> On some systems, acquiring a mandatory lock on a region of a file
  * prevents that region from being {@link java.nio.channels.FileChannel#map
- * </code>mapped into memory<code>}, and vice versa.  Programs that combine
+ * <i>mapped into memory</i>}, and vice versa.  Programs that combine
  * locking and mapping should be prepared for this combination to fail.
  *
  * <p> On some systems, closing a channel releases all locks held by the Java
@@ -113,11 +114,12 @@
  * @author Mark Reinhold
  * @author JSR-51 Expert Group
  * @since 1.4
+ * @updated 1.7
  */
 
 public abstract class FileLock {
 
-    private final FileChannel channel;
+    private final Channel channel;
     private final long position;
     private final long size;
     private final boolean shared;
@@ -159,11 +161,66 @@
     }
 
     /**
-     * Returns the file channel upon whose file this lock is held.  </p>
+     * {@note new} Initializes a new instance of this class.
+     *
+     * @param  channel
+     *         The channel upon whose file this lock is held
+     *
+     * @param  position
+     *         The position within the file at which the locked region starts;
+     *         must be non-negative
+     *
+     * @param  size
+     *         The size of the locked region; must be non-negative, and the sum
+     *         <tt>position</tt>&nbsp;+&nbsp;<tt>size</tt> must be non-negative
+     *
+     * @param  shared
+     *         <tt>true</tt> if this lock is shared,
+     *         <tt>false</tt> if it is exclusive
+     *
+     * @throws IllegalArgumentException
+     *         If the preconditions on the parameters do not hold
+     *
+     * @since 1.7
+     */
+    protected FileLock(AsynchronousFileChannel channel,
+                       long position, long size, boolean shared)
+    {
+        if (position < 0)
+            throw new IllegalArgumentException("Negative position");
+        if (size < 0)
+            throw new IllegalArgumentException("Negative size");
+        if (position + size < 0)
+            throw new IllegalArgumentException("Negative position + size");
+        this.channel = channel;
+        this.position = position;
+        this.size = size;
+        this.shared = shared;
+    }
+
+    /**
+     * {@note revised}
+     * Returns the file channel upon whose file this lock was acquired.
      *
-     * @return  The file channel
+     * <p> This method has been superseded by the {@link #acquiredBy acquiredBy}
+     * method.
+     *
+     * @return  The file channel, or {@code null} if the file lock was not
+     *          acquired by a file channel.
      */
     public final FileChannel channel() {
+        return (channel instanceof FileChannel) ? (FileChannel)channel : null;
+    }
+
+    /**
+     * {@note new}
+     * Returns the channel upon whose file this lock was acquired.
+     *
+     * @return  The channel upon whose file this lock was acquired.
+     *
+     * @since 1.7
+     */
+    public Channel acquiredBy() {
         return channel;
     }
 
diff -Nru openjdk.orig/jdk/src/share/classes/java/nio/channels/package-info.java openjdk/jdk/src/share/classes/java/nio/channels/package-info.java
--- openjdk.orig/jdk/src/share/classes/java/nio/channels/package-info.java	2009-02-13 21:10:32.000000000 +0000
+++ openjdk/jdk/src/share/classes/java/nio/channels/package-info.java	2009-02-13 22:23:47.000000000 +0000
@@ -46,6 +46,10 @@
  *     <td>Can read/write to/from a&nbsp;buffer</td></tr>
  * <tr><td valign=top><tt>&nbsp;&nbsp;&nbsp;&nbsp;<i>{@link java.nio.channels.SeekableByteChannel}</i></tt></td>
  *     <td>A {@code ByteChannel} connected to an entity that contains a variable-length sequence of bytes</td></tr>
+ * <tr><td valign=top><tt>&nbsp;&nbsp;<i>{@link java.nio.channels.AsynchronousChannel}</i></tt></td>
+ *     <td>Supports asynchronous I/O operations.</td></tr>
+ * <tr><td valign=top><tt>&nbsp;&nbsp;&nbsp;&nbsp;<i>{@link java.nio.channels.AsynchronousByteChannel}</i></tt></td>
+ *     <td>Can read and write bytes asynchronously</td></tr>
  * <tr><td valign=top><tt>&nbsp;&nbsp;<i>{@link java.nio.channels.NetworkChannel}</i></tt></td>
  *     <td>A channel to a network socket</td></tr>
  * <tr><td valign=top><tt>&nbsp;&nbsp;&nbsp;&nbsp;<i>{@link java.nio.channels.MulticastChannel}</i></tt></td>
@@ -218,12 +222,70 @@
  * directly; custom channel classes should extend the appropriate {@link
  * java.nio.channels.SelectableChannel} subclasses defined in this package.
  *
+ * <a name="async"></a>
+ *
+ * <blockquote><table cellspacing=1 cellpadding=0 summary="Lists asynchronous channels and their descriptions">
+ * <tr><th><p align="left">Asynchronous I/O</p></th><th><p align="left">Description</p></th></tr>
+ * <tr><td valign=top><tt>{@link java.nio.channels.AsynchronousFileChannel}</tt></td>
+ *     <td>An asynchronous channel for reading, writing, and manipulating a file</td></tr>
+ * <tr><td valign=top><tt>{@link java.nio.channels.AsynchronousSocketChannel}</tt></td>
+ *     <td>An asynchronous channel to a stream-oriented connecting socket</td></tr>
+ * <tr><td valign=top><tt>{@link java.nio.channels.AsynchronousServerSocketChannel}&nbsp;&nbsp;</tt></td>
+ *     <td>An asynchronous channel to a stream-oriented listening socket</td></tr>
+ * <tr><td valign=top><tt>{@link java.nio.channels.AsynchronousDatagramChannel}</tt></td>
+ *     <td>An asynchronous channel to a datagram-oriented socket</td></tr>
+ * <tr><td valign=top><tt>{@link java.nio.channels.CompletionHandler}</tt></td>
+ *     <td>A handler for consuming the result of an asynchronous operation</td></tr>
+ * <tr><td valign=top><tt>{@link java.nio.channels.AsynchronousChannelGroup}</tt></td>
+ *     <td>A grouping of asynchronous channels for the purpose of resource sharing</td></tr>
+ * </table></blockquote>
+ *
+ * <p> {@link java.nio.channels.AsynchronousChannel Asynchronous channels} are a
+ * special type of channel capable of asynchronous I/O operations. Asynchronous
+ * channels are non-blocking and define methods to initiate asynchronous
+ * operations, returning a {@link java.util.concurrent.Future} representing the
+ * pending result of each operation. The {@code Future} can be used to poll or
+ * wait for the result of the operation. Asynchronous I/O operations can also
+ * specify a {@link java.nio.channels.CompletionHandler} to invoke when the
+ * operation completes. A completion handler is user provided code that is executed
+ * to consume the result of I/O operation.
+ *
+ * <p> This package defines asynchronous-channel classes that are connected to
+ * a stream-oriented connecting or listening socket, or a datagram-oriented socket.
+ * It also defines the {@link java.nio.channels.AsynchronousFileChannel} class
+ * for asynchronous reading, writing, and manipulating a file. As with the {@link
+ * java.nio.channels.FileChannel} it supports operations to truncate the file
+ * to a specific size, force updates to the file to be written to the storage
+ * device, or acquire locks on the whole file or on a specific region of the file.
+ * Unlike the {@code FileChannel} it does not define methods for mapping a
+ * region of the file directly into memory. Where memory mapped I/O is required,
+ * then a {@code FileChannel} can be used.
+ *
+ * <p> Asynchronous channels are bound to an asynchronous channel group for the
+ * purpose of resource sharing. A group has an associated {@link
+ * java.util.concurrent.ExecutorService} to which tasks are submitted to handle
+ * I/O events and dispatch to completion handlers that consume the result of
+ * asynchronous operations performed on channels in the group. The group can
+ * optionally be specified when creating the channel or the channel can be bound
+ * to a <em>default group</em>. Sophisticated users may wish to create their
+ * own asynchronous channel groups or configure the {@code ExecutorService}
+ * that will be used for the default group.
+ *
+ * <p> As with selectors, the implementatin of asynchronous channels can be
+ * replaced by "plugging in" an alternative definition or instance of the {@link
+ * java.nio.channels.spi.AsynchronousChannelProvider} class defined in the
+ * <tt>{@link java.nio.channels.spi}</tt> package.  It is not expected that many
+ * developers will actually make use of this facility; it is provided primarily
+ * so that sophisticated users can take advantage of operating-system-specific
+ * asynchronous I/O mechanisms when very high performance is required.
+ *
  * <hr width="80%">
  * <p> Unless otherwise noted, passing a <tt>null</tt> argument to a constructor
  * or method in any class or interface in this package will cause a {@link
  * java.lang.NullPointerException NullPointerException} to be thrown.
  *
  * @since 1.4
+ * @updated 1.7
  * @author Mark Reinhold
  * @author JSR-51 Expert Group
  */
diff -Nru openjdk.orig/jdk/src/share/classes/java/util/Scanner.java openjdk/jdk/src/share/classes/java/util/Scanner.java
--- openjdk.orig/jdk/src/share/classes/java/util/Scanner.java	2009-02-13 21:10:48.000000000 +0000
+++ openjdk/jdk/src/share/classes/java/util/Scanner.java	2009-02-13 22:32:01.000000000 +0000
@@ -32,9 +32,10 @@
 import java.nio.channels.*;
 import java.nio.charset.*;
 import java.text.*;
-import java.util.Locale;
 import sun.misc.LRUCache;
 
+import java.nio.file.FileRef;
+
 /**
  * A simple text scanner which can parse primitive types and strings using
  * regular expressions.
@@ -673,6 +674,49 @@
     }
 
     /**
+     * {@note new}
+     * Constructs a new <code>Scanner</code> that produces values scanned
+     * from the specified file. Bytes from the file are converted into
+     * characters using the underlying platform's
+     * {@linkplain java.nio.charset.Charset#defaultCharset() default charset}.
+     *
+     * @param   source
+     *          A file to be scanned
+     * @throws  IOException
+     *          if an I/O error occurs opening source
+     *
+     * @since   1.7
+     */
+    public Scanner(FileRef source)
+        throws IOException
+    {
+        this(source.newByteChannel());
+    }
+
+    /**
+     * {@note new}
+     * Constructs a new <code>Scanner</code> that produces values scanned
+     * from the specified file. Bytes from the file are converted into
+     * characters using the specified charset.
+     *
+     * @param   source
+     *          A file to be scanned
+     * @param   charsetName
+     *          The encoding type used to convert bytes from the file
+     *          into characters to be scanned
+     * @throws  IOException
+     *          if an I/O error occurs opening source
+     * @throws  IllegalArgumentException
+     *          if the specified encoding is not found
+     * @since   1.7
+     */
+    public Scanner(FileRef source, String charsetName)
+        throws IOException
+    {
+        this(source.newByteChannel(), charsetName);
+    }
+
+    /**
      * Constructs a new <code>Scanner</code> that produces values scanned
      * from the specified string.
      *
diff -Nru openjdk.orig/jdk/src/share/classes/sun/nio/ch/MembershipRegistry.java openjdk/jdk/src/share/classes/sun/nio/ch/MembershipRegistry.java
--- openjdk.orig/jdk/src/share/classes/sun/nio/ch/MembershipRegistry.java	2009-02-14 02:09:45.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/nio/ch/MembershipRegistry.java	2009-02-14 03:34:58.000000000 +0000
@@ -120,10 +120,12 @@
      * Invalidate all keys in the registry
      */
     void invalidateAll() {
-        for (InetAddress group: groups.keySet()) {
-            for (MembershipKeyImpl key: groups.get(group)) {
-                key.invalidate();
+        if (groups != null) {
+            for (InetAddress group: groups.keySet()) {
+                for (MembershipKeyImpl key: groups.get(group)) {
+                    key.invalidate();
+                }
             }
-        }
+	}
     }
 }
diff -Nru openjdk.orig/jdk/src/share/classes/sun/nio/ch/Net.java openjdk/jdk/src/share/classes/sun/nio/ch/Net.java
--- openjdk.orig/jdk/src/share/classes/sun/nio/ch/Net.java	2009-02-11 23:11:27.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/nio/ch/Net.java	2009-02-14 01:49:30.000000000 +0000
@@ -32,7 +32,6 @@
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
-
 class Net {                                             // package-private
 
     private Net() { }
@@ -207,7 +206,7 @@
     // -- Socket options
 
     static void setSocketOption(FileDescriptor fd, ProtocolFamily family,
-                                SocketOption name, Object value)
+                                SocketOption<?> name, Object value)
         throws IOException
     {
         if (value == null)
@@ -262,7 +261,7 @@
     }
 
     static Object getSocketOption(FileDescriptor fd, ProtocolFamily family,
-                                  SocketOption name)
+                                  SocketOption<?> name)
         throws IOException
     {
         Class<?> type = name.type();
@@ -489,4 +488,11 @@
         initIDs();
     }
 
+    // From 1.7
+
+    private static native void setIntOption1(FileDescriptor fd, boolean mayNeedConversion,
+                                             int level, int opt, int arg)
+        throws IOException;
+
+
 }
diff -Nru openjdk.orig/jdk/src/share/classes/sun/security/util/SecurityConstants.java openjdk/jdk/src/share/classes/sun/security/util/SecurityConstants.java
--- openjdk.orig/jdk/src/share/classes/sun/security/util/SecurityConstants.java	2009-02-11 23:11:35.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/security/util/SecurityConstants.java	2009-02-11 23:14:46.000000000 +0000
@@ -52,6 +52,7 @@
     public static final String FILE_EXECUTE_ACTION = "execute";
     public static final String FILE_READ_ACTION = "read";
     public static final String FILE_WRITE_ACTION = "write";
+    public static final String FILE_READLINK_ACTION = "readlink";
 
     public static final String SOCKET_RESOLVE_ACTION = "resolve";
     public static final String SOCKET_CONNECT_ACTION = "connect";
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/nio/ch/FileDispatcher.java openjdk/jdk/src/solaris/classes/sun/nio/ch/FileDispatcher.java
--- openjdk.orig/jdk/src/solaris/classes/sun/nio/ch/FileDispatcher.java	2009-02-11 23:11:51.000000000 +0000
+++ openjdk/jdk/src/solaris/classes/sun/nio/ch/FileDispatcher.java	2009-02-11 23:14:46.000000000 +0000
@@ -35,6 +35,11 @@
 class FileDispatcher extends NativeDispatcher
 {
 
+    public static final int NO_LOCK = -1;       // Failed to lock
+    public static final int LOCKED = 0;         // Obtained requested lock
+    public static final int RET_EX_LOCK = 1;    // Obtained exclusive lock
+    public static final int INTERRUPTED = 2;    // Request interrupted
+
     static {
         Util.load();
         init();
@@ -77,6 +82,28 @@
         preClose0(fd);
     }
 
+    long size(FileDescriptor fd) throws IOException {
+        return size0(fd);
+    }
+
+    int truncate(FileDescriptor fd, long size) throws IOException {
+        return truncate0(fd, size);
+    }
+
+    int force(FileDescriptor fd, boolean metaData) throws IOException {
+        return force0(fd, metaData);
+    }
+
+    int lock(FileDescriptor fd, boolean blocking, long pos, long size,
+             boolean shared) throws IOException
+    {
+        return lock0(fd, blocking, pos, size, shared);
+    }
+
+    void release(FileDescriptor fd, long pos, long size) throws IOException {
+        release0(fd, pos, size);
+    }
+
     // -- Native methods --
 
     static native int read0(FileDescriptor fd, long address, int len)
@@ -105,4 +132,18 @@
 
     static native void init();
 
+    static native int force0(FileDescriptor fd, boolean metaData)
+        throws IOException;
+
+    static native int truncate0(FileDescriptor fd, long size)
+        throws IOException;
+
+    static native long size0(FileDescriptor fd) throws IOException;
+
+    static native int lock0(FileDescriptor fd, boolean blocking, long pos,
+                            long size, boolean shared) throws IOException;
+
+    static native void release0(FileDescriptor fd, long pos, long size)
+        throws IOException;
+
 }
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/nio/ch/InheritedChannel.java openjdk/jdk/src/solaris/classes/sun/nio/ch/InheritedChannel.java
--- openjdk.orig/jdk/src/solaris/classes/sun/nio/ch/InheritedChannel.java	2009-02-11 23:11:51.000000000 +0000
+++ openjdk/jdk/src/solaris/classes/sun/nio/ch/InheritedChannel.java	2009-02-14 01:21:46.000000000 +0000
@@ -34,6 +34,7 @@
 import java.nio.channels.SocketChannel;
 import java.nio.channels.ServerSocketChannel;
 import java.nio.channels.DatagramChannel;
+
 import java.nio.channels.spi.SelectorProvider;
 
 class InheritedChannel {
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/nio/ch/FileDispatcher.java openjdk/jdk/src/windows/classes/sun/nio/ch/FileDispatcher.java
--- openjdk.orig/jdk/src/windows/classes/sun/nio/ch/FileDispatcher.java	2009-02-11 23:11:51.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/nio/ch/FileDispatcher.java	2009-02-11 23:14:46.000000000 +0000
@@ -36,6 +36,11 @@
 class FileDispatcher extends NativeDispatcher
 {
 
+    public static final int NO_LOCK = -1;       // Failed to lock
+    public static final int LOCKED = 0;         // Obtained requested lock
+    public static final int RET_EX_LOCK = 1;    // Obtained exclusive lock
+    public static final int INTERRUPTED = 2;    // Request interrupted
+
     static {
         Util.load();
     }
@@ -78,6 +83,28 @@
         close0(fd);
     }
 
+    int force(FileDescriptor fd, boolean metaData) throws IOException {
+        return force0(fd, metaData);
+    }
+
+    int truncate(FileDescriptor fd, long size) throws IOException {
+        return truncate0(fd, size);
+    }
+
+    long size(FileDescriptor fd) throws IOException {
+        return size0(fd);
+    }
+
+    int lock(FileDescriptor fd, boolean blocking, long pos, long size,
+             boolean shared) throws IOException
+    {
+        return lock0(fd, blocking, pos, size, shared);
+    }
+
+    void release(FileDescriptor fd, long pos, long size) throws IOException {
+        release0(fd, pos, size);
+    }
+
     //-- Native methods
 
     static native int read0(FileDescriptor fd, long address, int len)
@@ -102,4 +129,17 @@
 
     static native void closeByHandle(long fd) throws IOException;
 
+    static native int force0(FileDescriptor fd, boolean metaData)
+        throws IOException;
+
+    static native int truncate0(FileDescriptor fd, long size)
+        throws IOException;
+
+    static native long size0(FileDescriptor fd) throws IOException;
+
+    static native int lock0(FileDescriptor fd, boolean blocking, long pos,
+                            long size, boolean shared) throws IOException;
+
+    static native void release0(FileDescriptor fd, long pos, long size)
+        throws IOException;
 }
