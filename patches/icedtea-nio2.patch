diff -Nru openjdk.orig/jdk/make/docs/CORE_PKGS.gmk openjdk/jdk/make/docs/CORE_PKGS.gmk
--- openjdk.orig/jdk/make/docs/CORE_PKGS.gmk	2009-02-05 08:44:13.000000000 +0000
+++ openjdk/jdk/make/docs/CORE_PKGS.gmk	2009-02-11 23:47:38.000000000 +0000
@@ -110,6 +110,9 @@
   java.nio.channels.spi                          \
   java.nio.charset                               \
   java.nio.charset.spi                           \
+  java.nio.file					 \
+  java.nio.file.attribute			 \
+  java.nio.file.spi				 \
   java.rmi                                       \
   java.rmi.activation                            \
   java.rmi.dgc                                   \
diff -Nru openjdk.orig/jdk/make/java/nio/FILES_java.gmk openjdk/jdk/make/java/nio/FILES_java.gmk
--- openjdk.orig/jdk/make/java/nio/FILES_java.gmk	2009-02-11 23:12:43.000000000 +0000
+++ openjdk/jdk/make/java/nio/FILES_java.gmk	2009-02-12 16:05:24.000000000 +0000
@@ -149,7 +149,150 @@
 	java/lang/StringCoding.java \
 	\
 	sun/misc/Cleaner.java \
-	sun/util/PreHashedMap.java
+	sun/util/PreHashedMap.java \
+	\
+	java/net/ProtocolFamily.java \
+	java/net/SocketOption.java \
+	java/net/StandardProtocolFamily.java \
+	java/net/StandardSocketOption.java \
+	java/nio/channels/AsynchronousByteChannel.java \
+	java/nio/channels/AsynchronousChannel.java \
+	java/nio/channels/AsynchronousChannelGroup.java \
+	java/nio/channels/AsynchronousDatagramChannel.java \
+	java/nio/channels/AsynchronousFileChannel.java \
+	java/nio/channels/AsynchronousServerSocketChannel.java \
+	java/nio/channels/AsynchronousSocketChannel.java \
+	java/nio/channels/Channels.java \
+	java/nio/channels/CompletionHandler.java \
+	java/nio/channels/DatagramChannel.java \
+	java/nio/channels/FileChannel.java \
+	java/nio/channels/FileLock.java \
+	java/nio/channels/MembershipKey.java \
+	java/nio/channels/MulticastChannel.java \
+	java/nio/channels/NetworkChannel.java \
+	java/nio/channels/SeekableByteChannel.java \
+	java/nio/channels/spi/AsynchronousChannelProvider.java \
+	java/nio/channels/spi/SelectorProvider.java \
+	java/nio/file/AccessDeniedException.java \
+	java/nio/file/AccessMode.java \
+	java/nio/file/AtomicMoveNotSupportedException.java \
+	java/nio/file/ClosedDirectoryStreamException.java \
+	java/nio/file/ClosedFileSystemException.java \
+	java/nio/file/ClosedWatchServiceException.java \
+	java/nio/file/CopyOption.java \
+	java/nio/file/DirectoryNotEmptyException.java \
+	java/nio/file/DirectoryStream.java \
+	java/nio/file/DirectoryStreamFilters.java \
+	java/nio/file/FileAction.java \
+	java/nio/file/FileAlreadyExistsException.java \
+	java/nio/file/FileRef.java \
+	java/nio/file/FileStore.java \
+	java/nio/file/FileSystem.java \
+	java/nio/file/FileSystemAlreadyExistsException.java \
+	java/nio/file/FileSystemException.java \
+	java/nio/file/FileSystemNotFoundException.java \
+	java/nio/file/FileSystems.java \
+	java/nio/file/FileTreeWalker.java \
+	java/nio/file/FileVisitOption.java \
+	java/nio/file/FileVisitResult.java \
+	java/nio/file/FileVisitor.java \
+	java/nio/file/Files.java \
+	java/nio/file/InvalidPathException.java \
+	java/nio/file/LinkPermission.java \
+	java/nio/file/NoSuchFileException.java \
+	java/nio/file/NotDirectoryException.java \
+	java/nio/file/NotLinkException.java \
+	java/nio/file/OpenOption.java \
+	java/nio/file/Path.java \
+	java/nio/file/PathMatcher.java \
+	java/nio/file/Paths.java \
+	java/nio/file/ProviderMismatchException.java \
+	java/nio/file/ProviderNotFoundException.java \
+	java/nio/file/ReadOnlyFileSystemException.java \
+	java/nio/file/SecureDirectoryStream.java \
+	java/nio/file/SimpleFileVisitor.java \
+	java/nio/file/StandardCopyOption.java \
+	java/nio/file/StandardOpenOption.java \
+	java/nio/file/StandardWatchEventKind.java \
+	java/nio/file/WatchEvent.java \
+	java/nio/file/WatchKey.java \
+	java/nio/file/WatchService.java \
+	java/nio/file/Watchable.java \
+	\
+	java/nio/file/attribute/AclEntry.java \
+	java/nio/file/attribute/AclEntryFlag.java \
+	java/nio/file/attribute/AclEntryPermission.java \
+	java/nio/file/attribute/AclEntryType.java \
+	java/nio/file/attribute/AclFileAttributeView.java \
+	java/nio/file/attribute/AttributeView.java \
+	java/nio/file/attribute/Attributes.java \
+	java/nio/file/attribute/BasicFileAttributeView.java \
+	java/nio/file/attribute/BasicFileAttributes.java \
+	java/nio/file/attribute/DosFileAttributeView.java \
+	java/nio/file/attribute/DosFileAttributes.java \
+	java/nio/file/attribute/FileAttribute.java \
+	java/nio/file/attribute/FileAttributeView.java \
+	java/nio/file/attribute/FileOwnerAttributeView.java \
+	java/nio/file/attribute/FileStoreAttributeView.java \
+	java/nio/file/attribute/FileStoreSpaceAttributeView.java \
+	java/nio/file/attribute/FileStoreSpaceAttributes.java \
+	java/nio/file/attribute/GroupPrincipal.java \
+	java/nio/file/attribute/NamedAttributeView.java \
+	java/nio/file/attribute/PosixFileAttributeView.java \
+	java/nio/file/attribute/PosixFileAttributes.java \
+	java/nio/file/attribute/PosixFilePermission.java \
+	java/nio/file/attribute/PosixFilePermissions.java \
+	java/nio/file/attribute/UserPrincipal.java \
+	java/nio/file/attribute/UserPrincipalLookupService.java \
+	java/nio/file/attribute/UserPrincipalNotFoundException.java \
+	\
+	java/nio/file/spi/AbstractPath.java \
+	java/nio/file/spi/FileSystemProvider.java \
+	java/nio/file/spi/FileTypeDetector.java \
+	\
+	java/util/concurrent/ScheduledThreadPoolExecutor.java \
+	\
+	misc/JavaUtilConcurrentThreadPoolExecutorAccess.java \
+	misc/JavaNetGetIndexAccess.java \
+	\
+	com/sun/nio/file/ExtendedCopyOption.java \
+	com/sun/nio/file/ExtendedOpenOption.java \
+	com/sun/nio/file/ExtendedWatchEventModifier.java \
+	\
+	sun/nio/ch/AbstractFuture.java \
+	sun/nio/ch/AsynchronousChannelGroupImpl.java \
+	sun/nio/ch/AsynchronousFileChannelImpl.java \
+	sun/nio/ch/AsynchronousServerSocketChannelImpl.java \
+	sun/nio/ch/AsynchronousSocketChannelImpl.java \
+	sun/nio/ch/Cancellable.java \
+	sun/nio/ch/CompletedFuture.java \
+	sun/nio/ch/DefaultAsynchronousChannelProvider.java \
+	sun/nio/ch/FileDispatcher.java \
+	sun/nio/ch/FileLockImpl.java \
+	sun/nio/ch/FileLockTable.java \
+	sun/nio/ch/Groupable.java \
+	sun/nio/ch/Invoker.java \
+	sun/nio/ch/PendingFuture.java \
+	sun/nio/ch/SimpleAsynchronousDatagramChannelImpl.java \
+	sun/nio/ch/ThreadPool.java \
+	\
+	sun/nio/fs/AbstractAclFileAttributeView.java \
+	sun/nio/fs/AbstractBasicFileAttributeView.java \
+	sun/nio/fs/AbstractFileStoreSpaceAttributeView.java \
+	sun/nio/fs/AbstractFileTypeDetector.java \
+	sun/nio/fs/AbstractPoller.java \
+	sun/nio/fs/AbstractNamedAttributeView.java \
+	sun/nio/fs/AbstractWatchKey.java \
+	sun/nio/fs/AbstractWatchService.java \
+	sun/nio/fs/Cancellable.java \
+	sun/nio/fs/DefaultFileSystemProvider.java \
+	sun/nio/fs/DefaultFileTypeDetector.java \
+	sun/nio/fs/FileOwnerAttributeViewImpl.java \
+	sun/nio/fs/Globs.java \
+	sun/nio/fs/MimeType.java \
+	sun/nio/fs/NativeBuffer.java \
+	sun/nio/fs/NativeBuffers.java \
+	sun/nio/fs/Reflect.java \
 
 # Generated coder classes
 #
@@ -267,7 +410,14 @@
 	\
 	java/nio/charset/CharacterCodingException.java \
 	java/nio/charset/IllegalCharsetNameException.java \
-	java/nio/charset/UnsupportedCharsetException.java
+	java/nio/charset/UnsupportedCharsetException.java \
+	\ 
+	java/nio/channels/AcceptPendingException.java \
+	java/nio/channels/IllegalChannelGroupException.java \
+	java/nio/channels/InterruptedByTimeoutException.java \
+	java/nio/channels/ReadPendingException.java \
+	java/nio/channels/ShutdownChannelGroupException.java \
+	java/nio/channels/WritePendingException.java 
 
 FILES_gen_sbcs = \
 	sun/nio/cs/ISO_8859_2.java \
diff -Nru openjdk.orig/jdk/make/java/nio/Makefile openjdk/jdk/make/java/nio/Makefile
--- openjdk.orig/jdk/make/java/nio/Makefile	2009-02-11 23:12:43.000000000 +0000
+++ openjdk/jdk/make/java/nio/Makefile	2009-02-11 23:35:40.000000000 +0000
@@ -40,6 +40,11 @@
 SNIO_SRC = $(SHARE_SRC)/classes/sun/nio
 SNIO_GEN = $(GENSRCDIR)/sun/nio
 
+INIO_SRC = $(SHARE_SRC)/classes/org/classpath/icedtea/java/nio
+INIO_GEN = $(GENSRCDIR)/org/classpath/icedtea/java/nio
+
+SERVICES = $(CLASSBINDIR)/META-INF/services
+
 #
 # Files to compile
 #
@@ -56,30 +61,128 @@
         sun/nio/ch/DevPollSelectorProvider.java \
 	sun/nio/ch/InheritedChannel.java \
         sun/nio/ch/PollSelectorProvider.java \
-        sun/nio/ch/PollSelectorImpl.java
+        sun/nio/ch/PollSelectorImpl.java \
+	sun/nio/ch/Port.java \
+	sun/nio/ch/SimpleAsynchronousFileChannelImpl.java \
+	sun/nio/ch/SolarisAsynchronousChannelProvider.java \
+	sun/nio/ch/SolarisEventPort.java \
+	sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java \
+	sun/nio/ch/UnixAsynchronousSocketChannelImpl.java \
+	\
+	sun/nio/fs/GnomeFileTypeDetector.java \
+	sun/nio/fs/PollingWatchService.java \
+	sun/nio/fs/SolarisAclFileAttributeView.java \
+	sun/nio/fs/SolarisFileStore.java \
+	sun/nio/fs/SolarisFileSystem.java \
+	sun/nio/fs/SolarisFileSystemProvider.java \
+	sun/nio/fs/SolarisNamedAttributeView.java \
+	sun/nio/fs/SolarisNativeDispatcher.java \
+	sun/nio/fs/SolarisWatchService.java \
+	sun/nio/fs/UnixChannelFactory.java \
+	sun/nio/fs/UnixCopyFile.java \
+	sun/nio/fs/UnixDirectoryStream.java \
+	sun/nio/fs/UnixException.java \
+	sun/nio/fs/UnixFileAttributeViews.java \
+	sun/nio/fs/UnixFileAttributes.java \
+	sun/nio/fs/UnixFileKey.java \
+	sun/nio/fs/UnixFileModeAttribute.java \
+	sun/nio/fs/UnixFileStore.java \
+	sun/nio/fs/UnixFileStoreAttributes.java \
+	sun/nio/fs/UnixFileSystem.java \
+	sun/nio/fs/UnixFileSystemProvider.java \
+	sun/nio/fs/UnixMountEntry.java \
+	sun/nio/fs/UnixNativeDispatcher.java \
+	sun/nio/fs/UnixPath.java \
+	sun/nio/fs/UnixSecureDirectoryStream.java \
+	sun/nio/fs/UnixUriUtils.java \
+	sun/nio/fs/UnixUserPrincipals.java
 
 FILES_c += \
         DevPollArrayWrapper.c \
 	InheritedChannel.c \
 	NativeThread.c \
-        PollArrayWrapper.c
+        PollArrayWrapper.c \
+	SolarisEventPort.c \
+	UnixAsynchronousServerSocketChannelImpl.c \
+	UnixAsynchronousSocketChannelImpl.c \
+	\
+	GnomeFileTypeDetector.c \
+	SolarisNativeDispatcher.c \
+	SolarisWatchService.c \
+	UnixCopyFile.c \
+	UnixNativeDispatcher.c
 
 FILES_export += \
 	sun/nio/ch/DevPollArrayWrapper.java \
 	sun/nio/ch/InheritedChannel.java \
-	sun/nio/ch/NativeThread.java
+	sun/nio/ch/NativeThread.java \
+	sun/nio/ch/SolarisEventPort.java \
+	sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java \
+	sun/nio/ch/UnixAsynchronousSocketChannelImpl.java \
+	\
+	sun/nio/fs/GnomeFileTypeDetector.java \
+	sun/nio/fs/SolarisNativeDispatcher.java \
+	sun/nio/fs/SolarisWatchService.java \
+	sun/nio/fs/UnixCopyFile.java \
+	sun/nio/fs/UnixNativeDispatcher.java
+
+FILES_gen += \
+	sun/nio/fs/SolarisConstants.java \
+	sun/nio/fs/UnixConstants.java
 endif # PLATFORM = solaris
 
 ifeq ($(PLATFORM), windows)
 FILES_java += \
+	sun/nio/ch/Iocp.java \
+	sun/nio/ch/PendingIoCache.java \
+	sun/nio/ch/WindowsAsynchronousChannelProvider.java \
+	sun/nio/ch/WindowsAsynchronousFileChannelImpl.java \
+	sun/nio/ch/WindowsAsynchronousServerSocketChannelImpl.java \
+	sun/nio/ch/WindowsAsynchronousSocketChannelImpl.java \
         sun/nio/ch/WindowsSelectorImpl.java \
-        sun/nio/ch/WindowsSelectorProvider.java
+        sun/nio/ch/WindowsSelectorProvider.java \
+	\
+	sun/nio/fs/RegistryFileTypeDetector.java \
+	sun/nio/fs/WindowsAclFileAttributeView.java \
+	sun/nio/fs/WindowsChannelFactory.java \
+	sun/nio/fs/WindowsConstants.java \
+	sun/nio/fs/WindowsDirectoryStream.java \
+	sun/nio/fs/WindowsException.java \
+	sun/nio/fs/WindowsFileAttributeViews.java \
+	sun/nio/fs/WindowsFileAttributes.java \
+	sun/nio/fs/WindowsFileCopy.java \
+	sun/nio/fs/WindowsFileStore.java \
+	sun/nio/fs/WindowsFileSystem.java \
+	sun/nio/fs/WindowsFileSystemProvider.java \
+	sun/nio/fs/WindowsLinkSupport.java \
+	sun/nio/fs/WindowsNamedAttributeView.java \
+	sun/nio/fs/WindowsNativeDispatcher.java \
+	sun/nio/fs/WindowsPath.java \
+	sun/nio/fs/WindowsPathParser.java \
+	sun/nio/fs/WindowsPathType.java \
+	sun/nio/fs/WindowsSecurity.java \
+	sun/nio/fs/WindowsSecurityDescriptor.java \
+	sun/nio/fs/WindowsUriSupport.java \
+	sun/nio/fs/WindowsUserPrincipals.java \
+	sun/nio/fs/WindowsWatchService.java
 
 FILES_c += \
+	Iocp.c \
+	RegistryFileTypeDetector.c \
+	WindowsAsynchronousFileChannelImpl.c \
+	WindowsAsynchronousServerSocketChannelImpl.c \
+	WindowsAsynchronousSocketChannelImpl.c \
+	WindowsNativeDispatcher.c \
         WindowsSelectorImpl.c
 
 FILES_export += \
+	sun/nio/ch/Iocp.java \
+	sun/nio/ch/WindowsAsynchronousFileChannelImpl.java \
+	sun/nio/ch/WindowsAsynchronousServerSocketChannelImpl.java \
+	sun/nio/ch/WindowsAsynchronousSocketChannelImpl.java \
 	sun/nio/ch/WindowsSelectorImpl.java
+	sun/nio/fs/WindowsNativeDispatcher.java \
+	sun/nio/fs/RegistryFileTypeDetector.java
 endif # PLATFORM = windows
 
 ifeq ($(PLATFORM), linux)
@@ -89,27 +192,83 @@
 	sun/nio/ch/DevPollSelectorImpl.java \
 	sun/nio/ch/DevPollSelectorProvider.java \
 	sun/nio/ch/EPollArrayWrapper.java \
+	sun/nio/ch/EPollPort.java \
 	sun/nio/ch/EPollSelectorProvider.java \
 	sun/nio/ch/EPollSelectorImpl.java \
 	sun/nio/ch/InheritedChannel.java \
+	sun/nio/ch/LinuxAsynchronousChannelProvider.java \
         sun/nio/ch/PollSelectorProvider.java \
-        sun/nio/ch/PollSelectorImpl.java
+        sun/nio/ch/PollSelectorImpl.java \
+	sun/nio/ch/Port.java \
+	sun/nio/ch/SimpleAsynchronousFileChannelImpl.java \
+	sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java \
+	sun/nio/ch/UnixAsynchronousSocketChannelImpl.java \
+	\
+	sun/nio/fs/GnomeFileTypeDetector.java \
+	sun/nio/fs/LinuxDosFileAttributeView.java \
+	sun/nio/fs/LinuxFileStore.java \
+	sun/nio/fs/LinuxFileSystem.java \
+	sun/nio/fs/LinuxFileSystemProvider.java \
+	sun/nio/fs/LinuxNamedAttributeView.java \
+	sun/nio/fs/LinuxNativeDispatcher.java \
+	sun/nio/fs/LinuxWatchService.java \
+	sun/nio/fs/PollingWatchService.java \
+	sun/nio/fs/UnixChannelFactory.java \
+	sun/nio/fs/UnixCopyFile.java \
+	sun/nio/fs/UnixDirectoryStream.java \
+	sun/nio/fs/UnixException.java \
+	sun/nio/fs/UnixFileAttributeViews.java \
+	sun/nio/fs/UnixFileAttributes.java \
+	sun/nio/fs/UnixFileKey.java \
+	sun/nio/fs/UnixFileModeAttribute.java \
+	sun/nio/fs/UnixFileStore.java \
+	sun/nio/fs/UnixFileStoreAttributes.java \
+	sun/nio/fs/UnixFileSystem.java \
+	sun/nio/fs/UnixFileSystemProvider.java \
+	sun/nio/fs/UnixMountEntry.java \
+	sun/nio/fs/UnixNativeDispatcher.java \
+	sun/nio/fs/UnixPath.java \
+	sun/nio/fs/UnixSecureDirectoryStream.java \
+	sun/nio/fs/UnixUriUtils.java \
+	sun/nio/fs/UnixUserPrincipals.java
 
 FILES_c += \
 	EPollArrayWrapper.c \
+	EPollPort.c \
 	InheritedChannel.c \
 	NativeThread.c \
-        PollArrayWrapper.c
+        PollArrayWrapper.c \
+	UnixAsynchronousServerSocketChannelImpl.c \
+	UnixAsynchronousSocketChannelImpl.c \
+	\
+	GnomeFileTypeDetector.c \
+	LinuxNativeDispatcher.c \
+	LinuxWatchService.c \
+	UnixCopyFile.c \
+	UnixNativeDispatcher.c
 
 FILES_export += \
 	sun/nio/ch/DevPollArrayWrapper.java \
         sun/nio/ch/EPollArrayWrapper.java \
+	sun/nio/ch/EPollPort.java \
 	sun/nio/ch/InheritedChannel.java \
-	sun/nio/ch/NativeThread.java
+	sun/nio/ch/NativeThread.java \
+	sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java \
+	sun/nio/ch/UnixAsynchronousSocketChannelImpl.java \
+	\
+	sun/nio/fs/GnomeFileTypeDetector.java \
+	sun/nio/fs/LinuxNativeDispatcher.java \
+	sun/nio/fs/LinuxWatchService.java \
+	sun/nio/fs/UnixCopyFile.java \
+	sun/nio/fs/UnixNativeDispatcher.java
+
+FILES_gen += \
+	sun/nio/fs/UnixConstants.java
 endif # PLATFORM = linux
 
 # Find platform-specific C source files
 #
+vpath %.c $(PLATFORM_SRC)/native/sun/nio/fs
 vpath %.c $(PLATFORM_SRC)/native/sun/nio/ch
 vpath %.c $(SHARE_SRC)/native/sun/nio/ch
 
@@ -152,7 +311,7 @@
 build: sources
 
 clean clobber::
-	$(RM) -r $(NIO_GEN) $(SNIO_GEN)
+	$(RM) -r $(NIO_GEN) $(SNIO_GEN) $(INIO_GEN)
 	$(RM) -r $(CLASSDESTDIR)/java/nio
 	$(RM) -r $(CLASSDESTDIR)/sun/nio
 
@@ -179,12 +338,16 @@
 CS_SRC=$(NIO_SRC)/charset
 SCH_SRC=$(SNIO_SRC)/ch
 SCS_SRC=$(SNIO_SRC)/cs
+SFS_SRC=$(SNIO_SRC)/fs
+ICH_SRC=$(INIO_SRC)/channels
 
 BUF_GEN=$(NIO_GEN)
 CH_GEN=$(NIO_GEN)/channels
 CS_GEN=$(NIO_GEN)/charset
 SCH_GEN=$(SNIO_GEN)/ch
 SCS_GEN=$(SNIO_GEN)/cs
+SFS_GEN=$(SNIO_GEN)/fs
+ICH_GEN=$(INIO_GEN)/channels
 
 FILES_gensbcs_out = $(FILES_gen_sbcs:%.java=$(GENSRCDIR)/%.java)
 
@@ -624,6 +787,11 @@
 	@$(RM) $@.temp
 	$(GEN_EX_CMD) $(BUF_SRC)/exceptions $(BUF_GEN)
 
+$(ICH_GEN)/%Exception.java: genExceptions.sh $(ICH_SRC)/exceptions
+	$(prep-target)
+	@$(RM) $@.temp
+	$(GEN_EX_CMD) $(ICH_SRC)/exceptions $(ICH_GEN)
+
 #
 # Generated charset-provider classes
 #
@@ -674,4 +842,48 @@
 	$(BOOT_JAVA_CMD) -cp $(CHARSETMAPPING_JARFILE) build.tools.charsetmapping.GenerateSBCS \
 		$(GENCSSRC) $(SCS_GEN) sbcs
 
+# 
+# Generated file system implementation classes (Unix only)
+#
+
+GENUC_SRC = $(PLATFORM_SRC)/native/sun/nio/fs/genUnixConstants.c
+
+GENUC_EXE = $(TEMPDIR)/genUnixConstants
+
+GENUC_COPYRIGHT_YEARS = $(shell $(CAT) $(GENUC_SRC) | \
+	$(NAWK) '/^.*Copyright.*Sun/ { print $$3 }')
+
+$(GENUC_EXE) : $(GENUC_SRC)
+	$(prep-target)
+	$(CC) $(CPPFLAGS) -o $@ $(GENUC_SRC)
+
+$(SFS_GEN)/UnixConstants.java: $(GENUC_EXE)
+	$(prep-target)
+	NAWK="$(NAWK)" SH="$(SH)" $(SH) -e addNotices.sh $(GENUC_COPYRIGHT_YEARS) > $@
+	$(GENUC_EXE) >> $@
+
+GENSC_SRC = $(PLATFORM_SRC)/native/sun/nio/fs/genSolarisConstants.c
+
+GENSC_EXE = $(TEMPDIR)/genSolarisConstants
+
+GENSC_COPYRIGHT_YEARS = $(shell $(CAT) $(GENSC_SRC) | \
+	$(NAWK) '/^.*Copyright.*Sun/ { print $$3 }')
+
+$(GENSC_EXE) : $(GENSC_SRC)
+	$(prep-target)
+	$(CC) $(CPPFLAGS) -o $@ $(GENSC_SRC)
+
+$(SFS_GEN)/SolarisConstants.java: $(GENSC_EXE)
+	$(prep-target)
+	NAWK="$(NAWK)" SH="$(SH)" $(SH) -e addNotices.sh $(GENSC_COPYRIGHT_YEARS) > $@
+	$(GENSC_EXE) >> $@
+
+#
+# Files to copy
+#
+
+$(SERVICES)/%: $(PLATFORM_SRC)/classes/sun/nio/fs/META-INF/services/%
+	$(install-file)
+
+
 .PHONY: sources 
diff -Nru openjdk.orig/jdk/make/java/nio/mapfile-linux openjdk/jdk/make/java/nio/mapfile-linux
--- openjdk.orig/jdk/make/java/nio/mapfile-linux	2009-02-05 08:44:13.000000000 +0000
+++ openjdk/jdk/make/java/nio/mapfile-linux	2009-02-11 23:39:12.000000000 +0000
@@ -44,6 +44,14 @@
 		Java_sun_nio_ch_EPollArrayWrapper_interrupt;
 		Java_sun_nio_ch_EPollArrayWrapper_offsetofData;
 		Java_sun_nio_ch_EPollArrayWrapper_sizeofEPollEvent;
+		Java_sun_nio_ch_EPollPort_init;
+		Java_sun_nio_ch_EPollPort_close0;
+		Java_sun_nio_ch_EPollPort_epollCreate;
+		Java_sun_nio_ch_EPollPort_epollCtl;
+		Java_sun_nio_ch_EPollPort_epollWait;
+		Java_sun_nio_ch_EPollPort_drain1;
+		Java_sun_nio_ch_EPollPort_interrupt;
+		Java_sun_nio_ch_EPollPort_socketpair;
                 Java_sun_nio_ch_FileChannelImpl_close0;
                 Java_sun_nio_ch_FileChannelImpl_force0;
                 Java_sun_nio_ch_FileChannelImpl_initIDs;
@@ -108,6 +116,74 @@
                 Java_sun_nio_ch_ServerSocketChannelImpl_accept0;
                 Java_sun_nio_ch_ServerSocketChannelImpl_initIDs;
                 Java_sun_nio_ch_SocketChannelImpl_checkConnect;
+		Java_sun_nio_ch_UnixAsynchronousServerSocketChannelImpl_accept0;
+		Java_sun_nio_ch_UnixAsynchronousServerSocketChannelImpl_initIDs;
+		Java_sun_nio_ch_UnixAsynchronousSocketChannelImpl_checkConnect;
+		Java_sun_nio_fs_GnomeFileTypeDetector_initializeGio;
+		Java_sun_nio_fs_GnomeFileTypeDetector_probeUsingGio;
+		Java_sun_nio_fs_GnomeFileTypeDetector_initializeGnomeVfs;
+		Java_sun_nio_fs_GnomeFileTypeDetector_probeUsingGnomeVfs;
+		Java_sun_nio_fs_LinuxWatchService_init;
+		Java_sun_nio_fs_LinuxWatchService_inotifyInit;
+		Java_sun_nio_fs_LinuxWatchService_inotifyAddWatch;
+		Java_sun_nio_fs_LinuxWatchService_inotifyRmWatch;
+		Java_sun_nio_fs_LinuxWatchService_configureBlocking;
+		Java_sun_nio_fs_LinuxWatchService_socketpair;
+		Java_sun_nio_fs_LinuxWatchService_poll;
+		Java_sun_nio_fs_LinuxNativeDispatcher_init;
+		Java_sun_nio_fs_LinuxNativeDispatcher_fgetxattr0;
+		Java_sun_nio_fs_LinuxNativeDispatcher_flistxattr;
+		Java_sun_nio_fs_LinuxNativeDispatcher_fsetxattr0;
+		Java_sun_nio_fs_LinuxNativeDispatcher_fremovexattr0;
+		Java_sun_nio_fs_LinuxNativeDispatcher_setmntent0;
+		Java_sun_nio_fs_LinuxNativeDispatcher_endmntent;
+		Java_sun_nio_fs_UnixNativeDispatcher_initIDs;
+		Java_sun_nio_fs_UnixNativeDispatcher_getcwd;
+		Java_sun_nio_fs_UnixNativeDispatcher_strerror;
+		Java_sun_nio_fs_UnixNativeDispatcher_dup;
+		Java_sun_nio_fs_UnixNativeDispatcher_access0;
+		Java_sun_nio_fs_UnixNativeDispatcher_stat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_lstat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fstat;
+		Java_sun_nio_fs_UnixNativeDispatcher_fstatat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_chmod0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fchmod;
+		Java_sun_nio_fs_UnixNativeDispatcher_chown0;
+		Java_sun_nio_fs_UnixNativeDispatcher_lchown0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fchown;
+		Java_sun_nio_fs_UnixNativeDispatcher_utimes0;
+		Java_sun_nio_fs_UnixNativeDispatcher_futimes;
+		Java_sun_nio_fs_UnixNativeDispatcher_open0;
+		Java_sun_nio_fs_UnixNativeDispatcher_openat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_close;
+		Java_sun_nio_fs_UnixNativeDispatcher_read;
+		Java_sun_nio_fs_UnixNativeDispatcher_write;
+		Java_sun_nio_fs_UnixNativeDispatcher_fopen0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fclose;
+		Java_sun_nio_fs_UnixNativeDispatcher_opendir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fdopendir;
+		Java_sun_nio_fs_UnixNativeDispatcher_readdir;
+		Java_sun_nio_fs_UnixNativeDispatcher_closedir;
+		Java_sun_nio_fs_UnixNativeDispatcher_link0;
+		Java_sun_nio_fs_UnixNativeDispatcher_unlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_unlinkat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_rename0;
+		Java_sun_nio_fs_UnixNativeDispatcher_renameat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_mkdir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_rmdir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_symlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_readlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_realpath0;
+		Java_sun_nio_fs_UnixNativeDispatcher_statvfs0;
+		Java_sun_nio_fs_UnixNativeDispatcher_pathconf0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fpathconf;
+		Java_sun_nio_fs_UnixNativeDispatcher_mknod0;
+		Java_sun_nio_fs_UnixNativeDispatcher_getpwuid;
+		Java_sun_nio_fs_UnixNativeDispatcher_getgrgid;
+		Java_sun_nio_fs_UnixNativeDispatcher_getpwnam0;
+		Java_sun_nio_fs_UnixNativeDispatcher_getgrnam0;
+		Java_sun_nio_fs_UnixNativeDispatcher_getextmntent;
+		Java_sun_nio_fs_UnixCopyFile_transfer;
 
 	local:
 		*;
diff -Nru openjdk.orig/jdk/make/java/nio/mapfile-solaris openjdk/jdk/make/java/nio/mapfile-solaris
--- openjdk.orig/jdk/make/java/nio/mapfile-solaris	2009-02-05 08:44:13.000000000 +0000
+++ openjdk/jdk/make/java/nio/mapfile-solaris	2009-02-11 23:38:28.000000000 +0000
@@ -106,6 +106,75 @@
                 Java_sun_nio_ch_ServerSocketChannelImpl_accept0;
                 Java_sun_nio_ch_ServerSocketChannelImpl_initIDs;
                 Java_sun_nio_ch_SocketChannelImpl_checkConnect;
+		Java_sun_nio_ch_UnixAsynchronousServerSocketChannelImpl_accept0;
+		Java_sun_nio_ch_UnixAsynchronousServerSocketChannelImpl_initIDs;
+		Java_sun_nio_ch_UnixAsynchronousSocketChannelImpl_checkConnect;
+		Java_sun_nio_ch_SolarisEventPort_init;
+		Java_sun_nio_ch_SolarisEventPort_portCreate;
+		Java_sun_nio_ch_SolarisEventPort_portClose;
+		Java_sun_nio_ch_SolarisEventPort_portAssociate;
+		Java_sun_nio_ch_SolarisEventPort_portGet;
+		Java_sun_nio_ch_SolarisEventPort_portGetn;
+		Java_sun_nio_ch_SolarisEventPort_portSend;
+		Java_sun_nio_fs_GnomeFileTypeDetector_initializeGio;
+		Java_sun_nio_fs_GnomeFileTypeDetector_probeUsingGio;
+		Java_sun_nio_fs_GnomeFileTypeDetector_initializeGnomeVfs;
+		Java_sun_nio_fs_GnomeFileTypeDetector_probeUsingGnomeVfs;
+		Java_sun_nio_fs_UnixNativeDispatcher_initIDs;
+		Java_sun_nio_fs_UnixNativeDispatcher_getcwd;
+		Java_sun_nio_fs_UnixNativeDispatcher_strerror;
+		Java_sun_nio_fs_UnixNativeDispatcher_dup;
+		Java_sun_nio_fs_UnixNativeDispatcher_access0;
+		Java_sun_nio_fs_UnixNativeDispatcher_stat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_lstat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fstat;
+		Java_sun_nio_fs_UnixNativeDispatcher_fstatat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_chmod0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fchmod;
+		Java_sun_nio_fs_UnixNativeDispatcher_chown0;
+		Java_sun_nio_fs_UnixNativeDispatcher_lchown0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fchown;
+		Java_sun_nio_fs_UnixNativeDispatcher_utimes0;
+		Java_sun_nio_fs_UnixNativeDispatcher_futimes;
+		Java_sun_nio_fs_UnixNativeDispatcher_open0;
+		Java_sun_nio_fs_UnixNativeDispatcher_openat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_close;
+		Java_sun_nio_fs_UnixNativeDispatcher_read;
+		Java_sun_nio_fs_UnixNativeDispatcher_write;
+		Java_sun_nio_fs_UnixNativeDispatcher_fopen0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fclose;
+		Java_sun_nio_fs_UnixNativeDispatcher_opendir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fdopendir;
+		Java_sun_nio_fs_UnixNativeDispatcher_readdir;
+		Java_sun_nio_fs_UnixNativeDispatcher_closedir;
+		Java_sun_nio_fs_UnixNativeDispatcher_link0;
+		Java_sun_nio_fs_UnixNativeDispatcher_unlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_unlinkat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_rename0;
+		Java_sun_nio_fs_UnixNativeDispatcher_renameat0;
+		Java_sun_nio_fs_UnixNativeDispatcher_mkdir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_rmdir0;
+		Java_sun_nio_fs_UnixNativeDispatcher_symlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_readlink0;
+		Java_sun_nio_fs_UnixNativeDispatcher_realpath0;
+		Java_sun_nio_fs_UnixNativeDispatcher_statvfs0;
+		Java_sun_nio_fs_UnixNativeDispatcher_pathconf0;
+		Java_sun_nio_fs_UnixNativeDispatcher_fpathconf;
+		Java_sun_nio_fs_UnixNativeDispatcher_mknod0;
+		Java_sun_nio_fs_UnixNativeDispatcher_getpwuid;
+		Java_sun_nio_fs_UnixNativeDispatcher_getgrgid;
+		Java_sun_nio_fs_UnixNativeDispatcher_getpwnam0;
+		Java_sun_nio_fs_UnixNativeDispatcher_getgrnam0;
+		Java_sun_nio_fs_UnixNativeDispatcher_getextmntent;
+		Java_sun_nio_fs_UnixCopyFile_transfer;
+		Java_sun_nio_fs_SolarisNativeDispatcher_init;
+		Java_sun_nio_fs_SolarisNativeDispatcher_facl;
+		Java_sun_nio_fs_SolarisWatchService_init;
+ 		Java_sun_nio_fs_SolarisWatchService_portCreate;
+		Java_sun_nio_fs_SolarisWatchService_portAssociate;
+		Java_sun_nio_fs_SolarisWatchService_portDissociate;
+		Java_sun_nio_fs_SolarisWatchService_portSend;
+		Java_sun_nio_fs_SolarisWatchService_portGetn;
 
 	local:
 		*;
diff -Nru openjdk.orig/jdk/make/mkdemo/Makefile openjdk/jdk/make/mkdemo/Makefile
--- openjdk.orig/jdk/make/mkdemo/Makefile	2009-02-05 08:44:13.000000000 +0000
+++ openjdk/jdk/make/mkdemo/Makefile	2009-02-11 23:14:46.000000000 +0000
@@ -31,7 +31,7 @@
 PRODUCT = demos
 include $(BUILDDIR)/common/Defs.gmk
 
-SUBDIRS = applets jfc jvmti management jni scripting jpda
+SUBDIRS = applets jfc jvmti management jni scripting jpda nio
 
 all build:: nbproject
 	$(SUBDIRS-loop)
diff -Nru openjdk.orig/jdk/make/mksample/nio/Makefile openjdk/jdk/make/mksample/nio/Makefile
--- openjdk.orig/jdk/make/mksample/nio/Makefile	2009-02-05 08:44:13.000000000 +0000
+++ openjdk/jdk/make/mksample/nio/Makefile	2009-02-11 23:42:20.000000000 +0000
@@ -31,7 +31,7 @@
 PRODUCT = java
 include $(BUILDDIR)/common/Defs.gmk
 
-SUBDIRS = multicast server
+SUBDIRS = aio file multicast server
 all build clean clobber::
 	$(SUBDIRS-loop)
 
diff -Nru openjdk.orig/jdk/src/share/classes/sun/nio/ch/DatagramChannelImpl.java openjdk/jdk/src/share/classes/sun/nio/ch/DatagramChannelImpl.java
--- openjdk.orig/jdk/src/share/classes/sun/nio/ch/DatagramChannelImpl.java	2009-02-11 23:11:27.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/nio/ch/DatagramChannelImpl.java	2009-02-11 23:14:46.000000000 +0000
@@ -56,6 +56,9 @@
     // The protocol family of the socket
     private final ProtocolFamily family;
 
+    // The protocol family of the socket
+    private final ProtocolFamily family;
+
     // IDs of native threads doing reads and writes, for signalling
     private volatile long readerThread = 0;
     private volatile long writerThread = 0;
@@ -94,6 +97,9 @@
     // Multicast support
     private MembershipRegistry registry;
 
+    // Multicast support
+    private MembershipRegistry registry;
+
     // -- End of fields protected by stateLock
 
 
@@ -532,6 +538,7 @@
                 assert IOStatus.check(n);
             }
         }
+	return this;
     }
 
     private long read0(ByteBuffer[] bufs) throws IOException {
@@ -1079,4 +1086,350 @@
         initIDs();
     }
 
+    public SocketAddress getRemoteAddress() throws IOException {
+        synchronized (stateLock) {
+            if (!isOpen())
+                throw new ClosedChannelException();
+            return remoteAddress;
+        }
+    }
+
+    public SocketAddress getLocalAddress() throws IOException {
+        synchronized (stateLock) {
+            if (!isOpen())
+                throw new ClosedChannelException();
+            return localAddress;
+        }
+    }
+
+    public <T> DatagramChannel setOption(SocketOption<T> name, T value)
+        throws IOException
+    {
+        if (name == null)
+            throw new NullPointerException();
+        if (!supportedOptions().contains(name))
+            throw new UnsupportedOperationException("'" + name + "' not supported");
+
+        synchronized (stateLock) {
+            ensureOpen();
+
+            if (name == StandardSocketOption.IP_TOS) {
+                // IPv4 only; no-op for IPv6
+                if (family == StandardProtocolFamily.INET) {
+                    Net.setSocketOption(fd, family, name, value);
+                }
+                return this;
+            }
+
+            if (name == StandardSocketOption.IP_MULTICAST_TTL ||
+                name == StandardSocketOption.IP_MULTICAST_LOOP)
+            {
+                // options are protocol dependent
+                Net.setSocketOption(fd, family, name, value);
+                return this;
+            }
+
+            if (name == StandardSocketOption.IP_MULTICAST_IF) {
+                if (value == null)
+                    throw new IllegalArgumentException("Cannot set IP_MULTICAST_IF to 'null'");
+                NetworkInterface interf = (NetworkInterface)value;
+                if (family == StandardProtocolFamily.INET6) {
+		    int index = SharedSecrets.getJavaNetGetIndexAccess().getIndex(interf);
+                    if (index == -1)
+                        throw new IOException("Network interface cannot be identified");
+                    Net.setInterface6(fd, index);
+                } else {
+                    // need IPv4 address to identify interface
+                    Inet4Address target = Net.anyInet4Address(interf);
+                    if (target == null)
+                        throw new IOException("Network interface not configured for IPv4");
+                    int targetAddress = Net.inet4AsInt(target);
+                    Net.setInterface4(fd, targetAddress);
+                }
+                return this;
+            }
+
+            // remaining options don't need any special handling
+            Net.setSocketOption(fd, Net.UNSPEC, name, value);
+            return this;
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    public <T> T getOption(SocketOption<T> name)
+        throws IOException
+    {
+        if (name == null)
+            throw new NullPointerException();
+        if (!supportedOptions().contains(name))
+            throw new UnsupportedOperationException("'" + name + "' not supported");
+
+        synchronized (stateLock) {
+            ensureOpen();
+
+            if (name == StandardSocketOption.IP_TOS) {
+                // IPv4 only; always return 0 on IPv6
+                if (family == StandardProtocolFamily.INET) {
+                    return (T) Net.getSocketOption(fd, family, name);
+                } else {
+                    return (T) Integer.valueOf(0);
+                }
+            }
+
+            if (name == StandardSocketOption.IP_MULTICAST_TTL ||
+                name == StandardSocketOption.IP_MULTICAST_LOOP)
+            {
+                return (T) Net.getSocketOption(fd, family, name);
+            }
+
+            if (name == StandardSocketOption.IP_MULTICAST_IF) {
+                if (family == StandardProtocolFamily.INET) {
+                    int address = Net.getInterface4(fd);
+                    if (address == 0)
+                        return null;    // default interface
+
+                    InetAddress ia = Net.inet4FromInt(address);
+                    NetworkInterface ni = NetworkInterface.getByInetAddress(ia);
+                    if (ni == null)
+                        throw new IOException("Unable to map address to interface");
+                    return (T) ni;
+                } else {
+                    int index = Net.getInterface6(fd);
+                    if (index == 0)
+                        return null;    // default interface
+
+                    NetworkInterface ni = SharedSecrets.getJavaNetGetIndexAccess().getByIndex(index);
+                    if (ni == null)
+                        throw new IOException("Unable to map index to interface");
+                    return (T) ni;
+                }
+            }
+
+            // no special handling
+            return (T) Net.getSocketOption(fd, Net.UNSPEC, name);
+        }
+    }
+
+    private static class LazyInitialization {
+        static final Set<SocketOption<?>> defaultOptions = defaultOptions();
+
+        private static Set<SocketOption<?>> defaultOptions() {
+            HashSet<SocketOption<?>> set = new HashSet<SocketOption<?>>(8);
+            set.add(StandardSocketOption.SO_SNDBUF);
+            set.add(StandardSocketOption.SO_RCVBUF);
+            set.add(StandardSocketOption.SO_REUSEADDR);
+            set.add(StandardSocketOption.SO_BROADCAST);
+            set.add(StandardSocketOption.IP_TOS);
+            set.add(StandardSocketOption.IP_MULTICAST_IF);
+            set.add(StandardSocketOption.IP_MULTICAST_TTL);
+            set.add(StandardSocketOption.IP_MULTICAST_LOOP);
+            return Collections.unmodifiableSet(set);
+        }
+    }
+
+    public final Set<SocketOption<?>> supportedOptions() {
+        return LazyInitialization.defaultOptions;
+    }
+
+    /**
+     * Joins channel's socket to the given group/interface and
+     * optional source address.
+     */
+    private MembershipKey innerJoin(InetAddress group,
+                                    NetworkInterface interf,
+                                    InetAddress source)
+        throws IOException
+    {
+        if (!group.isMulticastAddress())
+            throw new IllegalArgumentException("Group not a multicast address");
+
+        // check multicast address is compatible with this socket
+        if (!(group instanceof Inet4Address)) {
+            if (family == StandardProtocolFamily.INET)
+                throw new IllegalArgumentException("Group is not IPv4 address");
+            if (!(group instanceof Inet6Address))
+                throw new IllegalArgumentException("Address type not supported");
+        }
+
+        // check source address
+        if (source != null) {
+            if (source.isAnyLocalAddress())
+                throw new IllegalArgumentException("Source address is a wildcard address");
+            if (source.isMulticastAddress())
+                throw new IllegalArgumentException("Source address is multicast address");
+            if (source.getClass() != group.getClass())
+                throw new IllegalArgumentException("Source address is different type to group");
+        }
+
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null)
+            sm.checkMulticast(group);
+
+        synchronized (stateLock) {
+            if (!isOpen())
+                throw new ClosedChannelException();
+
+            // check the registry to see if we are already a member of the group
+            if (registry == null) {
+                registry = new MembershipRegistry();
+            } else {
+                // return existing membership key
+                MembershipKey key = registry.checkMembership(group, interf, source);
+                if (key != null)
+                    return key;
+            }
+
+            MembershipKeyImpl key;
+            if (family == StandardProtocolFamily.INET6) {
+                int index = SharedSecrets.getJavaNetGetIndexAccess().getIndex(interf);
+                if (index == -1)
+                    throw new IOException("Network interface cannot be identified");
+
+                // need multicast and source address as byte arrays
+                byte[] groupAddress = Net.inet6AsByteArray(group);
+                byte[] sourceAddress = (source == null) ? null :
+                    Net.inet6AsByteArray(source);
+
+                // join the group
+                int n = Net.join6(fd, groupAddress, index, sourceAddress);
+                if (n == IOStatus.UNAVAILABLE)
+                    throw new UnsupportedOperationException();
+
+                key = new MembershipKeyImpl.Type6(this, group, interf, source,
+                                                  groupAddress, index, sourceAddress);
+
+            } else {
+                // need IPv4 address to identify interface
+                Inet4Address target = Net.anyInet4Address(interf);
+                if (target == null)
+                    throw new IOException("Network interface not configured for IPv4");
+
+                int groupAddress = Net.inet4AsInt(group);
+                int targetAddress = Net.inet4AsInt(target);
+                int sourceAddress = (source == null) ? 0 : Net.inet4AsInt(source);
+
+                // join the group
+                int n = Net.join4(fd, groupAddress, targetAddress, sourceAddress);
+                if (n == IOStatus.UNAVAILABLE)
+                    throw new UnsupportedOperationException();
+
+                key = new MembershipKeyImpl.Type4(this, group, interf, source,
+                                                  groupAddress, targetAddress, sourceAddress);
+            }
+
+            registry.add(key);
+            return key;
+        }
+    }
+
+
+    public MembershipKey join(InetAddress group,
+                              NetworkInterface interf)
+        throws IOException
+    {
+        return innerJoin(group, interf, null);
+    }
+
+
+    public MembershipKey join(InetAddress group,
+                              NetworkInterface interf,
+                              InetAddress source)
+        throws IOException
+    {
+        if (source == null)
+            throw new NullPointerException("source address is null");
+        return innerJoin(group, interf, source);
+    }
+
+    /**
+     * Block datagrams from given source if a memory to receive all
+     * datagrams.
+     */
+    void block(MembershipKeyImpl key, InetAddress source)
+        throws IOException
+    {
+        assert key.channel() == this;
+        assert key.sourceAddress() == null;
+
+        synchronized (stateLock) {
+            if (!key.isValid())
+                throw new IllegalStateException("key is no longer valid");
+            if (source.isAnyLocalAddress())
+                throw new IllegalArgumentException("Source address is a wildcard address");
+            if (source.isMulticastAddress())
+                throw new IllegalArgumentException("Source address is multicast address");
+            if (source.getClass() != key.group().getClass())
+                throw new IllegalArgumentException("Source address is different type to group");
+
+            int n;
+            if (family == StandardProtocolFamily.INET6) {
+                 MembershipKeyImpl.Type6 key6 =
+                    (MembershipKeyImpl.Type6)key;
+                n = Net.block6(fd, key6.groupAddress(), key6.index(),
+                               Net.inet6AsByteArray(source));
+            } else {
+                MembershipKeyImpl.Type4 key4 =
+                    (MembershipKeyImpl.Type4)key;
+                n = Net.block4(fd, key4.groupAddress(), key4.interfaceAddress(),
+                               Net.inet4AsInt(source));
+            }
+            if (n == IOStatus.UNAVAILABLE) {
+                // ancient kernel
+                throw new UnsupportedOperationException();
+            }
+        }
+    }
+
+    /**
+     * Unblock given source.
+     */
+    void unblock(MembershipKeyImpl key, InetAddress source)
+        throws IOException
+    {
+        assert key.channel() == this;
+        assert key.sourceAddress() == null;
+
+        synchronized (stateLock) {
+            if (!key.isValid())
+                throw new IllegalStateException("key is no longer valid");
+
+            if (family == StandardProtocolFamily.INET6) {
+                MembershipKeyImpl.Type6 key6 =
+                    (MembershipKeyImpl.Type6)key;
+                Net.unblock6(fd, key6.groupAddress(), key6.index(),
+                             Net.inet6AsByteArray(source));
+            } else {
+                MembershipKeyImpl.Type4 key4 =
+                    (MembershipKeyImpl.Type4)key;
+                Net.unblock4(fd, key4.groupAddress(), key4.interfaceAddress(),
+                             Net.inet4AsInt(source));
+            }
+        }
+    }
+
+    // package-private
+    void drop(MembershipKeyImpl key)
+        throws IOException
+    {
+        assert key.channel() == this;
+
+        synchronized (stateLock) {
+            if (!key.isValid())
+                return;
+
+            if (family == StandardProtocolFamily.INET6) {
+                MembershipKeyImpl.Type6 key6 =
+                    (MembershipKeyImpl.Type6)key;
+                Net.drop6(fd, key6.groupAddress(), key6.index(), key6.source());
+            } else {
+                MembershipKeyImpl.Type4 key4 = (MembershipKeyImpl.Type4)key;
+                Net.drop4(fd, key4.groupAddress(), key4.interfaceAddress(),
+                    key4.source());
+            }
+
+            key.invalidate();
+            registry.remove(key);
+        }
+    }
+
 }
diff -Nru openjdk.orig/jdk/src/share/classes/sun/nio/ch/FileChannelImpl.java openjdk/jdk/src/share/classes/sun/nio/ch/FileChannelImpl.java
--- openjdk.orig/jdk/src/share/classes/sun/nio/ch/FileChannelImpl.java	2009-02-11 23:11:27.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/nio/ch/FileChannelImpl.java	2009-02-12 16:36:46.000000000 +0000
@@ -100,7 +100,6 @@
             throw new ClosedChannelException();
     }
 
-
     // -- Standard channel operations --
 
     protected void implCloseChannel() throws IOException {
@@ -295,6 +294,10 @@
         }
     }
 
+    public FileChannel positionSBC(long newPosition) throws IOException {
+      return position(newPosition);
+    }
+
     public long size() throws IOException {
         ensureOpen();
         synchronized (positionLock) {
@@ -365,6 +368,10 @@
         }
     }
 
+    public FileChannel truncateSBC(long size) throws IOException {
+      return truncate(size);
+    }
+
     public void force(boolean metaData) throws IOException {
         ensureOpen();
         int rv = -1;
diff -Nru openjdk.orig/jdk/src/share/classes/sun/nio/ch/FileChannelImpl.java~ openjdk/jdk/src/share/classes/sun/nio/ch/FileChannelImpl.java~
--- openjdk.orig/jdk/src/share/classes/sun/nio/ch/FileChannelImpl.java~	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/share/classes/sun/nio/ch/FileChannelImpl.java~	2009-02-11 23:14:46.000000000 +0000
@@ -0,0 +1,1326 @@
+/*
+ * Copyright 2000-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.nio.ch;
+
+import java.io.FileDescriptor;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.RandomAccessFile;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.MappedByteBuffer;
+import java.nio.BufferPoolMXBean;
+import java.nio.channels.*;
+import java.nio.channels.spi.*;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Iterator;
+import java.util.concurrent.ConcurrentHashMap;
+import java.lang.ref.WeakReference;
+import java.lang.ref.ReferenceQueue;
+import java.lang.reflect.Field;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import javax.management.ObjectName;
+import javax.management.MalformedObjectNameException;
+
+import sun.misc.Cleaner;
+import sun.security.action.GetPropertyAction;
+
+public class FileChannelImpl
+    extends FileChannel
+{
+
+    // Used to make native read and write calls
+    private static final NativeDispatcher nd;
+
+    // Memory allocation size for mapping buffers
+    private static final long allocationGranularity;
+
+    // File descriptor
+    private final FileDescriptor fd;
+
+    // File access mode (immutable)
+    private final boolean writable;
+    private final boolean readable;
+
+    // Required to prevent finalization of creating stream (immutable)
+    private final Object parent;
+
+    // Thread-safe set of IDs of native threads, for signalling
+    private final NativeThreadSet threads = new NativeThreadSet(2);
+
+    // Lock for operations involving position and size
+    private final Object positionLock = new Object();
+
+    private FileChannelImpl(FileDescriptor fd, boolean readable,
+                            boolean writable, Object parent)
+    {
+        this.fd = fd;
+        this.readable = readable;
+        this.writable = writable;
+        this.parent = parent;
+    }
+
+    // Invoked by getChannel() methods
+    // of java.io.File{Input,Output}Stream and RandomAccessFile
+    //
+    public static FileChannel open(FileDescriptor fd,
+                                   boolean readable, boolean writable,
+                                   Object parent)
+    {
+        return new FileChannelImpl(fd, readable, writable, parent);
+    }
+
+    private void ensureOpen() throws IOException {
+        if (!isOpen())
+            throw new ClosedChannelException();
+    }
+
+import org.classpath.icedtea.java.nio.channels.FileChannel;
+
+    // -- Standard channel operations --
+
+    protected void implCloseChannel() throws IOException {
+
+        nd.preClose(fd);
+        threads.signal();
+
+        // Invalidate and release any locks that we still hold
+        if (fileLockTable != null) {
+            fileLockTable.removeAll( new FileLockTable.Releaser() {
+                public void release(FileLock fl) throws IOException {
+                    ((FileLockImpl)fl).invalidate();
+                    release0(fd, fl.position(), fl.size());
+                }
+            });
+        }
+
+        if (parent != null) {
+
+            // Close the fd via the parent stream's close method.  The parent
+            // will reinvoke our close method, which is defined in the
+            // superclass AbstractInterruptibleChannel, but the isOpen logic in
+            // that method will prevent this method from being reinvoked.
+            //
+            ((java.io.Closeable)parent).close();
+        } else {
+            nd.close(fd);
+        }
+
+    }
+
+    public int read(ByteBuffer dst) throws IOException {
+        ensureOpen();
+        if (!readable)
+            throw new NonReadableChannelException();
+        synchronized (positionLock) {
+            int n = 0;
+            int ti = -1;
+            try {
+                begin();
+                if (!isOpen())
+                    return 0;
+                ti = threads.add();
+                do {
+                    n = IOUtil.read(fd, dst, -1, nd, positionLock);
+                } while ((n == IOStatus.INTERRUPTED) && isOpen());
+                return IOStatus.normalize(n);
+            } finally {
+                threads.remove(ti);
+                end(n > 0);
+                assert IOStatus.check(n);
+            }
+        }
+    }
+
+    private long read0(ByteBuffer[] dsts) throws IOException {
+        ensureOpen();
+        if (!readable)
+            throw new NonReadableChannelException();
+        synchronized (positionLock) {
+            long n = 0;
+            int ti = -1;
+            try {
+                begin();
+                if (!isOpen())
+                    return 0;
+                ti = threads.add();
+                do {
+                    n = IOUtil.read(fd, dsts, nd);
+                } while ((n == IOStatus.INTERRUPTED) && isOpen());
+                return IOStatus.normalize(n);
+            } finally {
+                threads.remove(ti);
+                end(n > 0);
+                assert IOStatus.check(n);
+            }
+        }
+    }
+
+    public long read(ByteBuffer[] dsts, int offset, int length)
+        throws IOException
+    {
+        if ((offset < 0) || (length < 0) || (offset > dsts.length - length))
+           throw new IndexOutOfBoundsException();
+        // ## Fix IOUtil.write so that we can avoid this array copy
+        return read0(Util.subsequence(dsts, offset, length));
+    }
+
+    public int write(ByteBuffer src) throws IOException {
+        ensureOpen();
+        if (!writable)
+            throw new NonWritableChannelException();
+        synchronized (positionLock) {
+            int n = 0;
+            int ti = -1;
+            try {
+                begin();
+                if (!isOpen())
+                    return 0;
+                ti = threads.add();
+                do {
+                    n = IOUtil.write(fd, src, -1, nd, positionLock);
+                } while ((n == IOStatus.INTERRUPTED) && isOpen());
+                return IOStatus.normalize(n);
+            } finally {
+                threads.remove(ti);
+                end(n > 0);
+                assert IOStatus.check(n);
+            }
+        }
+    }
+
+    private long write0(ByteBuffer[] srcs) throws IOException {
+        ensureOpen();
+        if (!writable)
+            throw new NonWritableChannelException();
+        synchronized (positionLock) {
+            long n = 0;
+            int ti = -1;
+            try {
+                begin();
+                if (!isOpen())
+                    return 0;
+                ti = threads.add();
+                do {
+                    n = IOUtil.write(fd, srcs, nd);
+                } while ((n == IOStatus.INTERRUPTED) && isOpen());
+                return IOStatus.normalize(n);
+            } finally {
+                threads.remove(ti);
+                end(n > 0);
+                assert IOStatus.check(n);
+            }
+        }
+    }
+
+    public long write(ByteBuffer[] srcs, int offset, int length)
+        throws IOException
+    {
+        if ((offset < 0) || (length < 0) || (offset > srcs.length - length))
+           throw new IndexOutOfBoundsException();
+        // ## Fix IOUtil.write so that we can avoid this array copy
+        return write0(Util.subsequence(srcs, offset, length));
+    }
+
+
+    // -- Other operations --
+
+    public long position() throws IOException {
+        ensureOpen();
+        synchronized (positionLock) {
+            long p = -1;
+            int ti = -1;
+            try {
+                begin();
+                if (!isOpen())
+                    return 0;
+                ti = threads.add();
+                do {
+                    p = position0(fd, -1);
+                } while ((p == IOStatus.INTERRUPTED) && isOpen());
+                return IOStatus.normalize(p);
+            } finally {
+                threads.remove(ti);
+                end(p > -1);
+                assert IOStatus.check(p);
+            }
+        }
+    }
+
+    public FileChannel position(long newPosition) throws IOException {
+        ensureOpen();
+        if (newPosition < 0)
+            throw new IllegalArgumentException();
+        synchronized (positionLock) {
+            long p = -1;
+            int ti = -1;
+            try {
+                begin();
+                if (!isOpen())
+                    return null;
+                ti = threads.add();
+                do {
+                    p  = position0(fd, newPosition);
+                } while ((p == IOStatus.INTERRUPTED) && isOpen());
+                return this;
+            } finally {
+                threads.remove(ti);
+                end(p > -1);
+                assert IOStatus.check(p);
+            }
+        }
+    }
+
+    public FileChannel positionSBC(long newPosition) throws IOException {
+      return position(newPosition);
+    }
+
+    public long size() throws IOException {
+        ensureOpen();
+        synchronized (positionLock) {
+            long s = -1;
+            int ti = -1;
+            try {
+                begin();
+                if (!isOpen())
+                    return -1;
+                ti = threads.add();
+                do {
+                    s = size0(fd);
+                } while ((s == IOStatus.INTERRUPTED) && isOpen());
+                return IOStatus.normalize(s);
+            } finally {
+                threads.remove(ti);
+                end(s > -1);
+                assert IOStatus.check(s);
+            }
+        }
+    }
+
+    public FileChannel truncate(long size) throws IOException {
+        ensureOpen();
+        if (size < 0)
+            throw new IllegalArgumentException();
+        if (size > size())
+            return this;
+        if (!writable)
+            throw new NonWritableChannelException();
+        synchronized (positionLock) {
+            int rv = -1;
+            long p = -1;
+            int ti = -1;
+            try {
+                begin();
+                if (!isOpen())
+                    return null;
+                ti = threads.add();
+
+                // get current position
+                do {
+                    p = position0(fd, -1);
+                } while ((p == IOStatus.INTERRUPTED) && isOpen());
+                if (!isOpen())
+                    return null;
+                assert p >= 0;
+
+                // truncate file
+                do {
+                    rv = truncate0(fd, size);
+                } while ((rv == IOStatus.INTERRUPTED) && isOpen());
+                if (!isOpen())
+                    return null;
+
+                // set position to size if greater than size
+                if (p > size)
+                    p = size;
+                do {
+                    rv = (int)position0(fd, p);
+                } while ((rv == IOStatus.INTERRUPTED) && isOpen());
+                return this;
+            } finally {
+                threads.remove(ti);
+                end(rv > -1);
+                assert IOStatus.check(rv);
+            }
+        }
+    }
+
+    public FileChannel truncateSBC(long size) throws IOException {
+      return truncate(size);
+    }
+
+    public void force(boolean metaData) throws IOException {
+        ensureOpen();
+        int rv = -1;
+        int ti = -1;
+        try {
+            begin();
+            if (!isOpen())
+                return;
+            ti = threads.add();
+            do {
+                rv = force0(fd, metaData);
+            } while ((rv == IOStatus.INTERRUPTED) && isOpen());
+        } finally {
+            threads.remove(ti);
+            end(rv > -1);
+            assert IOStatus.check(rv);
+        }
+    }
+
+    // Assume at first that the underlying kernel supports sendfile();
+    // set this to false if we find out later that it doesn't
+    //
+    private static volatile boolean transferSupported = true;
+
+    // Assume that the underlying kernel sendfile() will work if the target
+    // fd is a pipe; set this to false if we find out later that it doesn't
+    //
+    private static volatile boolean pipeSupported = true;
+
+    // Assume that the underlying kernel sendfile() will work if the target
+    // fd is a file; set this to false if we find out later that it doesn't
+    //
+    private static volatile boolean fileSupported = true;
+
+    private long transferToDirectly(long position, int icount,
+                                    WritableByteChannel target)
+        throws IOException
+    {
+        if (!transferSupported)
+            return IOStatus.UNSUPPORTED;
+
+        FileDescriptor targetFD = null;
+        if (target instanceof FileChannelImpl) {
+            if (!fileSupported)
+                return IOStatus.UNSUPPORTED_CASE;
+            targetFD = ((FileChannelImpl)target).fd;
+        } else if (target instanceof SelChImpl) {
+            // Direct transfer to pipe causes EINVAL on some configurations
+            if ((target instanceof SinkChannelImpl) && !pipeSupported)
+                return IOStatus.UNSUPPORTED_CASE;
+            targetFD = ((SelChImpl)target).getFD();
+        }
+        if (targetFD == null)
+            return IOStatus.UNSUPPORTED;
+        int thisFDVal = IOUtil.fdVal(fd);
+        int targetFDVal = IOUtil.fdVal(targetFD);
+        if (thisFDVal == targetFDVal) // Not supported on some configurations
+            return IOStatus.UNSUPPORTED;
+
+        long n = -1;
+        int ti = -1;
+        try {
+            begin();
+            if (!isOpen())
+                return -1;
+            ti = threads.add();
+            do {
+                n = transferTo0(thisFDVal, position, icount, targetFDVal);
+            } while ((n == IOStatus.INTERRUPTED) && isOpen());
+            if (n == IOStatus.UNSUPPORTED_CASE) {
+                if (target instanceof SinkChannelImpl)
+                    pipeSupported = false;
+                if (target instanceof FileChannelImpl)
+                    fileSupported = false;
+                return IOStatus.UNSUPPORTED_CASE;
+            }
+            if (n == IOStatus.UNSUPPORTED) {
+                // Don't bother trying again
+                transferSupported = false;
+                return IOStatus.UNSUPPORTED;
+            }
+            return IOStatus.normalize(n);
+        } finally {
+            threads.remove(ti);
+            end (n > -1);
+        }
+    }
+
+    private long transferToTrustedChannel(long position, int icount,
+                                          WritableByteChannel target)
+        throws IOException
+    {
+        if (  !((target instanceof FileChannelImpl)
+                || (target instanceof SelChImpl)))
+            return IOStatus.UNSUPPORTED;
+
+        // Trusted target: Use a mapped buffer
+        MappedByteBuffer dbb = null;
+        try {
+            dbb = map(MapMode.READ_ONLY, position, icount);
+            // ## Bug: Closing this channel will not terminate the write
+            return target.write(dbb);
+        } finally {
+            if (dbb != null)
+                unmap(dbb);
+        }
+    }
+
+    private long transferToArbitraryChannel(long position, int icount,
+                                            WritableByteChannel target)
+        throws IOException
+    {
+        // Untrusted target: Use a newly-erased buffer
+        int c = Math.min(icount, TRANSFER_SIZE);
+        ByteBuffer bb = Util.getTemporaryDirectBuffer(c);
+        long tw = 0;                    // Total bytes written
+        long pos = position;
+        try {
+            Util.erase(bb);
+            while (tw < icount) {
+                bb.limit(Math.min((int)(icount - tw), TRANSFER_SIZE));
+                int nr = read(bb, pos);
+                if (nr <= 0)
+                    break;
+                bb.flip();
+                // ## Bug: Will block writing target if this channel
+                // ##      is asynchronously closed
+                int nw = target.write(bb);
+                tw += nw;
+                if (nw != nr)
+                    break;
+                pos += nw;
+                bb.clear();
+            }
+            return tw;
+        } catch (IOException x) {
+            if (tw > 0)
+                return tw;
+            throw x;
+        } finally {
+            Util.releaseTemporaryDirectBuffer(bb);
+        }
+    }
+
+    public long transferTo(long position, long count,
+                           WritableByteChannel target)
+        throws IOException
+    {
+        ensureOpen();
+        if (!target.isOpen())
+            throw new ClosedChannelException();
+        if (!readable)
+            throw new NonReadableChannelException();
+        if (target instanceof FileChannelImpl &&
+            !((FileChannelImpl)target).writable)
+            throw new NonWritableChannelException();
+        if ((position < 0) || (count < 0))
+            throw new IllegalArgumentException();
+        long sz = size();
+        if (position > sz)
+            return 0;
+        int icount = (int)Math.min(count, Integer.MAX_VALUE);
+        if ((sz - position) < icount)
+            icount = (int)(sz - position);
+
+        long n;
+
+        // Attempt a direct transfer, if the kernel supports it
+        if ((n = transferToDirectly(position, icount, target)) >= 0)
+            return n;
+
+        // Attempt a mapped transfer, but only to trusted channel types
+        if ((n = transferToTrustedChannel(position, icount, target)) >= 0)
+            return n;
+
+        // Slow path for untrusted targets
+        return transferToArbitraryChannel(position, icount, target);
+    }
+
+    private long transferFromFileChannel(FileChannelImpl src,
+                                         long position, long count)
+        throws IOException
+    {
+        // Note we could loop here to accumulate more at once
+        synchronized (src.positionLock) {
+            long p = src.position();
+            int icount = (int)Math.min(Math.min(count, Integer.MAX_VALUE),
+                                       src.size() - p);
+            // ## Bug: Closing this channel will not terminate the write
+            MappedByteBuffer bb = src.map(MapMode.READ_ONLY, p, icount);
+            try {
+                long n = write(bb, position);
+                src.position(p + n);
+                return n;
+            } finally {
+                unmap(bb);
+            }
+        }
+    }
+
+    private static final int TRANSFER_SIZE = 8192;
+
+    private long transferFromArbitraryChannel(ReadableByteChannel src,
+                                              long position, long count)
+        throws IOException
+    {
+        // Untrusted target: Use a newly-erased buffer
+        int c = (int)Math.min(count, TRANSFER_SIZE);
+        ByteBuffer bb = Util.getTemporaryDirectBuffer(c);
+        long tw = 0;                    // Total bytes written
+        long pos = position;
+        try {
+            Util.erase(bb);
+            while (tw < count) {
+                bb.limit((int)Math.min((count - tw), (long)TRANSFER_SIZE));
+                // ## Bug: Will block reading src if this channel
+                // ##      is asynchronously closed
+                int nr = src.read(bb);
+                if (nr <= 0)
+                    break;
+                bb.flip();
+                int nw = write(bb, pos);
+                tw += nw;
+                if (nw != nr)
+                    break;
+                pos += nw;
+                bb.clear();
+            }
+            return tw;
+        } catch (IOException x) {
+            if (tw > 0)
+                return tw;
+            throw x;
+        } finally {
+            Util.releaseTemporaryDirectBuffer(bb);
+        }
+    }
+
+    public long transferFrom(ReadableByteChannel src,
+                             long position, long count)
+        throws IOException
+    {
+        ensureOpen();
+        if (!src.isOpen())
+            throw new ClosedChannelException();
+        if (!writable)
+            throw new NonWritableChannelException();
+        if ((position < 0) || (count < 0))
+            throw new IllegalArgumentException();
+        if (position > size())
+            return 0;
+        if (src instanceof FileChannelImpl)
+           return transferFromFileChannel((FileChannelImpl)src,
+                                          position, count);
+
+        return transferFromArbitraryChannel(src, position, count);
+    }
+
+    public int read(ByteBuffer dst, long position) throws IOException {
+        if (dst == null)
+            throw new NullPointerException();
+        if (position < 0)
+            throw new IllegalArgumentException("Negative position");
+        if (!readable)
+            throw new NonReadableChannelException();
+        ensureOpen();
+        int n = 0;
+        int ti = -1;
+        try {
+            begin();
+            if (!isOpen())
+                return -1;
+            ti = threads.add();
+            do {
+                n = IOUtil.read(fd, dst, position, nd, positionLock);
+            } while ((n == IOStatus.INTERRUPTED) && isOpen());
+            return IOStatus.normalize(n);
+        } finally {
+            threads.remove(ti);
+            end(n > 0);
+            assert IOStatus.check(n);
+        }
+    }
+
+    public int write(ByteBuffer src, long position) throws IOException {
+        if (src == null)
+            throw new NullPointerException();
+        if (position < 0)
+            throw new IllegalArgumentException("Negative position");
+        if (!writable)
+            throw new NonWritableChannelException();
+        ensureOpen();
+        int n = 0;
+        int ti = -1;
+        try {
+            begin();
+            if (!isOpen())
+                return -1;
+            ti = threads.add();
+            do {
+                n = IOUtil.write(fd, src, position, nd, positionLock);
+            } while ((n == IOStatus.INTERRUPTED) && isOpen());
+            return IOStatus.normalize(n);
+        } finally {
+            threads.remove(ti);
+            end(n > 0);
+            assert IOStatus.check(n);
+        }
+    }
+
+
+    // -- Memory-mapped buffers --
+
+    private static class Unmapper
+        implements Runnable
+    {
+        // keep track of mapped buffer usage
+        static volatile int count;
+        static volatile long totalSize;
+        static volatile long totalCapacity;
+
+        private long address;
+        private long size;
+        private int cap;
+
+        private Unmapper(long address, long size, int cap) {
+            assert (address != 0);
+            this.address = address;
+            this.size = size;
+            this.cap = cap;
+
+            synchronized (Unmapper.class) {
+                count++;
+                totalSize += size;
+                totalCapacity += cap;
+            }
+        }
+
+        public void run() {
+            if (address == 0)
+                return;
+            unmap0(address, size);
+            address = 0;
+
+            synchronized (Unmapper.class) {
+                count--;
+                totalSize -= size;
+                totalCapacity -= cap;
+            }
+        }
+    }
+
+    private static void unmap(MappedByteBuffer bb) {
+        Cleaner cl = ((DirectBuffer)bb).cleaner();
+        if (cl != null)
+            cl.clean();
+    }
+
+    private static final int MAP_RO = 0;
+    private static final int MAP_RW = 1;
+    private static final int MAP_PV = 2;
+
+    public MappedByteBuffer map(MapMode mode, long position, long size)
+        throws IOException
+    {
+        ensureOpen();
+        if (position < 0L)
+            throw new IllegalArgumentException("Negative position");
+        if (size < 0L)
+            throw new IllegalArgumentException("Negative size");
+        if (position + size < 0)
+            throw new IllegalArgumentException("Position + size overflow");
+        if (size > Integer.MAX_VALUE)
+            throw new IllegalArgumentException("Size exceeds Integer.MAX_VALUE");
+        int imode = -1;
+        if (mode == MapMode.READ_ONLY)
+            imode = MAP_RO;
+        else if (mode == MapMode.READ_WRITE)
+            imode = MAP_RW;
+        else if (mode == MapMode.PRIVATE)
+            imode = MAP_PV;
+        assert (imode >= 0);
+        if ((mode != MapMode.READ_ONLY) && !writable)
+            throw new NonWritableChannelException();
+        if (!readable)
+            throw new NonReadableChannelException();
+
+        long addr = -1;
+        int ti = -1;
+        try {
+            begin();
+            if (!isOpen())
+                return null;
+            ti = threads.add();
+            if (size() < position + size) { // Extend file size
+                if (!writable) {
+                    throw new IOException("Channel not open for writing " +
+                        "- cannot extend file to required size");
+                }
+                int rv;
+                do {
+                    rv = truncate0(fd, position + size);
+                } while ((rv == IOStatus.INTERRUPTED) && isOpen());
+            }
+            if (size == 0) {
+                addr = 0;
+                if ((!writable) || (imode == MAP_RO))
+                    return Util.newMappedByteBufferR(0, 0, null);
+                else
+                    return Util.newMappedByteBuffer(0, 0, null);
+            }
+
+            int pagePosition = (int)(position % allocationGranularity);
+            long mapPosition = position - pagePosition;
+            long mapSize = size + pagePosition;
+            try {
+                // If no exception was thrown from map0, the address is valid
+                addr = map0(imode, mapPosition, mapSize);
+            } catch (OutOfMemoryError x) {
+                // An OutOfMemoryError may indicate that we've exhausted memory
+                // so force gc and re-attempt map
+                System.gc();
+                try {
+                    Thread.sleep(100);
+                } catch (InterruptedException y) {
+                    Thread.currentThread().interrupt();
+                }
+                try {
+                    addr = map0(imode, mapPosition, mapSize);
+                } catch (OutOfMemoryError y) {
+                    // After a second OOME, fail
+                    throw new IOException("Map failed", y);
+                }
+            }
+
+            assert (IOStatus.checkAll(addr));
+            assert (addr % allocationGranularity == 0);
+            int isize = (int)size;
+            Unmapper um = new Unmapper(addr, size + pagePosition, isize);
+            if ((!writable) || (imode == MAP_RO))
+                return Util.newMappedByteBufferR(isize, addr + pagePosition, um);
+            else
+                return Util.newMappedByteBuffer(isize, addr + pagePosition, um);
+        } finally {
+            threads.remove(ti);
+            end(IOStatus.checkAll(addr));
+        }
+    }
+
+    /**
+     * Returns the management interface for mapped buffers
+     */
+    public static BufferPoolMXBean getMappedBufferPoolMXBean() {
+        return LazyInitialization.mappedBufferPoolMXBean;
+    }
+
+    // Lazy initialization of management interface
+    private static class LazyInitialization {
+        static final BufferPoolMXBean mappedBufferPoolMXBean = mappedBufferPoolMXBean();
+
+        private static BufferPoolMXBean mappedBufferPoolMXBean() {
+            final String pool = "mapped";
+            final ObjectName obj;
+            try {
+                obj = new ObjectName("java.nio:type=BufferPool,name=" + pool);
+            } catch (MalformedObjectNameException x) {
+                throw new AssertionError(x);
+            }
+            return new BufferPoolMXBean() {
+
+                public ObjectName getObjectName() {
+                    return obj;
+                }
+
+                public String getName() {
+                    return pool;
+                }
+
+                public long getCount() {
+                    return Unmapper.count;
+                }
+
+                public long getTotalCapacity() {
+                    return Unmapper.totalCapacity;
+                }
+
+                public long getMemoryUsed() {
+                    return Unmapper.totalSize;
+                }
+            };
+        }
+    }
+
+    // -- Locks --
+
+    public static final int NO_LOCK = -1;       // Failed to lock
+    public static final int LOCKED = 0;         // Obtained requested lock
+    public static final int RET_EX_LOCK = 1;    // Obtained exclusive lock
+    public static final int INTERRUPTED = 2;    // Request interrupted
+
+    // keeps track of locks on this file
+    private volatile FileLockTable fileLockTable;
+
+    // indicates if file locks are maintained system-wide (as per spec)
+    private static boolean isSharedFileLockTable;
+
+    // indicates if the disableSystemWideOverlappingFileLockCheck property
+    // has been checked
+    private static volatile boolean propertyChecked;
+
+    // The lock list in J2SE 1.4/5.0 was local to each FileChannel instance so
+    // the overlap check wasn't system wide when there were multiple channels to
+    // the same file. This property is used to get 1.4/5.0 behavior if desired.
+    private static boolean isSharedFileLockTable() {
+        if (!propertyChecked) {
+            synchronized (FileChannelImpl.class) {
+                if (!propertyChecked) {
+                    String value = AccessController.doPrivileged(
+                        new GetPropertyAction(
+                            "sun.nio.ch.disableSystemWideOverlappingFileLockCheck"));
+                    isSharedFileLockTable = ((value == null) || value.equals("false"));
+                    propertyChecked = true;
+                }
+            }
+        }
+        return isSharedFileLockTable;
+    }
+
+    private FileLockTable fileLockTable() {
+        if (fileLockTable == null) {
+            synchronized (this) {
+                if (fileLockTable == null) {
+                    fileLockTable = isSharedFileLockTable() ?
+                        new SharedFileLockTable(this) : new SimpleFileLockTable();
+                }
+            }
+        }
+        return fileLockTable;
+    }
+
+    public FileLock lock(long position, long size, boolean shared)
+        throws IOException
+    {
+        ensureOpen();
+        if (shared && !readable)
+            throw new NonReadableChannelException();
+        if (!shared && !writable)
+            throw new NonWritableChannelException();
+        FileLockImpl fli = new FileLockImpl(this, position, size, shared);
+        FileLockTable flt = fileLockTable();
+        flt.add(fli);
+        boolean i = true;
+        int ti = -1;
+        try {
+            begin();
+            if (!isOpen())
+                return null;
+            ti = threads.add();
+            int result = lock0(fd, true, position, size, shared);
+            if (result == RET_EX_LOCK) {
+                assert shared;
+                FileLockImpl fli2 = new FileLockImpl(this, position, size,
+                                                     false);
+                flt.replace(fli, fli2);
+                return fli2;
+            }
+            if (result == INTERRUPTED || result == NO_LOCK) {
+                flt.remove(fli);
+                i = false;
+            }
+        } catch (IOException e) {
+            flt.remove(fli);
+            throw e;
+        } finally {
+            threads.remove(ti);
+            try {
+                end(i);
+            } catch (ClosedByInterruptException e) {
+                throw new FileLockInterruptionException();
+            }
+        }
+        return fli;
+    }
+
+    public FileLock tryLock(long position, long size, boolean shared)
+        throws IOException
+    {
+        ensureOpen();
+        if (shared && !readable)
+            throw new NonReadableChannelException();
+        if (!shared && !writable)
+            throw new NonWritableChannelException();
+        FileLockImpl fli = new FileLockImpl(this, position, size, shared);
+        FileLockTable flt = fileLockTable();
+        flt.add(fli);
+        int result = lock0(fd, false, position, size, shared);
+        if (result == NO_LOCK) {
+            flt.remove(fli);
+            return null;
+        }
+        if (result == RET_EX_LOCK) {
+            assert shared;
+            FileLockImpl fli2 = new FileLockImpl(this, position, size,
+                                                 false);
+            flt.replace(fli, fli2);
+            return fli2;
+        }
+        return fli;
+    }
+
+    void release(FileLockImpl fli) throws IOException {
+        ensureOpen();
+        release0(fd, fli.position(), fli.size());
+        assert fileLockTable != null;
+        fileLockTable.remove(fli);
+    }
+
+
+    // -- File lock support  --
+
+    /**
+     * A table of FileLocks.
+     */
+    private interface FileLockTable {
+        /**
+         * Adds a file lock to the table.
+         *
+         * @throws OverlappingFileLockException if the file lock overlaps
+         *         with an existing file lock in the table
+         */
+        void add(FileLock fl) throws OverlappingFileLockException;
+
+        /**
+         * Remove an existing file lock from the table.
+         */
+        void remove(FileLock fl);
+
+        /**
+         * An implementation of this interface releases a given file lock.
+         * Used with removeAll.
+         */
+        interface Releaser {
+            void release(FileLock fl) throws IOException;
+        }
+
+        /**
+         * Removes all file locks from the table.
+         * <p>
+         * The Releaser#release method is invoked for each file lock before
+         * it is removed.
+         *
+         * @throws IOException if the release method throws IOException
+         */
+        void removeAll(Releaser r) throws IOException;
+
+        /**
+         * Replaces an existing file lock in the table.
+         */
+        void replace(FileLock fl1, FileLock fl2);
+    }
+
+    /**
+     * A simple file lock table that maintains a list of FileLocks obtained by a
+     * FileChannel. Use to get 1.4/5.0 behaviour.
+     */
+    private static class SimpleFileLockTable implements FileLockTable {
+        // synchronize on list for access
+        private List<FileLock> lockList = new ArrayList<FileLock>(2);
+
+        public SimpleFileLockTable() {
+        }
+
+        private void checkList(long position, long size)
+            throws OverlappingFileLockException
+        {
+            assert Thread.holdsLock(lockList);
+            for (FileLock fl: lockList) {
+                if (fl.overlaps(position, size)) {
+                    throw new OverlappingFileLockException();
+                }
+            }
+        }
+
+        public void add(FileLock fl) throws OverlappingFileLockException {
+            synchronized (lockList) {
+                checkList(fl.position(), fl.size());
+                lockList.add(fl);
+            }
+        }
+
+        public void remove(FileLock fl) {
+            synchronized (lockList) {
+                lockList.remove(fl);
+            }
+        }
+
+        public void removeAll(Releaser releaser) throws IOException {
+            synchronized(lockList) {
+                Iterator<FileLock> i = lockList.iterator();
+                while (i.hasNext()) {
+                    FileLock fl = i.next();
+                    releaser.release(fl);
+                    i.remove();
+                }
+            }
+        }
+
+        public void replace(FileLock fl1, FileLock fl2) {
+            synchronized (lockList) {
+                lockList.remove(fl1);
+                lockList.add(fl2);
+            }
+        }
+    }
+
+    /**
+     * A weak reference to a FileLock.
+     * <p>
+     * SharedFileLockTable uses a list of file lock references to avoid keeping the
+     * FileLock (and FileChannel) alive.
+     */
+    private static class FileLockReference extends WeakReference<FileLock> {
+        private FileKey fileKey;
+
+        FileLockReference(FileLock referent,
+                          ReferenceQueue<FileLock> queue,
+                          FileKey key) {
+            super(referent, queue);
+            this.fileKey = key;
+        }
+
+        private FileKey fileKey() {
+            return fileKey;
+        }
+    }
+
+    /**
+     * A file lock table that is over a system-wide map of all file locks.
+     */
+    private static class SharedFileLockTable implements FileLockTable {
+        // The system-wide map is a ConcurrentHashMap that is keyed on the FileKey.
+        // The map value is a list of file locks represented by FileLockReferences.
+        // All access to the list must be synchronized on the list.
+        private static ConcurrentHashMap<FileKey, ArrayList<FileLockReference>> lockMap =
+            new ConcurrentHashMap<FileKey, ArrayList<FileLockReference>>();
+
+        // reference queue for cleared refs
+        private static ReferenceQueue<FileLock> queue = new ReferenceQueue<FileLock>();
+
+        // the enclosing file channel
+        private FileChannelImpl fci;
+
+        // File key for the file that this channel is connected to
+        private FileKey fileKey;
+
+        public SharedFileLockTable(FileChannelImpl fci) {
+            this.fci = fci;
+            this.fileKey = FileKey.create(fci.fd);
+        }
+
+        public void add(FileLock fl) throws OverlappingFileLockException {
+            ArrayList<FileLockReference> list = lockMap.get(fileKey);
+
+            for (;;) {
+
+                // The key isn't in the map so we try to create it atomically
+                if (list == null) {
+                    list = new ArrayList<FileLockReference>(2);
+                    ArrayList<FileLockReference> prev;
+                    synchronized (list) {
+                        prev = lockMap.putIfAbsent(fileKey, list);
+                        if (prev == null) {
+                            // we successfully created the key so we add the file lock
+                            list.add(new FileLockReference(fl, queue, fileKey));
+                            break;
+                        }
+                    }
+                    // someone else got there first
+                    list = prev;
+                }
+
+                // There is already a key. It is possible that some other thread
+                // is removing it so we re-fetch the value from the map. If it
+                // hasn't changed then we check the list for overlapping locks
+                // and add the new lock to the list.
+                synchronized (list) {
+                    ArrayList<FileLockReference> current = lockMap.get(fileKey);
+                    if (list == current) {
+                        checkList(list, fl.position(), fl.size());
+                        list.add(new FileLockReference(fl, queue, fileKey));
+                        break;
+                    }
+                    list = current;
+                }
+
+            }
+
+            // process any stale entries pending in the reference queue
+            removeStaleEntries();
+        }
+
+        private void removeKeyIfEmpty(FileKey fk, ArrayList<FileLockReference> list) {
+            assert Thread.holdsLock(list);
+            assert lockMap.get(fk) == list;
+            if (list.isEmpty()) {
+                lockMap.remove(fk);
+            }
+        }
+
+        public void remove(FileLock fl) {
+            assert fl != null;
+
+            // the lock must exist so the list of locks must be present
+            ArrayList<FileLockReference> list = lockMap.get(fileKey);
+            assert list != null;
+
+            synchronized (list) {
+                int index = 0;
+                while (index < list.size()) {
+                    FileLockReference ref = list.get(index);
+                    FileLock lock = ref.get();
+                    if (lock == fl) {
+                        assert (lock != null) && (lock.channel() == fci);
+                        ref.clear();
+                        list.remove(index);
+                        break;
+                    }
+                    index++;
+                }
+            }
+        }
+
+        public void removeAll(Releaser releaser) throws IOException {
+            ArrayList<FileLockReference> list = lockMap.get(fileKey);
+            if (list != null) {
+                synchronized (list) {
+                    int index = 0;
+                    while (index < list.size()) {
+                        FileLockReference ref = list.get(index);
+                        FileLock lock = ref.get();
+
+                        // remove locks obtained by this channel
+                        if (lock != null && lock.channel() == fci) {
+                            // invoke the releaser to invalidate/release the lock
+                            releaser.release(lock);
+
+                            // remove the lock from the list
+                            ref.clear();
+                            list.remove(index);
+                        } else {
+                            index++;
+                        }
+                    }
+
+                    // once the lock list is empty we remove it from the map
+                    removeKeyIfEmpty(fileKey, list);
+                }
+            }
+        }
+
+        public void replace(FileLock fromLock, FileLock toLock) {
+            // the lock must exist so there must be a list
+            ArrayList<FileLockReference> list = lockMap.get(fileKey);
+            assert list != null;
+
+            synchronized (list) {
+                for (int index=0; index<list.size(); index++) {
+                    FileLockReference ref = list.get(index);
+                    FileLock lock = ref.get();
+                    if (lock == fromLock) {
+                        ref.clear();
+                        list.set(index, new FileLockReference(toLock, queue, fileKey));
+                        break;
+                    }
+                }
+            }
+        }
+
+        // Check for overlapping file locks
+        private void checkList(List<FileLockReference> list, long position, long size)
+            throws OverlappingFileLockException
+        {
+            assert Thread.holdsLock(list);
+            for (FileLockReference ref: list) {
+                FileLock fl = ref.get();
+                if (fl != null && fl.overlaps(position, size))
+                    throw new OverlappingFileLockException();
+            }
+        }
+
+        // Process the reference queue
+        private void removeStaleEntries() {
+            FileLockReference ref;
+            while ((ref = (FileLockReference)queue.poll()) != null) {
+                FileKey fk = ref.fileKey();
+                ArrayList<FileLockReference> list = lockMap.get(fk);
+                if (list != null) {
+                    synchronized (list) {
+                        list.remove(ref);
+                        removeKeyIfEmpty(fk, list);
+                    }
+                }
+            }
+        }
+    }
+
+    // -- Native methods --
+
+    // Grabs a file lock
+    native int lock0(FileDescriptor fd, boolean blocking, long pos, long size,
+                     boolean shared) throws IOException;
+
+    // Releases a file lock
+    native void release0(FileDescriptor fd, long pos, long size)
+        throws IOException;
+
+    // Creates a new mapping
+    private native long map0(int prot, long position, long length)
+        throws IOException;
+
+    // Removes an existing mapping
+    private static native int unmap0(long address, long length);
+
+    // Forces output to device
+    private native int force0(FileDescriptor fd, boolean metaData);
+
+    // Truncates a file
+    private native int truncate0(FileDescriptor fd, long size);
+
+    // Transfers from src to dst, or returns -2 if kernel can't do that
+    private native long transferTo0(int src, long position, long count, int dst);
+
+    // Sets or reports this file's position
+    // If offset is -1, the current position is returned
+    // otherwise the position is set to offset
+    private native long position0(FileDescriptor fd, long offset);
+
+    // Reports this file's size
+    private native long size0(FileDescriptor fd);
+
+    // Caches fieldIDs
+    private static native long initIDs();
+
+    static {
+        Util.load();
+        allocationGranularity = initIDs();
+        nd = new FileDispatcher();
+    }
+
+}
diff -Nru openjdk.orig/jdk/src/share/classes/sun/nio/ch/Net.java openjdk/jdk/src/share/classes/sun/nio/ch/Net.java
--- openjdk.orig/jdk/src/share/classes/sun/nio/ch/Net.java	2009-02-11 23:11:27.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/nio/ch/Net.java	2009-02-11 23:14:46.000000000 +0000
@@ -32,6 +32,15 @@
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+
+import java.util.Enumeration;
+
+import org.classpath.icedtea.java.net.ProtocolFamily;
+import org.classpath.icedtea.java.net.SocketOption;
+import org.classpath.icedtea.java.net.StandardProtocolFamily;
+import org.classpath.icedtea.java.net.StandardSocketOption;
 
 class Net {                                             // package-private
 
@@ -489,4 +498,314 @@
         initIDs();
     }
 
+    // From 1.7
+
+    static native void listen(FileDescriptor fd, int backlog) throws IOException;
+
+    // unspecified protocol family
+    static final ProtocolFamily UNSPEC = new ProtocolFamily() {
+        public String name() {
+            return "UNSPEC";
+        }
+    };
+
+    // -- Socket options
+
+    static void setSocketOption(FileDescriptor fd, ProtocolFamily family,
+                                SocketOption<?> name, Object value)
+        throws IOException
+    {
+        if (value == null)
+            throw new IllegalArgumentException("Invalid option value");
+
+        // only simple values supported by this method
+        Class<?> type = name.type();
+        if (type != Integer.class && type != Boolean.class)
+            throw new AssertionError("Should not reach here");
+
+        // special handling
+        if (name == StandardSocketOption.SO_RCVBUF ||
+            name == StandardSocketOption.SO_SNDBUF)
+        {
+            int i = ((Integer)value).intValue();
+            if (i < 0)
+                throw new IllegalArgumentException("Invalid send/receive buffer size");
+        }
+        if (name == StandardSocketOption.SO_LINGER) {
+            int i = ((Integer)value).intValue();
+            if (i < 0)
+                value = Integer.valueOf(-1);
+            if (i > 65535)
+                value = Integer.valueOf(65535);
+        }
+        if (name == StandardSocketOption.IP_TOS) {
+            int i = ((Integer)value).intValue();
+            if (i < 0 || i > 255)
+                throw new IllegalArgumentException("Invalid IP_TOS value");
+        }
+        if (name == StandardSocketOption.IP_MULTICAST_TTL) {
+            int i = ((Integer)value).intValue();
+            if (i < 0 || i > 255)
+                throw new IllegalArgumentException("Invalid TTL/hop value");
+        }
+
+        // map option name to platform level/name
+        OptionKey key = SocketOptionRegistry.findOption(name, family);
+        if (key == null)
+            throw new AssertionError("Option not found");
+
+        int arg;
+        if (type == Integer.class) {
+            arg = ((Integer)value).intValue();
+        } else {
+            boolean b = ((Boolean)value).booleanValue();
+            arg = (b) ? 1 : 0;
+        }
+
+        boolean mayNeedConversion = (family == UNSPEC);
+        setIntOption1(fd, mayNeedConversion, key.level(), key.name(), arg);
+    }
+
+    static Object getSocketOption(FileDescriptor fd, ProtocolFamily family,
+                                  SocketOption<?> name)
+        throws IOException
+    {
+        Class<?> type = name.type();
+
+        // only simple values supported by this method
+        if (type != Integer.class && type != Boolean.class)
+            throw new AssertionError("Should not reach here");
+
+        // map option name to platform level/name
+        OptionKey key = SocketOptionRegistry.findOption(name, family);
+        if (key == null)
+            throw new AssertionError("Option not found");
+
+        boolean mayNeedConversion = (family == UNSPEC);
+        int value = getIntOption0(fd, mayNeedConversion, key.level(), key.name());
+
+        if (type == Integer.class) {
+            return Integer.valueOf(value);
+        } else {
+            return (value == 0) ? Boolean.FALSE : Boolean.TRUE;
+        }
+    }
+
+    private static native int getIntOption0(FileDescriptor fd, boolean mayNeedConversion,
+                                            int level, int opt)
+        throws IOException;
+
+    private static native void setIntOption1(FileDescriptor fd, boolean mayNeedConversion,
+                                             int level, int opt, int arg)
+        throws IOException;
+
+    public final static int SHUT_RD = 0;
+    public final static int SHUT_WR = 1;
+
+    static native void shutdown(FileDescriptor fd, int how) throws IOException;
+
+    static native void setInterface6(FileDescriptor fd, int index) throws IOException;
+
+    static native void setInterface4(FileDescriptor fd, int interf) throws IOException;
+
+    static native int getInterface4(FileDescriptor fd) throws IOException;
+
+    static native int getInterface6(FileDescriptor fd) throws IOException;
+
+    /**
+     * Returns any IPv4 address of the given network interface, or
+     * null if the interface does not have any IPv4 addresses.
+     */
+    static Inet4Address anyInet4Address(final NetworkInterface interf) {
+        return AccessController.doPrivileged(new PrivilegedAction<Inet4Address>() {
+            public Inet4Address run() {
+                Enumeration<InetAddress> addrs = interf.getInetAddresses();
+                while (addrs.hasMoreElements()) {
+                    InetAddress addr = addrs.nextElement();
+                    if (addr instanceof Inet4Address) {
+                        return (Inet4Address)addr;
+                    }
+                }
+                return null;
+            }
+        });
+    }
+
+    /**
+     * Returns an IPv4 address as an int.
+     */
+    static int inet4AsInt(InetAddress ia) {
+        if (ia instanceof Inet4Address) {
+            byte[] addr = ia.getAddress();
+            int address  = addr[3] & 0xFF;
+            address |= ((addr[2] << 8) & 0xFF00);
+            address |= ((addr[1] << 16) & 0xFF0000);
+            address |= ((addr[0] << 24) & 0xFF000000);
+            return address;
+        }
+        throw new AssertionError("Should not reach here");
+    }
+
+    /**
+     * Returns an InetAddress from the given IPv4 address
+     * represented as an int.
+     */
+    static InetAddress inet4FromInt(int address) {
+        byte[] addr = new byte[4];
+        addr[0] = (byte) ((address >>> 24) & 0xFF);
+        addr[1] = (byte) ((address >>> 16) & 0xFF);
+        addr[2] = (byte) ((address >>> 8) & 0xFF);
+        addr[3] = (byte) (address & 0xFF);
+        try {
+            return InetAddress.getByAddress(addr);
+        } catch (UnknownHostException uhe) {
+            throw new AssertionError("Should not reach here");
+        }
+    }
+
+    /**
+     * Returns an IPv6 address as a byte array
+     */
+    static byte[] inet6AsByteArray(InetAddress ia) {
+        if (ia instanceof Inet6Address) {
+            return ia.getAddress();
+        }
+
+        // need to construct IPv4-mapped address
+        if (ia instanceof Inet4Address) {
+            byte[] ip4address = ia.getAddress();
+            byte[] address = new byte[16];
+            address[10] = (byte)0xff;
+            address[11] = (byte)0xff;
+            address[12] = ip4address[0];
+            address[13] = ip4address[1];
+            address[14] = ip4address[2];
+            address[15] = ip4address[3];
+            return address;
+        }
+
+        throw new AssertionError("Should not reach here");
+    }
+
+    // -- Miscellaneous utilities --
+
+    private static volatile boolean checkedIPv6 = false;
+    private static volatile boolean isIPv6Available;
+
+    /**
+     * Tells whether dual-IPv4/IPv6 sockets should be used.
+     */
+    static boolean isIPv6Available() {
+        if (!checkedIPv6) {
+            isIPv6Available = isIPv6Available0();
+            checkedIPv6 = true;
+        }
+        return isIPv6Available;
+    }
+
+    /**
+     * Join IPv6 multicast group
+     */
+    static int join6(FileDescriptor fd, byte[] group, int index, byte[] source)
+        throws IOException
+    {
+        return joinOrDrop6(true, fd, group, index, source);
+    }
+
+    /**
+     * Drop membership of IPv6 multicast group
+     */
+    static void drop6(FileDescriptor fd, byte[] group, int index, byte[] source)
+        throws IOException
+    {
+        joinOrDrop6(false, fd, group, index, source);
+    }
+
+    private static native int joinOrDrop6(boolean join, FileDescriptor fd, byte[] group, int index, byte[] source)
+        throws IOException;
+
+    /**
+     * Block IPv6 source
+     */
+    static int block6(FileDescriptor fd, byte[] group, int index, byte[] source)
+        throws IOException
+    {
+        return blockOrUnblock6(true, fd, group, index, source);
+    }
+
+    /**
+     * Unblock IPv6 source
+     */
+    static void unblock6(FileDescriptor fd, byte[] group, int index, byte[] source)
+        throws IOException
+    {
+        blockOrUnblock6(false, fd, group, index, source);
+    }
+
+    static native int blockOrUnblock6(boolean block, FileDescriptor fd, byte[] group, int index, byte[] source)
+        throws IOException;
+
+    /**
+     * Join IPv4 multicast group
+     */
+    static int join4(FileDescriptor fd, int group, int interf, int source)
+        throws IOException
+    {
+        return joinOrDrop4(true, fd, group, interf, source);
+    }
+
+    /**
+     * Drop membership of IPv4 multicast group
+     */
+    static void drop4(FileDescriptor fd, int group, int interf, int source)
+        throws IOException
+    {
+        joinOrDrop4(false, fd, group, interf, source);
+    }
+
+    private static native int joinOrDrop4(boolean join, FileDescriptor fd, int group, int interf, int source)
+        throws IOException;
+
+    /**
+     * Block IPv4 source
+     */
+    static int block4(FileDescriptor fd, int group, int interf, int source)
+        throws IOException
+    {
+        return blockOrUnblock4(true, fd, group, interf, source);
+    }
+
+    /**
+     * Unblock IPv4 source
+     */
+    static void unblock4(FileDescriptor fd, int group, int interf, int source)
+        throws IOException
+    {
+        blockOrUnblock4(false, fd, group, interf, source);
+    }
+
+    private static native int blockOrUnblock4(boolean block, FileDescriptor fd, int group,
+                                              int interf, int source)
+        throws IOException;
+
+    static int connect(FileDescriptor fd, InetAddress remote, int remotePort)
+        throws IOException
+    {
+        return connect(UNSPEC, fd, remote, remotePort);
+    }
+
+    static int connect(ProtocolFamily family, FileDescriptor fd, InetAddress remote, int remotePort)
+        throws IOException
+    {
+        boolean preferIPv6 = isIPv6Available() &&
+            (family != StandardProtocolFamily.INET);
+        return connect0(preferIPv6, fd, remote, remotePort);
+    }
+
+    private static native int connect0(boolean preferIPv6,
+                                       FileDescriptor fd,
+                                       InetAddress remote,
+                                       int remotePort)
+        throws IOException;
+
 }
diff -Nru openjdk.orig/jdk/src/share/classes/sun/security/util/SecurityConstants.java openjdk/jdk/src/share/classes/sun/security/util/SecurityConstants.java
--- openjdk.orig/jdk/src/share/classes/sun/security/util/SecurityConstants.java	2009-02-11 23:11:35.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/security/util/SecurityConstants.java	2009-02-11 23:14:46.000000000 +0000
@@ -52,6 +52,7 @@
     public static final String FILE_EXECUTE_ACTION = "execute";
     public static final String FILE_READ_ACTION = "read";
     public static final String FILE_WRITE_ACTION = "write";
+    public static final String FILE_READLINK_ACTION = "readlink";
 
     public static final String SOCKET_RESOLVE_ACTION = "resolve";
     public static final String SOCKET_CONNECT_ACTION = "connect";
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/nio/ch/FileDispatcher.java openjdk/jdk/src/solaris/classes/sun/nio/ch/FileDispatcher.java
--- openjdk.orig/jdk/src/solaris/classes/sun/nio/ch/FileDispatcher.java	2009-02-11 23:11:51.000000000 +0000
+++ openjdk/jdk/src/solaris/classes/sun/nio/ch/FileDispatcher.java	2009-02-11 23:14:46.000000000 +0000
@@ -35,6 +35,11 @@
 class FileDispatcher extends NativeDispatcher
 {
 
+    public static final int NO_LOCK = -1;       // Failed to lock
+    public static final int LOCKED = 0;         // Obtained requested lock
+    public static final int RET_EX_LOCK = 1;    // Obtained exclusive lock
+    public static final int INTERRUPTED = 2;    // Request interrupted
+
     static {
         Util.load();
         init();
@@ -77,6 +82,28 @@
         preClose0(fd);
     }
 
+    long size(FileDescriptor fd) throws IOException {
+        return size0(fd);
+    }
+
+    int truncate(FileDescriptor fd, long size) throws IOException {
+        return truncate0(fd, size);
+    }
+
+    int force(FileDescriptor fd, boolean metaData) throws IOException {
+        return force0(fd, metaData);
+    }
+
+    int lock(FileDescriptor fd, boolean blocking, long pos, long size,
+             boolean shared) throws IOException
+    {
+        return lock0(fd, blocking, pos, size, shared);
+    }
+
+    void release(FileDescriptor fd, long pos, long size) throws IOException {
+        release0(fd, pos, size);
+    }
+
     // -- Native methods --
 
     static native int read0(FileDescriptor fd, long address, int len)
@@ -105,4 +132,18 @@
 
     static native void init();
 
+    static native int force0(FileDescriptor fd, boolean metaData)
+        throws IOException;
+
+    static native int truncate0(FileDescriptor fd, long size)
+        throws IOException;
+
+    static native long size0(FileDescriptor fd) throws IOException;
+
+    static native int lock0(FileDescriptor fd, boolean blocking, long pos,
+                            long size, boolean shared) throws IOException;
+
+    static native void release0(FileDescriptor fd, long pos, long size)
+        throws IOException;
+
 }
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/nio/ch/InheritedChannel.java openjdk/jdk/src/solaris/classes/sun/nio/ch/InheritedChannel.java
--- openjdk.orig/jdk/src/solaris/classes/sun/nio/ch/InheritedChannel.java	2009-02-11 23:11:51.000000000 +0000
+++ openjdk/jdk/src/solaris/classes/sun/nio/ch/InheritedChannel.java	2009-02-11 23:14:46.000000000 +0000
@@ -34,7 +34,8 @@
 import java.nio.channels.SocketChannel;
 import java.nio.channels.ServerSocketChannel;
 import java.nio.channels.DatagramChannel;
-import java.nio.channels.spi.SelectorProvider;
+
+import org.classpath.icedtea.java.nio.channels.spi.SelectorProvider;
 
 class InheritedChannel {
 
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/nio/ch/FileDispatcher.java openjdk/jdk/src/windows/classes/sun/nio/ch/FileDispatcher.java
--- openjdk.orig/jdk/src/windows/classes/sun/nio/ch/FileDispatcher.java	2009-02-11 23:11:51.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/nio/ch/FileDispatcher.java	2009-02-11 23:14:46.000000000 +0000
@@ -36,6 +36,11 @@
 class FileDispatcher extends NativeDispatcher
 {
 
+    public static final int NO_LOCK = -1;       // Failed to lock
+    public static final int LOCKED = 0;         // Obtained requested lock
+    public static final int RET_EX_LOCK = 1;    // Obtained exclusive lock
+    public static final int INTERRUPTED = 2;    // Request interrupted
+
     static {
         Util.load();
     }
@@ -78,6 +83,28 @@
         close0(fd);
     }
 
+    int force(FileDescriptor fd, boolean metaData) throws IOException {
+        return force0(fd, metaData);
+    }
+
+    int truncate(FileDescriptor fd, long size) throws IOException {
+        return truncate0(fd, size);
+    }
+
+    long size(FileDescriptor fd) throws IOException {
+        return size0(fd);
+    }
+
+    int lock(FileDescriptor fd, boolean blocking, long pos, long size,
+             boolean shared) throws IOException
+    {
+        return lock0(fd, blocking, pos, size, shared);
+    }
+
+    void release(FileDescriptor fd, long pos, long size) throws IOException {
+        release0(fd, pos, size);
+    }
+
     //-- Native methods
 
     static native int read0(FileDescriptor fd, long address, int len)
@@ -102,4 +129,17 @@
 
     static native void closeByHandle(long fd) throws IOException;
 
+    static native int force0(FileDescriptor fd, boolean metaData)
+        throws IOException;
+
+    static native int truncate0(FileDescriptor fd, long size)
+        throws IOException;
+
+    static native long size0(FileDescriptor fd) throws IOException;
+
+    static native int lock0(FileDescriptor fd, boolean blocking, long pos,
+                            long size, boolean shared) throws IOException;
+
+    static native void release0(FileDescriptor fd, long pos, long size)
+        throws IOException;
 }
