--- openjdk/hotspot/src/os/linux/vm/os_linux.cpp.orig	2008-12-03 19:33:43.000000000 +0000
+++ openjdk/hotspot/src/os/linux/vm/os_linux.cpp	2008-12-03 19:44:02.000000000 +0000
@@ -176,7 +176,9 @@
 #endif
 
 // Cpu architecture string
-#if   defined(IA64)
+#if   defined(ZERO)
+static char cpu_arch[] = ZERO_LIBARCH;
+#elif defined(IA64)
 static char cpu_arch[] = "ia64";
 #elif defined(IA32)
 static char cpu_arch[] = "i386";
@@ -1712,7 +1714,14 @@
     {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)"Sparc 32"},
     {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)"Sparc v9 64"},
     {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)"Power PC 32"},
-    {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)"Power PC 64"}
+    {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)"Power PC 64"},
+    {EM_ARM,         EM_ARM,     ELFCLASS32,   ELFDATA2LSB, (char*)"ARM"},
+    {EM_S390,        EM_S390,    ELFCLASSNONE, ELFDATA2MSB, (char*)"IBM System/390"},
+    {EM_ALPHA,       EM_ALPHA,   ELFCLASS64, ELFDATA2LSB, (char*)"Alpha"},
+    {EM_MIPS_RS3_LE, EM_MIPS_RS3_LE, ELFCLASS32, ELFDATA2LSB, (char*)"MIPSel"},
+    {EM_MIPS,        EM_MIPS,    ELFCLASS32, ELFDATA2MSB, (char*)"MIPS"},
+    {EM_PARISC,      EM_PARISC,  ELFCLASS32, ELFDATA2MSB, (char*)"HPPA"},
+    {EM_68K,         EM_68K,     ELFCLASS32, ELFDATA2MSB, (char*)"M68k"}
   };
 
   #if  (defined IA32)
@@ -1729,9 +1738,23 @@
     static  Elf32_Half running_arch_code=EM_PPC64;
   #elif  (defined __powerpc__)
     static  Elf32_Half running_arch_code=EM_PPC;
+  #elif  (defined ARM)
+    static  Elf32_Half running_arch_code=EM_ARM;
+  #elif  (defined S390)
+    static  Elf32_Half running_arch_code=EM_S390;
+  #elif  (defined ALPHA)
+    static  Elf32_Half running_arch_code=EM_ALPHA;
+  #elif  (defined MIPSEL)
+    static  Elf32_Half running_arch_code=EM_MIPS_RS3_LE;
+  #elif  (defined HPPA)
+    static  Elf32_Half running_arch_code=EM_PARISC;
+  #elif  (defined MIPS)
+    static  Elf32_Half running_arch_code=EM_MIPS;
+  #elif  (defined M68K)
+    static  Elf32_Half running_arch_code=EM_68K;
   #else
     #error Method os::dll_load requires that one of following is defined:\
-         IA32, AMD64, IA64, __sparc, __powerpc__
+         IA32, AMD64, IA64, __sparc, __powerpc__, ARM, S390, ALPHA, MIPS, MIPSEL, HPPA, M68K
   #endif
 
   // Identify compatability class for VM's architecture and library's architecture
@@ -1763,10 +1786,12 @@
     return NULL;
   }
 
+#ifndef S390
   if (lib_arch.elf_class != arch_array[running_arch_index].elf_class) {
     ::snprintf(diag_msg_buf, diag_msg_max_length-1," (Possible cause: architecture word width mismatch)");
     return NULL;
   }
+#endif // !S390
 
   if (lib_arch.compat_class != arch_array[running_arch_index].compat_class) {
     if ( lib_arch.name!=NULL ) {
@@ -2545,7 +2570,9 @@
     // format has been changed), we'll use the largest page size supported by
     // the processor.
 
+#ifndef ZERO
     _large_page_size = IA32_ONLY(4 * M) AMD64_ONLY(2 * M) IA64_ONLY(256 * M) SPARC_ONLY(4 * M);
+#endif
 
     FILE *fp = fopen("/proc/meminfo", "r");
     if (fp) {
--- openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp.orig	2008-11-20 08:41:04.000000000 +0000
+++ openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp	2008-12-03 19:40:11.000000000 +0000
@@ -3031,9 +3031,9 @@
   tty->print_cr("&native_fresult: " INTPTR_FORMAT, (uintptr_t) &this->_native_fresult);
   tty->print_cr("native_lresult: " INTPTR_FORMAT, (uintptr_t) this->_native_lresult);
 #endif
-#ifdef IA64
+#if defined(IA64) && !defined(ZERO)
   tty->print_cr("last_Java_fp: " INTPTR_FORMAT, (uintptr_t) this->_last_Java_fp);
-#endif // IA64
+#endif // IA64 && !ZERO
   tty->print_cr("self_link: " INTPTR_FORMAT, (uintptr_t) this->_self_link);
 }
 
--- openjdk/hotspot/src/share/vm/runtime/jniHandles.hpp.orig	2008-11-20 08:41:06.000000000 +0000
+++ openjdk/hotspot/src/share/vm/runtime/jniHandles.hpp	2008-12-03 19:40:11.000000000 +0000
@@ -126,9 +126,17 @@
   // Fill block with bad_handle values
   void zap();
 
+#ifdef ZERO
+ protected:
+  friend class CppInterpreter;
+#endif // ZERO
+
   // No more handles in the both the current and following blocks
   void clear() { _top = 0; }
 
+#ifdef ZERO
+ private:
+#endif // ZERO
   // Free list computation
   void rebuild_free_list();
 
--- openjdk/hotspot/src/share/vm/runtime/icache.cpp.orig	2008-11-20 08:41:06.000000000 +0000
+++ openjdk/hotspot/src/share/vm/runtime/icache.cpp	2008-12-03 19:45:03.000000000 +0000
@@ -78,6 +78,7 @@
 }
 
 void AbstractICache::invalidate_range(address start, int nbytes) {
+#ifndef ZERO
   static bool firstTime = true;
   if (firstTime) {
     guarantee(start == CAST_FROM_FN_PTR(address, _flush_icache_stub),
@@ -97,6 +98,7 @@
   }
   call_flush_stub(start, round_to(nbytes, ICache::line_size) >>
                          ICache::log2_line_size);
+#endif
 }
 
 // For init.cpp
--- openjdk/hotspot/src/share/vm/runtime/mutex.hpp.orig	2008-11-20 08:41:06.000000000 +0000
+++ openjdk/hotspot/src/share/vm/runtime/mutex.hpp	2008-12-03 19:40:11.000000000 +0000
@@ -61,18 +61,10 @@
 } ;
 
 // Endian-ness ... index of least-significant byte in SplitWord.Bytes[]
-#ifdef AMD64        // little
+#ifdef VM_LITTLE_ENDIAN
  #define _LSBINDEX 0
 #else
-#if IA32            // little
- #define _LSBINDEX 0
-#else
-#ifdef SPARC        // big
  #define _LSBINDEX (sizeof(intptr_t)-1)
-#else
- #error "unknown architecture"
-#endif
-#endif
 #endif
 
 class ParkEvent ;
--- openjdk/hotspot/src/share/vm/utilities/vmError.cpp.orig	2008-12-03 19:33:25.000000000 +0000
+++ openjdk/hotspot/src/share/vm/utilities/vmError.cpp	2008-12-03 19:40:11.000000000 +0000
@@ -25,6 +25,11 @@
 # include "incls/_precompiled.incl"
 # include "incls/_vmError.cpp.incl"
 
+# ifdef ZERO
+# include <interpreterRuntime.hpp>
+# include <stackPrinter_zero.hpp>
+# endif //
+
 // List of environment variables that should be reported in error log file.
 const char *env_list[] = {
   // All platforms
@@ -398,6 +403,7 @@
        st->cr();
      }
 
+#ifndef ZERO
   STEP(110, "(printing stack bounds)" )
 
      if (_verbose) {
@@ -455,11 +461,16 @@
           st->cr();
        }
      }
+#endif // !ZERO
 
   STEP(130, "(printing Java stack)" )
 
      if (_verbose && _thread && _thread->is_Java_thread()) {
        JavaThread* jt = (JavaThread*)_thread;
+#ifdef ZERO
+       st->print_cr("Java stack:");
+       ZeroStackPrinter(st, buf, sizeof(buf)).print(jt);
+#else
        if (jt->has_last_Java_frame()) {
          st->print_cr("Java frames: (J=compiled Java code, j=interpreted, Vv=VM code)");
          for(StackFrameStream sfs(jt); !sfs.is_done(); sfs.next()) {
@@ -467,6 +478,7 @@
            st->cr();
          }
        }
+#endif // ZERO
      }
 
   STEP(140, "(printing VM operation)" )
@@ -478,6 +490,14 @@
           op->print_on_error(st);
           st->cr();
           st->cr();
+#ifdef ZERO
+          if (op->calling_thread()->is_Java_thread()) {
+            st->print_cr("Calling thread's Java stack:");
+            ZeroStackPrinter(st, buf, sizeof(buf)).print(
+              (JavaThread *) op->calling_thread());
+            st->cr();
+          }
+#endif // ZERO
         }
      }
 
