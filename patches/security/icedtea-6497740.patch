--- old/src/share/classes/sun/security/pkcs11/P11KeyPairGenerator.java	Fri Aug 22 18:58:20 2008
+++ openjdk/jdk/src/share/classes/sun/security/pkcs11/P11KeyPairGenerator.java	Fri Aug 22 18:58:20 2008
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2003-2008 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -38,6 +38,8 @@
 import sun.security.pkcs11.wrapper.*;
 import static sun.security.pkcs11.wrapper.PKCS11Constants.*;
 
+import sun.security.rsa.RSAKeyFactory;
+
 /**
  * KeyPairGenerator implementation class. This class currently supports
  * RSA, DSA, DH, and EC.
@@ -66,7 +68,7 @@
     private AlgorithmParameterSpec params;
 
     // for RSA, selected or default value of public exponent, always valid
-    private BigInteger rsaPublicExponent;
+    private BigInteger rsaPublicExponent = RSAKeyGenParameterSpec.F4;
 
     // SecureRandom instance, if specified in init
     private SecureRandom random;
@@ -88,7 +90,7 @@
     public void initialize(int keySize, SecureRandom random) {
         token.ensureValid();
         try {
-            checkKeySize(keySize);
+            checkKeySize(keySize, null);
         } catch (InvalidAlgorithmParameterException e) {
             throw new InvalidParameterException(e.getMessage());
         }
@@ -95,12 +97,12 @@
         this.keySize = keySize;
         this.params = null;
         this.random = random;
-        this.rsaPublicExponent = RSAKeyGenParameterSpec.F4;
         if (algorithm.equals("EC")) {
             params = P11ECKeyFactory.getECParameterSpec(keySize);
             if (params == null) {
-                throw new InvalidParameterException
-                ("No EC parameters available for key size " + keySize + " bits");
+                throw new InvalidParameterException(
+                    "No EC parameters available for key size "
+                    + keySize + " bits");
             }
         }
     }
@@ -115,8 +117,10 @@
                         ("DHParameterSpec required for Diffie-Hellman");
             }
             DHParameterSpec dhParams = (DHParameterSpec)params;
-            this.keySize = dhParams.getP().bitLength();
-            this.params = params;
+            int tmpKeySize = dhParams.getP().bitLength();
+            checkKeySize(tmpKeySize, dhParams);
+            this.keySize = tmpKeySize;
+            this.params = dhParams;
             // XXX sanity check params
         } else if (algorithm.equals("RSA")) {
             if (params instanceof RSAKeyGenParameterSpec == false) {
@@ -124,7 +128,9 @@
                         ("RSAKeyGenParameterSpec required for RSA");
             }
             RSAKeyGenParameterSpec rsaParams = (RSAKeyGenParameterSpec)params;
-            this.keySize = rsaParams.getKeysize();
+            int tmpKeySize = rsaParams.getKeysize();
+            checkKeySize(tmpKeySize, rsaParams);
+            this.keySize = tmpKeySize;
             this.params = null;
             this.rsaPublicExponent = rsaParams.getPublicExponent();
             // XXX sanity check params
@@ -134,13 +140,16 @@
                         ("DSAParameterSpec required for DSA");
             }
             DSAParameterSpec dsaParams = (DSAParameterSpec)params;
-            this.keySize = dsaParams.getP().bitLength();
-            this.params = params;
+            int tmpKeySize = dsaParams.getP().bitLength();
+            checkKeySize(tmpKeySize, dsaParams);
+            this.keySize = tmpKeySize;
+            this.params = dsaParams;
             // XXX sanity check params
         } else if (algorithm.equals("EC")) {
             ECParameterSpec ecParams;
             if (params instanceof ECParameterSpec) {
-                ecParams = P11ECKeyFactory.getECParameterSpec((ECParameterSpec)params);
+                ecParams = P11ECKeyFactory.getECParameterSpec(
+                    (ECParameterSpec)params);
                 if (ecParams == null) {
                     throw new InvalidAlgorithmParameterException
                         ("Unsupported curve: " + params);
@@ -156,16 +165,17 @@
                 throw new InvalidAlgorithmParameterException
                     ("ECParameterSpec or ECGenParameterSpec required for EC");
             }
-            this.keySize = ecParams.getCurve().getField().getFieldSize();
+            int tmpKeySize = ecParams.getCurve().getField().getFieldSize();
+            checkKeySize(tmpKeySize, ecParams);
+            this.keySize = tmpKeySize;
             this.params = ecParams;
         } else {
             throw new ProviderException("Unknown algorithm: " + algorithm);
         }
         this.random = random;
-        checkKeySize(keySize);
     }
 
-    private void checkKeySize(int keySize)
+    private void checkKeySize(int keySize, AlgorithmParameterSpec params)
             throws InvalidAlgorithmParameterException {
         if (algorithm.equals("EC")) {
             if (keySize < 112) {
@@ -178,13 +188,28 @@
                     ("Key size must be at most 2048 bit");
             }
             return;
+        } else if (algorithm.equals("RSA")) {
+            BigInteger tmpExponent = rsaPublicExponent;
+            if (params != null) {
+                // Already tested for instanceof RSAKeyGenParameterSpec above
+                tmpExponent =
+                    ((RSAKeyGenParameterSpec)params).getPublicExponent();
+            }
+            try {
+                // This provider supports 64K or less.
+                RSAKeyFactory.checkKeyLengths(keySize, tmpExponent,
+                    512, 64 * 1024);
+            } catch (InvalidKeyException e) {
+                throw new InvalidAlgorithmParameterException(e.getMessage());
+            }
+            return;
         }
+
         if (keySize < 512) {
             throw new InvalidAlgorithmParameterException
                 ("Key size must be at least 512 bit");
         }
-        if (algorithm.equals("RSA") ||
-                (algorithm.equals("DH") && (params != null))) {
+        if (algorithm.equals("DH") && (params != null)) {
             // sanity check, nobody really wants keys this large
             if (keySize > 64 * 1024) {
                 throw new InvalidAlgorithmParameterException
--- old/src/share/classes/sun/security/pkcs11/P11KeyStore.java	Fri Aug 22 18:58:29 2008
+++ openjdk/jdk/src/share/classes/sun/security/pkcs11/P11KeyStore.java	Fri Aug 22 18:58:29 2008
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2003-2008 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -80,6 +80,8 @@
 import sun.security.pkcs11.wrapper.*;
 import static sun.security.pkcs11.wrapper.PKCS11Constants.*;
 
+import sun.security.rsa.RSAKeyFactory;
+
 final class P11KeyStore extends KeyStoreSpi {
 
     private static final CK_ATTRIBUTE ATTR_CLASS_CERT =
@@ -1335,6 +1337,15 @@
             BigInteger modulus = attrs[0].getBigInteger();
             keyLength = modulus.bitLength();
 
+            // This check will combine our "don't care" values here
+            // with the system-wide min/max values.
+            try {
+                RSAKeyFactory.checkKeyLengths(keyLength, null,
+                    -1, Integer.MAX_VALUE);
+            } catch (InvalidKeyException e) {
+                throw new KeyStoreException(e.getMessage());
+            }
+
             return P11Key.privateKey(session,
                                 oHandle,
                                 keyType,
--- old/src/share/classes/sun/security/pkcs11/P11RSAKeyFactory.java	Fri Aug 22 18:58:37 2008
+++ openjdk/jdk/src/share/classes/sun/security/pkcs11/P11RSAKeyFactory.java	Fri Aug 22 18:58:37 2008
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2003-2008 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -35,6 +35,8 @@
 import sun.security.pkcs11.wrapper.*;
 import static sun.security.pkcs11.wrapper.PKCS11Constants.*;
 
+import sun.security.rsa.RSAKeyFactory;
+
 /**
  * RSA KeyFactory implemenation.
  *
@@ -131,6 +133,9 @@
         } catch (PKCS11Exception e) {
             throw new InvalidKeySpecException
                 ("Could not create RSA public key", e);
+        } catch (InvalidKeyException e) {
+            throw new InvalidKeySpecException
+                ("Could not create RSA public key", e);
         }
     }
 
@@ -175,11 +180,15 @@
         } catch (PKCS11Exception e) {
             throw new InvalidKeySpecException
                 ("Could not create RSA private key", e);
+        } catch (InvalidKeyException e) {
+            throw new InvalidKeySpecException
+                ("Could not create RSA private key", e);
         }
     }
 
     private PublicKey generatePublic(BigInteger n, BigInteger e)
-            throws PKCS11Exception {
+            throws PKCS11Exception, InvalidKeyException {
+        RSAKeyFactory.checkKeyLengths(n.bitLength(), e, -1, 64 * 1024);
         CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {
             new CK_ATTRIBUTE(CKA_CLASS, CKO_PUBLIC_KEY),
             new CK_ATTRIBUTE(CKA_KEY_TYPE, CKK_RSA),
@@ -200,7 +209,8 @@
     }
 
     private PrivateKey generatePrivate(BigInteger n, BigInteger d)
-            throws PKCS11Exception {
+            throws PKCS11Exception, InvalidKeyException {
+        RSAKeyFactory.checkKeyLengths(n.bitLength(), null, -1, 64 * 1024);
         CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {
             new CK_ATTRIBUTE(CKA_CLASS, CKO_PRIVATE_KEY),
             new CK_ATTRIBUTE(CKA_KEY_TYPE, CKK_RSA),
@@ -222,7 +232,9 @@
 
     private PrivateKey generatePrivate(BigInteger n, BigInteger e,
             BigInteger d, BigInteger p, BigInteger q, BigInteger pe,
-            BigInteger qe, BigInteger coeff) throws PKCS11Exception {
+            BigInteger qe, BigInteger coeff) throws PKCS11Exception,
+            InvalidKeyException {
+        RSAKeyFactory.checkKeyLengths(n.bitLength(), e, -1, 64 * 1024);
         CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {
             new CK_ATTRIBUTE(CKA_CLASS, CKO_PRIVATE_KEY),
             new CK_ATTRIBUTE(CKA_KEY_TYPE, CKK_RSA),
--- old/src/share/classes/sun/security/rsa/RSAKeyFactory.java	Fri Aug 22 18:58:44 2008
+++ openjdk/jdk/src/share/classes/sun/security/rsa/RSAKeyFactory.java	Fri Aug 22 18:58:43 2008
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2003-2008 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,6 +31,8 @@
 import java.security.interfaces.*;
 import java.security.spec.*;
 
+import sun.security.action.GetPropertyAction;
+
 /**
  * KeyFactory for RSA keys. Keys must be instances of PublicKey or PrivateKey
  * and getAlgorithm() must return "RSA". For such keys, it supports conversion
@@ -68,6 +70,24 @@
     private final static Class<?> x509KeySpecClass  = X509EncodedKeySpec.class;
     private final static Class<?> pkcs8KeySpecClass = PKCS8EncodedKeySpec.class;
 
+    public final static int MIN_MODLEN = 512;
+    public final static int MAX_MODLEN = 16384;
+
+    /*
+     * If the modulus length is above this value, restrict the size of
+     * the exponent to something that can be reasonably computed.  We
+     * could simply hardcode the exp len to something like 64 bits, but
+     * this approach allows flexibility in case impls would like to use
+     * larger module and exponent values.
+     */
+    public final static int MAX_MODLEN_RESTRICT_EXP = 3072;
+    public final static int MAX_RESTRICTED_EXPLEN = 64;
+
+    private static final boolean restrictExpLen =
+        "true".equalsIgnoreCase(AccessController.doPrivileged(
+            new GetPropertyAction(
+                "sun.security.rsa.restrictRSAExponent", "true")));
+
     // instance used for static translateKey();
     private final static RSAKeyFactory INSTANCE = new RSAKeyFactory();
 
@@ -76,75 +96,80 @@
     }
 
     /**
-     * Static method to convert Key into a useable instance of
-     * RSAPublicKey or RSAPrivate(Crt)Key. Check the key and convert it
-     * to a SunRsaSign key if necessary. If the key is not an RSA key
-     * or cannot be used, throw an InvalidKeyException.
+     * Static method to convert Key into an instance of RSAPublicKeyImpl
+     * or RSAPrivate(Crt)KeyImpl. If the key is not an RSA key or cannot be
+     * used, throw an InvalidKeyException.
      *
-     * The difference between this method and engineTranslateKey() is that
-     * we do not convert keys of other providers that are already an
-     * instance of RSAPublicKey or RSAPrivate(Crt)Key.
-     *
      * Used by RSASignature and RSACipher.
      */
     public static RSAKey toRSAKey(Key key) throws InvalidKeyException {
-        if (key instanceof RSAKey) {
-            RSAKey rsaKey = (RSAKey)key;
-            checkKey(rsaKey);
-            return rsaKey;
+        if ((key instanceof RSAPrivateKeyImpl) ||
+            (key instanceof RSAPrivateCrtKeyImpl) ||
+            (key instanceof RSAPublicKeyImpl)) {
+            return (RSAKey)key;
         } else {
             return (RSAKey)INSTANCE.engineTranslateKey(key);
         }
     }
 
-    /**
-     * Check that the given RSA key is valid.
+    /*
+     * Single test entry point for all of the mechanisms in the SunRsaSign
+     * provider (RSA*KeyImpls).  All of the tests are the same.
+     *
+     * For compatibility, we round up to the nearest byte here:
+     * some Key impls might pass in a value within a byte of the
+     * real value.
      */
-    private static void checkKey(RSAKey key) throws InvalidKeyException {
-        // check for subinterfaces, omit additional checks for our keys
-        if (key instanceof RSAPublicKey) {
-            if (key instanceof RSAPublicKeyImpl) {
-                return;
-            }
-        } else if (key instanceof RSAPrivateKey) {
-            if ((key instanceof RSAPrivateCrtKeyImpl)
-                    || (key instanceof RSAPrivateKeyImpl)) {
-                return;
-            }
-        } else {
-            throw new InvalidKeyException("Neither a public nor a private key");
-        }
-        // RSAKey does not extend Key, so we need to do a cast
-        String keyAlg = ((Key)key).getAlgorithm();
-        if (keyAlg.equals("RSA") == false) {
-            throw new InvalidKeyException("Not an RSA key: " + keyAlg);
-        }
-        BigInteger modulus;
-        // some providers implement RSAKey for keys where the values are
-        // not accessible (although they should). Detect those here
-        // for a more graceful failure.
-        try {
-            modulus = key.getModulus();
-            if (modulus == null) {
-                throw new InvalidKeyException("Modulus is missing");
-            }
-        } catch (RuntimeException e) {
-            throw new InvalidKeyException(e);
-        }
-        checkKeyLength(modulus);
+    static void checkRSAProviderKeyLengths(int modulusLen, BigInteger exponent)
+            throws InvalidKeyException {
+        checkKeyLengths(((modulusLen + 7) & ~7), exponent,
+            RSAKeyFactory.MIN_MODLEN, Integer.MAX_VALUE);
     }
 
     /**
-     * Check the length of the modulus of an RSA key. We only support keys
-     * at least 505 bits long.
+     * Check the length of an RSA key modulus/exponent to make sure it
+     * is not too short or long.  Some impls have their own min and
+     * max key sizes that may or may not match with a system defined value.
+     *
+     * @param modulusLen the bit length of the RSA modulus.
+     * @param exponent the RSA exponent
+     * @param minModulusLen if > 0, check to see if modulusLen is at
+     *        least this long, otherwise unused.
+     * @param maxModulusLen caller will allow this max number of bits.
+     *        Allow the smaller of the system-defined maximum and this param.
+     *
+     * @throws InvalidKeyException if any of the values are unacceptable.
      */
-    static void checkKeyLength(BigInteger modulus) throws InvalidKeyException {
-        if (modulus.bitLength() < 505) {
-            // some providers may generate slightly shorter keys
-            // accept them if the encoding is at least 64 bytes long
-            throw new InvalidKeyException
-                ("RSA keys must be at least 512 bits long");
+     public static void checkKeyLengths(int modulusLen, BigInteger exponent,
+            int minModulusLen, int maxModulusLen) throws InvalidKeyException {
+
+        if ((minModulusLen > 0) && (modulusLen < (minModulusLen))) {
+            throw new InvalidKeyException( "RSA keys must be at least " +
+                minModulusLen + " bits long");
         }
+
+        // Even though our policy file may allow this, we don't want
+        // either value (mod/exp) to be too big.
+
+        int maxLen = Math.min(maxModulusLen, MAX_MODLEN);
+
+        // If a RSAPrivateKey/RSAPublicKey, make sure the
+        // modulus len isn't too big.
+        if (modulusLen > maxLen) {
+            throw new InvalidKeyException(
+                "RSA keys must be no longer than " + maxLen + " bits");
+        }
+
+        // If a RSAPublicKey, make sure the exponent isn't too big.
+        if (restrictExpLen && (exponent != null) &&
+                (modulusLen > MAX_MODLEN_RESTRICT_EXP) &&
+                (exponent.bitLength() > MAX_RESTRICTED_EXPLEN)) {
+            throw new InvalidKeyException(
+                "RSA exponents can be no longer than " +
+                MAX_RESTRICTED_EXPLEN + " bits " +
+                " if modulus is greater than " +
+                MAX_MODLEN_RESTRICT_EXP + " bits");
+        }
     }
 
     /**
--- old/src/share/classes/sun/security/rsa/RSAKeyPairGenerator.java	Fri Aug 22 18:58:50 2008
+++ openjdk/jdk/src/share/classes/sun/security/rsa/RSAKeyPairGenerator.java	Fri Aug 22 18:58:49 2008
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2004 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2003-2008 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -47,7 +47,7 @@
     // public exponent to use
     private BigInteger publicExponent;
 
-    // size of the key to generate, >= 512
+    // size of the key to generate, >= RSAKeyFactory.MIN_MODLEN
     private int keySize;
 
     // PRNG to use
@@ -60,15 +60,16 @@
 
     // initialize the generator. See JCA doc
     public void initialize(int keySize, SecureRandom random) {
-        if (keySize < 512) {
-            throw new InvalidParameterException
-                ("Key size must be at least 512 bits");
+
+        // do not allow unreasonably small or large key sizes,
+        // probably user error
+        try {
+            RSAKeyFactory.checkKeyLengths(keySize, RSAKeyGenParameterSpec.F4,
+                512, 64 * 1024);
+        } catch (InvalidKeyException e) {
+            throw new InvalidParameterException(e.getMessage());
         }
-        if (keySize > 64 * 1024) {
-            // do not allow unreasonably large key sizes, probably user error
-            throw new InvalidParameterException
-                ("Key size must be 65536 bits or less");
-        }
+
         this.keySize = keySize;
         this.random = random;
         this.publicExponent = RSAKeyGenParameterSpec.F4;
@@ -77,35 +78,41 @@
     // second initialize method. See JCA doc.
     public void initialize(AlgorithmParameterSpec params, SecureRandom random)
             throws InvalidAlgorithmParameterException {
+
         if (params instanceof RSAKeyGenParameterSpec == false) {
             throw new InvalidAlgorithmParameterException
                 ("Params must be instance of RSAKeyGenParameterSpec");
         }
+
         RSAKeyGenParameterSpec rsaSpec = (RSAKeyGenParameterSpec)params;
-        keySize = rsaSpec.getKeysize();
-        publicExponent = rsaSpec.getPublicExponent();
-        this.random = random;
-        if (keySize < 512) {
-            throw new InvalidAlgorithmParameterException
-                ("Key size must be at least 512 bits");
-        }
-        if (keySize > 64 * 1024) {
-            // do not allow unreasonably large key sizes, probably user error
-            throw new InvalidAlgorithmParameterException
-                ("Key size must be 65536 bits or less");
-        }
-        if (publicExponent == null) {
-            publicExponent = RSAKeyGenParameterSpec.F4;
+        int tmpKeySize = rsaSpec.getKeysize();
+        BigInteger tmpPublicExponent = rsaSpec.getPublicExponent();
+
+        if (tmpPublicExponent == null) {
+            tmpPublicExponent = RSAKeyGenParameterSpec.F4;
         } else {
-            if (publicExponent.compareTo(RSAKeyGenParameterSpec.F0) < 0) {
+            if (tmpPublicExponent.compareTo(RSAKeyGenParameterSpec.F0) < 0) {
                 throw new InvalidAlgorithmParameterException
                         ("Public exponent must be 3 or larger");
             }
-            if (publicExponent.bitLength() > keySize) {
+            if (tmpPublicExponent.bitLength() > tmpKeySize) {
                 throw new InvalidAlgorithmParameterException
                         ("Public exponent must be smaller than key size");
             }
         }
+
+        // do not allow unreasonably large key sizes, probably user error
+        try {
+            RSAKeyFactory.checkKeyLengths(tmpKeySize, tmpPublicExponent,
+                512, 64 * 1024);
+        } catch (InvalidKeyException e) {
+            throw new InvalidAlgorithmParameterException(
+                "Invalid key sizes", e);
+        }
+
+        this.keySize = tmpKeySize;
+        this.publicExponent = tmpPublicExponent;
+        this.random = random;
     }
 
     // generate the keypair. See JCA doc
--- old/src/share/classes/sun/security/rsa/RSAPrivateCrtKeyImpl.java	Fri Aug 22 18:58:56 2008
+++ openjdk/jdk/src/share/classes/sun/security/rsa/RSAPrivateCrtKeyImpl.java	Fri Aug 22 18:58:56 2008

@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2003-2008 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -89,7 +89,7 @@
      */
     RSAPrivateCrtKeyImpl(byte[] encoded) throws InvalidKeyException {
         decode(encoded);
-        RSAKeyFactory.checkKeyLength(n);
+        RSAKeyFactory.checkRSAProviderKeyLengths(n.bitLength(), e);
     }
 
     /**
@@ -107,7 +107,8 @@
         this.pe = pe;
         this.qe = qe;
         this.coeff = coeff;
-        RSAKeyFactory.checkKeyLength(n);
+        RSAKeyFactory.checkRSAProviderKeyLengths(n.bitLength(), e);
+
         // generate the encoding
         algid = rsaId;
         try {
--- old/src/share/classes/sun/security/rsa/RSAPrivateKeyImpl.java	Fri Aug 22 18:59:02 2008
+++ openjdk/jdk/src/share/classes/sun/security/rsa/RSAPrivateKeyImpl.java	Fri Aug 22 18:59:01 2008
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2003-2008 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -61,7 +61,7 @@
     RSAPrivateKeyImpl(BigInteger n, BigInteger d) throws InvalidKeyException {
         this.n = n;
         this.d = d;
-        RSAKeyFactory.checkKeyLength(n);
+        RSAKeyFactory.checkRSAProviderKeyLengths(n.bitLength(), null);
         // generate the encoding
         algid = RSAPrivateCrtKeyImpl.rsaId;
         try {
--- old/src/share/classes/sun/security/rsa/RSAPublicKeyImpl.java	Fri Aug 22 18:59:07 2008
+++ openjdk/jdk/src/share/classes/sun/security/rsa/RSAPublicKeyImpl.java	Fri Aug 22 18:59:07 2008
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2003-2008 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -56,10 +56,11 @@
      * Construct a key from its components. Used by the
      * RSAKeyFactory and the RSAKeyPairGenerator.
      */
-    public RSAPublicKeyImpl(BigInteger n, BigInteger e) throws InvalidKeyException {
+    public RSAPublicKeyImpl(BigInteger n, BigInteger e)
+            throws InvalidKeyException {
         this.n = n;
         this.e = e;
-        RSAKeyFactory.checkKeyLength(n);
+        RSAKeyFactory.checkRSAProviderKeyLengths(n.bitLength(), e);
         // generate the encoding
         algid = RSAPrivateCrtKeyImpl.rsaId;
         try {
@@ -80,7 +81,7 @@
      */
     public RSAPublicKeyImpl(byte[] encoded) throws InvalidKeyException {
         decode(encoded);
-        RSAKeyFactory.checkKeyLength(n);
+        RSAKeyFactory.checkRSAProviderKeyLengths(n.bitLength(), e);
     }
 
     // see JCA doc
--- old/src/windows/classes/sun/security/mscapi/RSAKeyPairGenerator.java	Fri Aug 22 18:59:11 2008
+++ openjdk/jdk/src/windows/classes/sun/security/mscapi/RSAKeyPairGenerator.java	Fri Aug 22 18:59:11 2008
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2005-2008 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,6 +31,7 @@
 import java.security.spec.RSAKeyGenParameterSpec;
 
 import sun.security.jca.JCAUtil;
+import sun.security.rsa.RSAKeyFactory;
 
 /**
  * RSA keypair generator.
@@ -43,8 +44,8 @@
 public final class RSAKeyPairGenerator extends KeyPairGeneratorSpi {
 
     // Supported by Microsoft Base, Strong and Enhanced Cryptographic Providers
-    private static final int KEY_SIZE_MIN = 512; // disallow MSCAPI min. of 384
-    private static final int KEY_SIZE_MAX = 16384;
+    static final int KEY_SIZE_MIN = 512; // disallow MSCAPI min. of 384
+    static final int KEY_SIZE_MAX = 16384;
     private static final int KEY_SIZE_DEFAULT = 1024;
 
     // size of the key to generate, KEY_SIZE_MIN <= keySize <= KEY_SIZE_MAX
@@ -59,7 +60,14 @@
     // random is always ignored
     public void initialize(int keySize, SecureRandom random) {
 
-        checkKeySize(keySize);
+        try {
+            RSAKeyFactory.checkKeyLengths(keySize, null,
+                KEY_SIZE_MIN, KEY_SIZE_MAX);
+        } catch (InvalidKeyException e) {
+            throw new InvalidParameterException(e.getMessage());
+        }
+
+        this.keySize = keySize;
     }
 
     // second initialize method. See JCA doc
@@ -67,9 +75,9 @@
     public void initialize(AlgorithmParameterSpec params, SecureRandom random)
             throws InvalidAlgorithmParameterException {
 
+        int tmpSize;
         if (params == null) {
-            checkKeySize(KEY_SIZE_DEFAULT);
-
+            tmpSize = KEY_SIZE_DEFAULT;
         } else if (params instanceof RSAKeyGenParameterSpec) {
 
             if (((RSAKeyGenParameterSpec) params).getPublicExponent() != null) {
@@ -76,12 +84,22 @@
                 throw new InvalidAlgorithmParameterException
                     ("Exponent parameter is not supported");
             }
-            checkKeySize(((RSAKeyGenParameterSpec) params).getKeysize());
+            tmpSize = ((RSAKeyGenParameterSpec) params).getKeysize();
 
         } else {
             throw new InvalidAlgorithmParameterException
                 ("Params must be an instance of RSAKeyGenParameterSpec");
         }
+
+        try {
+            RSAKeyFactory.checkKeyLengths(tmpSize, null,
+                KEY_SIZE_MIN, KEY_SIZE_MAX);
+        } catch (InvalidKeyException e) {
+            throw new InvalidAlgorithmParameterException(
+                "Invalid Key sizes", e);
+        }
+
+        this.keySize = tmpSize;
     }
 
     // generate the keypair. See JCA doc
@@ -95,18 +113,6 @@
         return new KeyPair(keys.getPublic(), keys.getPrivate());
     }
 
-    private void checkKeySize(int keySize) throws InvalidParameterException {
-        if (keySize < KEY_SIZE_MIN) {
-            throw new InvalidParameterException
-                ("Key size must be at least " + KEY_SIZE_MIN + " bits");
-        }
-        if (keySize > KEY_SIZE_MAX) {
-            throw new InvalidParameterException
-                ("Key size must be " + KEY_SIZE_MAX + " bits or less");
-        }
-        this.keySize = keySize;
-    }
-
     private static native RSAKeyPair generateRSAKeyPair(int keySize,
         String keyContainerName);
 }
--- old/src/windows/classes/sun/security/mscapi/RSASignature.java	Fri Aug 22 18:59:18 2008
+++ openjdk/jdk/src/windows/classes/sun/security/mscapi/RSASignature.java	Fri Aug 22 18:59:17 2008
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2005-2008 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -38,7 +38,10 @@
 import java.security.Signature;
 import java.security.SignatureSpi;
 import java.security.SignatureException;
+import java.math.BigInteger;
 
+import sun.security.rsa.RSAKeyFactory;
+
 /**
  * RSA signature implementation. Supports RSA signing using PKCS#1 v1.5 padding.
  *
@@ -124,8 +127,17 @@
 
             // convert key to MSCAPI format
 
-            byte[] modulusBytes = rsaKey.getModulus().toByteArray();
+            BigInteger modulus = rsaKey.getModulus();
+            BigInteger exponent =  rsaKey.getPublicExponent();
 
+            // Check against the local and global values to make sure
+            // the sizes are ok.  Round up to the nearest byte.
+            RSAKeyFactory.checkKeyLengths(((modulus.bitLength() + 7) & ~7),
+                exponent, -1, RSAKeyPairGenerator.KEY_SIZE_MAX);
+
+            byte[] modulusBytes = modulus.toByteArray();
+            byte[] exponentBytes = exponent.toByteArray();
+
             // Adjust key length due to sign bit
             int keyBitLength = (modulusBytes[0] == 0)
                 ? (modulusBytes.length - 1) * 8
@@ -132,8 +144,7 @@
                 : modulusBytes.length * 8;
 
             byte[] keyBlob = generatePublicKeyBlob(
-                keyBitLength, modulusBytes,
-                rsaKey.getPublicExponent().toByteArray());
+                keyBitLength, modulusBytes, exponentBytes);
 
             publicKey = importPublicKey(keyBlob, keyBitLength);
 
@@ -166,13 +177,12 @@
         }
         privateKey = (sun.security.mscapi.RSAPrivateKey) key;
 
-        // Determine byte length from bit length
-        int keySize = (privateKey.bitLength() + 7) >> 3;
+        // Check against the local and global values to make sure
+        // the sizes are ok.  Round up to nearest byte.
+        RSAKeyFactory.checkKeyLengths(((privateKey.bitLength() + 7) & ~7),
+            null, RSAKeyPairGenerator.KEY_SIZE_MIN,
+            RSAKeyPairGenerator.KEY_SIZE_MAX);
 
-        if (keySize < 64)
-            throw new InvalidKeyException(
-                "RSA keys must be at least 512 bits long");
-
         if (needsReset) {
             messageDigest.reset();
             needsReset = false;
--- /dev/null	Fri Aug 22 18:59:23 2008
+++ openjdk/jdk/test/closed/sun/security/rsa/TestLimits.java	Fri Aug 22 18:59:22 2008
@@ -0,0 +1,772 @@
+/**
+ * @test
+ * @bug 6497740
+ * @summary Limit the size of RSA public keys
+ * @author Brad R. Wetmore
+ */
+
+/**
+ * Test the long RSA key restrictions.
+ *
+ * In many of the tests, I am not creating valid key or keyspecs,
+ * because they would take too long to generate, especially for the longer
+ * ones.  Instead I'm just using values that will trigger the appropriate
+ * checks.
+ *
+ * This test uses two prebuilt keystores, one containing a 16385 bit key,
+ * which would take forever to generate during automatic testing.
+ *
+ * keytool -genkeypair -alias duke1 -keyalg RSA -keysize 1024 \
+ *     -validity 3650 -keystore keystore.good
+ *
+ * keytool -genkeypair -alias duke1 -keyalg RSA -keysize 16385 \
+ *     -validity 3650 -keystore keystore.bad
+ */
+
+import java.math.BigInteger;
+import java.util.Random;
+import java.security.*;
+import java.security.spec.*;
+import java.security.interfaces.*;
+import java.io.*;
+
+// Obtain the current length values.
+import sun.security.rsa.RSAKeyFactory;
+
+public class TestLimits {
+
+    private final static String BASE = System.getProperty("test.src", ".");
+
+    private static SecureRandom random = new SecureRandom();
+
+    private static final String SunRSA = "SunRsaSign";
+    private static final String MSCAPI = "SunMSCAPI";
+    private static final String P11 = "SunPKCS11-Solaris";
+
+    /*
+     * Helper method which generates simple keys of length len.
+     */
+    private static BigInteger getBigInteger(int len) {
+        return BigInteger.ZERO.setBit(len - 1);
+    }
+
+    /*
+     * Tests the RSAKeyPairGenerator.initialize(len) returns
+     * the right results.
+     */
+    private static void testRSAKeyPairGeneratorLen(String provider, boolean b,
+            int len) throws Exception {
+
+        System.out.println("testRSAKeyPairGeneratorLen.initialize: " +
+            len + " " + b + " " + provider);
+
+        KeyPairGenerator kpg =
+            KeyPairGenerator.getInstance("RSA", provider);
+        try {
+            kpg.initialize(len);
+            if (!b) {
+                throw new Exception("Should have failed");
+            }
+        } catch (InvalidParameterException e) {
+            if (b) {
+                throw new Exception("Should have passed", e);
+            }
+        }
+        kpg = KeyPairGenerator.getInstance("RSA", provider);
+        try {
+            kpg.initialize(len, random);
+            if (!b) {
+                throw new Exception("Should have failed");
+            }
+        } catch (InvalidParameterException e) {
+            if (b) {
+                throw new Exception("Should have passed", e);
+            }
+        }
+    }
+
+    /*
+     * Tests the RSAKeyPairGenerator.initialize(KeySpec) returns
+     * the right results.  If expLen > 0, then create a
+     * corresponding value, otherwise, leave null.
+     */
+    private static void testRSAKeyPairGeneratorSpec(String provider,
+            boolean b, int modLen, int expLen) throws Exception {
+
+        System.out.println(
+            "testRSAKeyPairGeneratorSpec.initialize: " +
+            modLen + " " + expLen + " " + b + " " + provider);
+
+        RSAKeyGenParameterSpec keySpec = new RSAKeyGenParameterSpec(
+            modLen, (expLen > 0) ? getBigInteger(expLen) : null);
+
+        KeyPairGenerator kpg =
+            KeyPairGenerator.getInstance("RSA", provider);
+        try {
+            kpg.initialize(keySpec);
+            if (!b) {
+                throw new Exception("Should have failed");
+            }
+        } catch (InvalidParameterException e) {
+            if (b) {
+                throw new Exception("Should have passed", e);
+            }
+        } catch (InvalidAlgorithmParameterException e) {
+            if (b) {
+                throw new Exception("Should have passed", e);
+            }
+        }
+        kpg = KeyPairGenerator.getInstance("RSA", provider);
+        try {
+            kpg.initialize(keySpec, random);
+            if (!b) {
+                throw new Exception("Should have failed");
+            }
+        } catch (InvalidParameterException e) {
+            if (b) {
+                throw new Exception("Should have passed", e);
+            }
+        } catch (InvalidAlgorithmParameterException e) {
+            if (b) {
+                throw new Exception("Should have passed", e);
+            }
+        }
+    }
+
+    /*
+     * Driver for the above two tests.  Tests most of the cases.
+     * Other tests below are subsets of this.
+     */
+    private static void testRSAKeyPairGenerator() throws Exception {
+
+        // Start with the small, medium, and large modulus values only.
+        testRSAKeyPairGeneratorLen(SunRSA, false,
+            RSAKeyFactory.MIN_MODLEN - 1);
+        testRSAKeyPairGeneratorLen(SunRSA, true,
+            RSAKeyFactory.MIN_MODLEN);
+        testRSAKeyPairGeneratorLen(SunRSA, true,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP);
+        testRSAKeyPairGeneratorLen(SunRSA, true,
+            RSAKeyFactory.MAX_MODLEN);
+        testRSAKeyPairGeneratorLen(SunRSA, false,
+            RSAKeyFactory.MAX_MODLEN + 1);
+
+        testRSAKeyPairGeneratorSpec(SunRSA, false,
+            2048, 2049);
+        testRSAKeyPairGeneratorSpec(SunRSA, false,
+            RSAKeyFactory.MIN_MODLEN - 1, -1);
+        testRSAKeyPairGeneratorSpec(SunRSA, false,
+            RSAKeyFactory.MIN_MODLEN - 1,
+            RSAKeyGenParameterSpec.F0.intValue() - 1);
+        testRSAKeyPairGeneratorSpec(SunRSA, false,
+            RSAKeyFactory.MIN_MODLEN - 1,
+            RSAKeyGenParameterSpec.F0.intValue());
+        testRSAKeyPairGeneratorSpec(SunRSA, false,
+            RSAKeyFactory.MIN_MODLEN - 1,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN);
+        testRSAKeyPairGeneratorSpec(SunRSA, false,
+            RSAKeyFactory.MIN_MODLEN - 1,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1);
+
+        testRSAKeyPairGeneratorSpec(SunRSA, true,
+            RSAKeyFactory.MIN_MODLEN, -1);
+        testRSAKeyPairGeneratorSpec(SunRSA, false,
+            RSAKeyFactory.MIN_MODLEN,
+            RSAKeyGenParameterSpec.F0.intValue() - 1);
+        testRSAKeyPairGeneratorSpec(SunRSA, true,
+            RSAKeyFactory.MIN_MODLEN,
+            RSAKeyGenParameterSpec.F0.intValue());
+        testRSAKeyPairGeneratorSpec(SunRSA, true,
+            RSAKeyFactory.MIN_MODLEN,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN);
+        testRSAKeyPairGeneratorSpec(SunRSA, true,
+            RSAKeyFactory.MIN_MODLEN,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1);
+
+        testRSAKeyPairGeneratorSpec(SunRSA, true,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP, -1);
+        testRSAKeyPairGeneratorSpec(SunRSA, false,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP,
+            RSAKeyGenParameterSpec.F0.intValue() - 1);
+        testRSAKeyPairGeneratorSpec(SunRSA, true,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP,
+            RSAKeyGenParameterSpec.F0.intValue());
+        testRSAKeyPairGeneratorSpec(SunRSA, true,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN);
+        testRSAKeyPairGeneratorSpec(SunRSA, true,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1);
+
+        testRSAKeyPairGeneratorSpec(SunRSA, true,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP + 1,
+            -1);
+        testRSAKeyPairGeneratorSpec(SunRSA, false,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP + 1,
+            RSAKeyGenParameterSpec.F0.intValue() - 1);
+        testRSAKeyPairGeneratorSpec(SunRSA, true,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP + 1,
+            RSAKeyGenParameterSpec.F0.intValue());
+        testRSAKeyPairGeneratorSpec(SunRSA, true,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP + 1,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN);
+        testRSAKeyPairGeneratorSpec(SunRSA, false,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP + 1,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1);
+
+        testRSAKeyPairGeneratorSpec(SunRSA, true,
+            RSAKeyFactory.MAX_MODLEN,
+            -1);
+        testRSAKeyPairGeneratorSpec(SunRSA, false,
+            RSAKeyFactory.MAX_MODLEN,
+            RSAKeyGenParameterSpec.F0.intValue() - 1);
+        testRSAKeyPairGeneratorSpec(SunRSA, true,
+            RSAKeyFactory.MAX_MODLEN,
+            RSAKeyGenParameterSpec.F0.intValue());
+        testRSAKeyPairGeneratorSpec(SunRSA, true,
+            RSAKeyFactory.MAX_MODLEN,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN);
+        testRSAKeyPairGeneratorSpec(SunRSA, false,
+            RSAKeyFactory.MAX_MODLEN,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1);
+
+        testRSAKeyPairGeneratorSpec(SunRSA, false,
+            RSAKeyFactory.MAX_MODLEN + 1,
+            -1);
+        testRSAKeyPairGeneratorSpec(SunRSA, false,
+            RSAKeyFactory.MAX_MODLEN + 1,
+            RSAKeyGenParameterSpec.F0.intValue() - 1);
+        testRSAKeyPairGeneratorSpec(SunRSA, false,
+            RSAKeyFactory.MAX_MODLEN + 1,
+            RSAKeyGenParameterSpec.F0.intValue());
+        testRSAKeyPairGeneratorSpec(SunRSA, false,
+            RSAKeyFactory.MAX_MODLEN + 1,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN);
+        testRSAKeyPairGeneratorSpec(SunRSA, false,
+            RSAKeyFactory.MAX_MODLEN + 1,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1);
+    }
+
+    /*
+     * Driver for the above two tests.  Tests most of the cases.
+     * Other tests below are subsets of this.
+     */
+    private static void testP11KeyPairGenerator() throws Exception {
+
+        // Start with the small, medium, and large modulus values only.
+        testRSAKeyPairGeneratorLen(P11, false,
+            RSAKeyFactory.MIN_MODLEN - 1);
+        testRSAKeyPairGeneratorLen(P11, true,
+            RSAKeyFactory.MIN_MODLEN);
+        testRSAKeyPairGeneratorLen(P11, true,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP);
+        testRSAKeyPairGeneratorLen(P11, true,
+            RSAKeyFactory.MAX_MODLEN);
+        testRSAKeyPairGeneratorLen(P11, false,
+            RSAKeyFactory.MAX_MODLEN + 1);
+
+        testRSAKeyPairGeneratorSpec(P11, false,
+            RSAKeyFactory.MIN_MODLEN - 1, -1);
+        testRSAKeyPairGeneratorSpec(P11, false,
+            RSAKeyFactory.MIN_MODLEN - 1,
+            RSAKeyGenParameterSpec.F0.intValue() - 1);
+        testRSAKeyPairGeneratorSpec(P11, false,
+            RSAKeyFactory.MIN_MODLEN - 1,
+            RSAKeyGenParameterSpec.F0.intValue());
+        testRSAKeyPairGeneratorSpec(P11, false,
+            RSAKeyFactory.MIN_MODLEN - 1,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN);
+        testRSAKeyPairGeneratorSpec(P11, false,
+            RSAKeyFactory.MIN_MODLEN - 1,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1);
+
+        testRSAKeyPairGeneratorSpec(P11, true,
+            RSAKeyFactory.MIN_MODLEN, -1);
+        testRSAKeyPairGeneratorSpec(P11, true,
+            RSAKeyFactory.MIN_MODLEN,
+            RSAKeyGenParameterSpec.F0.intValue());
+        testRSAKeyPairGeneratorSpec(P11, true,
+            RSAKeyFactory.MIN_MODLEN,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN);
+        testRSAKeyPairGeneratorSpec(P11, true,
+            RSAKeyFactory.MIN_MODLEN,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1);
+
+        testRSAKeyPairGeneratorSpec(P11, true,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP, -1);
+        testRSAKeyPairGeneratorSpec(P11, true,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP,
+            RSAKeyGenParameterSpec.F0.intValue());
+        testRSAKeyPairGeneratorSpec(P11, true,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN);
+        testRSAKeyPairGeneratorSpec(P11, true,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1);
+
+        testRSAKeyPairGeneratorSpec(P11, true,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP + 1, -1);
+        testRSAKeyPairGeneratorSpec(P11, true,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP + 1,
+            RSAKeyGenParameterSpec.F0.intValue());
+        testRSAKeyPairGeneratorSpec(P11, true,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP + 1,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN);
+        testRSAKeyPairGeneratorSpec(P11, false,
+            RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP + 1,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1);
+
+        testRSAKeyPairGeneratorSpec(P11, true,
+            RSAKeyFactory.MAX_MODLEN, -1);
+        testRSAKeyPairGeneratorSpec(P11, true,
+            RSAKeyFactory.MAX_MODLEN,
+            RSAKeyGenParameterSpec.F0.intValue());
+        testRSAKeyPairGeneratorSpec(P11, true,
+            RSAKeyFactory.MAX_MODLEN,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN);
+        testRSAKeyPairGeneratorSpec(P11, false,
+            RSAKeyFactory.MAX_MODLEN,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1);
+
+        testRSAKeyPairGeneratorSpec(P11, false,
+            RSAKeyFactory.MAX_MODLEN + 1, -1);
+        testRSAKeyPairGeneratorSpec(P11, false,
+            RSAKeyFactory.MAX_MODLEN + 1,
+            RSAKeyGenParameterSpec.F0.intValue() - 1);
+        testRSAKeyPairGeneratorSpec(P11, false,
+            RSAKeyFactory.MAX_MODLEN + 1,
+            RSAKeyGenParameterSpec.F0.intValue());
+        testRSAKeyPairGeneratorSpec(P11, false,
+            RSAKeyFactory.MAX_MODLEN + 1,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN);
+        testRSAKeyPairGeneratorSpec(P11, false,
+            RSAKeyFactory.MAX_MODLEN + 1,
+            RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1);
+    }
+
+    /*
+     * Test the KeyFactory translations.
+     */
+    private static void testTranslateKey(String provider, boolean b, Key key)
+            throws Exception {
+        System.out.println("testTranslateKey: " + b + " " + key + " " +
+            provider);
+
+        KeyFactory kf = KeyFactory.getInstance("RSA", provider);
+
+        try {
+            kf.translateKey(key);
+            if (!b) {
+                throw new Exception("Should have failed");
+            }
+        } catch (InvalidKeyException e) {
+            if (b) {
+                throw new Exception("Should have passed", e);
+            }
+        }
+    }
+
+    /*
+     * Test the KeyFactory's translation code.
+     *
+     * This also checks the KeyImpl's constructors.
+     *
+     * We've already tested all the corner cases above, just making
+     * sure that the others are correctly doing their checks.
+     */
+    private static void testRSAKeyFactory() throws Exception {
+        testTranslateKey(SunRSA, true, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP),
+            RSAKeyGenParameterSpec.F4));
+        testTranslateKey(SunRSA, true, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(RSAKeyFactory.MAX_RESTRICTED_EXPLEN)));
+        testTranslateKey(SunRSA, false, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1)));
+        testTranslateKey(SunRSA, false, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN + 1),
+            RSAKeyGenParameterSpec.F4));
+        testTranslateKey(SunRSA, false, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MIN_MODLEN - 8),
+            RSAKeyGenParameterSpec.F4));
+        testTranslateKey(SunRSA, true, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MIN_MODLEN - 7),
+            RSAKeyGenParameterSpec.F4));
+
+        // Private keys don't have the same restriction
+        testTranslateKey(SunRSA, true, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP),
+            RSAKeyGenParameterSpec.F4));
+        testTranslateKey(SunRSA, true, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(RSAKeyFactory.MAX_RESTRICTED_EXPLEN)));
+        testTranslateKey(SunRSA, true, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1)));
+        testTranslateKey(SunRSA, false, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN + 1),
+            RSAKeyGenParameterSpec.F4));
+        testTranslateKey(SunRSA, false, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MIN_MODLEN - 8),
+            RSAKeyGenParameterSpec.F4));
+        testTranslateKey(SunRSA, true, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MIN_MODLEN - 7),
+            RSAKeyGenParameterSpec.F4));
+    }
+
+    private static void testP11KeyFactory() throws Exception {
+        testTranslateKey(P11, true, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP),
+            RSAKeyGenParameterSpec.F4));
+        testTranslateKey(P11, true, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(RSAKeyFactory.MAX_RESTRICTED_EXPLEN)));
+        testTranslateKey(P11, false, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1)));
+        testTranslateKey(P11, false, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN + 1),
+            RSAKeyGenParameterSpec.F4));
+        testTranslateKey(P11, true, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MIN_MODLEN - 8),
+            RSAKeyGenParameterSpec.F4));
+
+        // Private keys don't have the same restriction
+        testTranslateKey(P11, true, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP),
+            RSAKeyGenParameterSpec.F4));
+        testTranslateKey(P11, true, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(RSAKeyFactory.MAX_RESTRICTED_EXPLEN)));
+        testTranslateKey(P11, true, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1)));
+        testTranslateKey(P11, false, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN + 1),
+            RSAKeyGenParameterSpec.F4));
+        testTranslateKey(P11, true, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MIN_MODLEN - 8),
+            RSAKeyGenParameterSpec.F4));
+    }
+
+    /*
+     * Tests that that Signature's are working properly for both public
+     * and private keys.
+     */
+    private static void testInitSign(String provider,
+            boolean b, PrivateKey key) throws Exception {
+        System.out.println("testInitSign: " + b + " " + key + " " + provider);
+
+        Signature kf = Signature.getInstance("SHA1withRSA", provider);
+
+        try {
+            kf.initSign(key);
+            if (!b) {
+                throw new Exception("Should have failed");
+            }
+        } catch (InvalidKeyException e) {
+            if (b) {
+                throw new Exception("Should have passed", e);
+            }
+        } catch (ProviderException e) {
+            // The Solaris PKCS11 softtoken doesn't currently allow
+            // keys larger than 4K.  Throws a ProviderException.
+            if (!b) {
+                throw new Exception("Should have failed", e);
+            } else {
+                System.out.println("Large Keys excpetion, passing...");
+            }
+        }
+    }
+
+    private static void testInitVerify(String provider,
+            boolean b, PublicKey key) throws Exception {
+        System.out.println("testInitVerify: " + b + " " + key + " " +
+            provider);
+
+        Signature kf = Signature.getInstance("SHA1withRSA", provider);
+
+        try {
+            kf.initVerify(key);
+            if (!b) {
+                throw new Exception("Should have failed");
+            }
+        } catch (InvalidKeyException e) {
+            if (b) {
+                throw new Exception("Should have passed", e);
+            }
+        } catch (ProviderException e) {
+            // The Solaris PKCS11 softtoken doesn't currently allow
+            // keys larger than 4K.  Throws a ProviderException.
+            if (!b) {
+                throw new Exception("Should have failed", e);
+            } else {
+                System.out.println("Large Keys excpetion, passing...");
+            }
+        }
+    }
+
+    private static void testRSASignature() throws Exception {
+        testInitSign(SunRSA, true, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP),
+            RSAKeyGenParameterSpec.F4));
+        testInitSign(SunRSA, true, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(RSAKeyFactory.MAX_RESTRICTED_EXPLEN)));
+        testInitSign(SunRSA, true, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1)));
+        testInitSign(SunRSA, false, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN + 1),
+            RSAKeyGenParameterSpec.F4));
+        testInitSign(SunRSA, false, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MIN_MODLEN - 8),
+            RSAKeyGenParameterSpec.F4));
+        testInitSign(SunRSA, true, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MIN_MODLEN - 7),
+            RSAKeyGenParameterSpec.F4));
+
+        testInitVerify(SunRSA, true, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP),
+            RSAKeyGenParameterSpec.F4));
+        testInitVerify(SunRSA, true, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(RSAKeyFactory.MAX_RESTRICTED_EXPLEN)));
+        testInitVerify(SunRSA, false, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1)));
+        testInitVerify(SunRSA, false, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN + 1),
+            RSAKeyGenParameterSpec.F4));
+        testInitVerify(SunRSA, false, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MIN_MODLEN - 8),
+            RSAKeyGenParameterSpec.F4));
+        testInitVerify(SunRSA, true, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MIN_MODLEN - 7),
+            RSAKeyGenParameterSpec.F4));
+    }
+
+    private static void testP11Signature() throws Exception {
+        testInitSign(P11, true, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP),
+            RSAKeyGenParameterSpec.F4));
+        testInitSign(P11, true, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(RSAKeyFactory.MAX_RESTRICTED_EXPLEN)));
+        testInitSign(P11, true, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1)));
+        testInitSign(P11, false, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN + 1),
+            RSAKeyGenParameterSpec.F4));
+        testInitSign(P11, true, new MyRSAPrivateKey(
+            getBigInteger(RSAKeyFactory.MIN_MODLEN - 8),
+            RSAKeyGenParameterSpec.F4));
+
+        testInitVerify(P11, true, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP),
+            RSAKeyGenParameterSpec.F4));
+        testInitVerify(P11, true, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(RSAKeyFactory.MAX_RESTRICTED_EXPLEN)));
+        testInitVerify(P11, false, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1)));
+        testInitVerify(P11, false, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN + 1),
+            RSAKeyGenParameterSpec.F4));
+        testInitVerify(P11, true, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MIN_MODLEN - 8),
+            RSAKeyGenParameterSpec.F4));
+    }
+
+    /*
+     * There are a couple test files, one with big keys.  Make sure that
+     * they are caught correctly.
+     */
+    private static void testStore(String file) throws Exception {
+
+        KeyStore ks = KeyStore.getInstance("JKS");
+        FileInputStream fis = new FileInputStream(new File(BASE, file));
+        ks.load(fis, "changeit".toCharArray());
+
+        java.security.cert.Certificate cert = ks.getCertificate("duke1");
+
+        Signature kf = Signature.getInstance("SHA1withRSA", SunRSA);
+        kf.initVerify(cert);
+    }
+
+    private static void testKeyStore() throws Exception {
+        System.out.println("testKeyStore with good key:");
+        testStore("keystore.good");
+
+        System.out.println("testKeyStore with bad key:");
+        try {
+            testStore("keystore.bad");
+            throw new Exception("Didn't throw expected IOException");
+        } catch (java.security.cert.CertificateParsingException e) {
+            System.out.println("Got proper CertificateParsingException");
+        }
+    }
+
+    /*
+     * We'll hard code the solaris p11 file for now.  If we
+     * ever add another one by default, this test will fail
+     * and we'll need to adjust the logic here.
+     */
+    private static void testP11() throws Exception {
+
+        // Replace the existing P11 provider with one that
+        // uses the local configuration file.
+        Provider p = Security.getProvider(P11);
+        if (p == null) {
+            System.out.println("Skipping " + P11 + " tests");
+            return;
+        }
+
+        Security.removeProvider(P11);
+        String config = BASE + "/sunpkcs11-solaris_enableSHA1withRSAsig.cfg";
+        System.out.println("Using config: " + config);
+        p = new sun.security.pkcs11.SunPKCS11(config);
+        Security.insertProviderAt(p, 1);
+
+        testP11KeyPairGenerator();
+        testP11KeyFactory();
+        testP11Signature();
+    }
+
+    /*
+     * Run a few tests with the MSCAPI provider.
+     */
+    private static void testMSCAPI() throws Exception {
+        if (Security.getProvider(MSCAPI) == null) {
+            System.out.println("Skipping " + MSCAPI + " tests");
+            return;
+        }
+
+        testRSAKeyPairGeneratorLen(MSCAPI, false,
+            RSAKeyFactory.MIN_MODLEN - 7);
+        testRSAKeyPairGeneratorLen(MSCAPI, true,
+            RSAKeyFactory.MIN_MODLEN);
+        testRSAKeyPairGeneratorLen(MSCAPI, true,
+            RSAKeyFactory.MAX_MODLEN);
+        testRSAKeyPairGeneratorLen(MSCAPI, false,
+            RSAKeyFactory.MAX_MODLEN + 1);
+
+        testRSAKeyPairGeneratorSpec(MSCAPI, false,
+            RSAKeyFactory.MIN_MODLEN - 1, -1);
+        testRSAKeyPairGeneratorSpec(MSCAPI, true,
+            RSAKeyFactory.MIN_MODLEN, -1);
+        testRSAKeyPairGeneratorSpec(MSCAPI, true,
+            RSAKeyFactory.MAX_MODLEN, -1);
+        testRSAKeyPairGeneratorSpec(MSCAPI, false,
+            RSAKeyFactory.MAX_MODLEN + 1, -1);
+
+        // This will fail because the SunMSCAPI provider itself
+        // won't allow Specs to contain actual exponents.
+        testRSAKeyPairGeneratorSpec(MSCAPI, false,
+            RSAKeyFactory.MAX_MODLEN, 64);
+
+        // Stock XP's MSCAPI won't allow exponents >= 32 bits,
+        // so we'll fudge a bit here.
+        testInitVerify(MSCAPI, true, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN_RESTRICT_EXP),
+            RSAKeyGenParameterSpec.F4));
+        testInitVerify(MSCAPI, true, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(24)));
+        testInitVerify(MSCAPI, false, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN),
+            getBigInteger(RSAKeyFactory.MAX_RESTRICTED_EXPLEN + 1)));
+        testInitVerify(MSCAPI, false, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MAX_MODLEN + 1),
+            RSAKeyGenParameterSpec.F4));
+        testInitVerify(MSCAPI, true, new MyRSAPublicKey(
+            getBigInteger(RSAKeyFactory.MIN_MODLEN - 1),
+            RSAKeyGenParameterSpec.F4));
+    }
+
+    public static void main(String args[]) throws Exception {
+
+        testRSAKeyPairGenerator();
+
+        testRSAKeyFactory();
+
+        testRSASignature();
+
+        testKeyStore();
+
+        testMSCAPI();
+
+        testP11();
+    }
+
+    /*
+     * Helper PublicKey class.  Create these with no restrictions.
+     */
+    private static class MyRSAPublicKey implements RSAPublicKey {
+
+        private final BigInteger n;
+        private final BigInteger e;
+
+        MyRSAPublicKey(BigInteger n, BigInteger e) {
+            this.n = n;
+            this.e = e;
+        }
+
+        public BigInteger getModulus() {
+            return n;
+        }
+
+        public BigInteger getPublicExponent() {
+            return e;
+        }
+
+        public String getAlgorithm() {
+             return "RSA";
+         }
+
+        public String getFormat() {
+            return "PKCS#8";
+        }
+
+        public byte [] getEncoded() {
+            return null;
+        }
+    }
+
+    /*
+     * Helper PrivateKey class.  Create these with no restrictions.
+     */
+    private static class MyRSAPrivateKey implements RSAPrivateKey {
+
+        private final BigInteger n;
+        private final BigInteger d;
+
+        MyRSAPrivateKey(BigInteger n, BigInteger d) {
+            this.n = n;
+            this.d = d;
+        }
+
+        public BigInteger getModulus() {
+            return n;
+        }
+
+        public BigInteger getPrivateExponent() {
+            return d;
+        }
+
+        public String getAlgorithm() {
+            return "RSA";
+        }
+
+        public String getFormat() {
+            return "PKCS#8";
+        }
+
+        public byte [] getEncoded() {
+            return null;
+        }
+    }
+}
--- /dev/null	Fri Aug 22 18:59:31 2008
+++ openjdk/jdk/test/closed/sun/security/rsa/sunpkcs11-solaris_enableSHA1withRSAsig.cfg	Fri Aug 22 18:59:29 2008
@@ -0,0 +1,36 @@
+#
+# Configuration file to allow the SunPKCS11 provider to utilize
+# the Solaris Cryptographic Framework, if it is available
+#
+
+name = Solaris
+
+description = SunPKCS11 accessing Solaris Cryptographic Framework
+
+library = /usr/lib/$ISA/libpkcs11.so
+
+handleStartupErrors = ignoreAll
+
+attributes = compatibility
+
+disabledMechanisms = {
+  CKM_MD2
+  CKM_MD5
+  CKM_SHA_1
+  CKM_SHA256
+  CKM_SHA384
+  CKM_SHA512
+  CKM_DSA_KEY_PAIR_GEN
+# KEY_AND_MAC_DERIVE disabled due to Solaris bug 6306708
+  CKM_SSL3_KEY_AND_MAC_DERIVE
+  CKM_TLS_KEY_AND_MAC_DERIVE
+# the following mechanisms are disabled due to performance issues (Solaris bug 6337157)
+  CKM_DSA_SHA1
+  CKM_MD5_RSA_PKCS
+# For testing purposes, we'll reenable this suite.
+#  CKM_SHA1_RSA_PKCS
+  CKM_SHA256_RSA_PKCS
+  CKM_SHA384_RSA_PKCS
+  CKM_SHA512_RSA_PKCS
+}
+
