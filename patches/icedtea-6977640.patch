
# HG changeset patch
# User twisti
# Date 1282119736 25200
# Node ID 13b87063b4d8dea40ba97a283ad5bd3272e876f3
# Parent a62d332029cf3a8c710687b833d71966e078bbdc
6977640: Zero and Shark fixes
Summary: A number of fixes for Zero and Shark.
Reviewed-by: twisti
Contributed-by: Gary Benson <gbenson@redhat.com>

--- openjdk/hotspot/src/cpu/zero/vm/bytecodeInterpreter_zero.inline.hpp	Fri Aug 13 15:14:00 2010 -0700
+++ openjdk/hotspot/src/cpu/zero/vm/bytecodeInterpreter_zero.inline.hpp	Wed Aug 18 01:22:16 2010 -0700
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2007 Red Hat, Inc.
+ * Copyright 2007, 2010 Red Hat, Inc.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -268,7 +268,7 @@ inline jint BytecodeInterpreter::VMintSu
   return op1 - op2;
 }
 
-inline jint BytecodeInterpreter::VMintUshr(jint op1, jint op2) {
+inline juint BytecodeInterpreter::VMintUshr(jint op1, jint op2) {
   return ((juint) op1) >> (op2 & 0x1F);
 }
 
--- openjdk/hotspot/src/cpu/zero/vm/javaFrameAnchor_zero.hpp	Fri Aug 13 15:14:00 2010 -0700
+++ openjdk/hotspot/src/cpu/zero/vm/javaFrameAnchor_zero.hpp	Wed Aug 18 01:22:16 2010 -0700
@@ -82,6 +82,10 @@
     return _last_Java_fp;
   }
 
+  address last_Java_pc() const {
+    return _last_Java_pc;
+  }
+
   static ByteSize last_Java_fp_offset() {
     return byte_offset_of(JavaFrameAnchor, _last_Java_fp);
   }
--- openjdk/hotspot/src/os_cpu/linux_zero/vm/os_linux_zero.cpp	Fri Aug 13 15:14:00 2010 -0700
+++ openjdk/hotspot/src/os_cpu/linux_zero/vm/os_linux_zero.cpp	Wed Aug 18 01:22:16 2010 -0700
@@ -435,22 +435,22 @@ extern "C" {
   void _Copy_arrayof_conjoint_bytes(HeapWord* from,
                                     HeapWord* to,
                                     size_t    count) {
-    ShouldNotCallThis();
+    memmove(to, from, count);
   }
   void _Copy_arrayof_conjoint_jshorts(HeapWord* from,
                                       HeapWord* to,
                                       size_t    count) {
-    ShouldNotCallThis();
+    memmove(to, from, count * 2);
   }
   void _Copy_arrayof_conjoint_jints(HeapWord* from,
                                     HeapWord* to,
                                     size_t    count) {
-    ShouldNotCallThis();
+    memmove(to, from, count * 4);
   }
   void _Copy_arrayof_conjoint_jlongs(HeapWord* from,
                                      HeapWord* to,
                                      size_t    count) {
-    ShouldNotCallThis();
+    memmove(to, from, count * 8);
   }
 };
 
--- openjdk/hotspot/src/os_cpu/linux_zero/vm/thread_linux_zero.cpp	Fri Aug 13 15:14:00 2010 -0700
+++ openjdk/hotspot/src/os_cpu/linux_zero/vm/thread_linux_zero.cpp	Wed Aug 18 01:22:16 2010 -0700
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2009 Red Hat, Inc.
+ * Copyright 2009, 2010 Red Hat, Inc.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,6 +23,9 @@
  *
  */
 
-// This file is intentionally empty
+#include "incls/_precompiled.incl"
+#include "incls/_thread_linux_zero.cpp.incl"
 
-void JavaThread::cache_global_variables() { }
+void JavaThread::cache_global_variables() {
+  // nothing to do
+}
--- openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp	Fri Aug 13 15:14:00 2010 -0700
+++ openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp	Wed Aug 18 01:22:16 2010 -0700
@@ -421,7 +421,9 @@ BytecodeInterpreter::run(interpreterStat
 #ifdef ASSERT
   if (istate->_msg != initialize) {
     assert(abs(istate->_stack_base - istate->_stack_limit) == (istate->_method->max_stack() + 1), "bad stack limit");
-  IA32_ONLY(assert(istate->_stack_limit == istate->_thread->last_Java_sp() + 1, "wrong"));
+#ifndef SHARK
+    IA32_ONLY(assert(istate->_stack_limit == istate->_thread->last_Java_sp() + 1, "wrong"));
+#endif // !SHARK
   }
   // Verify linkages.
   interpreterState l = istate;

