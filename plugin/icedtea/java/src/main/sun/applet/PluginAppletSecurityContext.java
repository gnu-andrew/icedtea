/* PluginAppletSecurityContext -- execute plugin JNI messages
   Copyright (C) 2008  Red Hat

This file is part of IcedTea.

IcedTea is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

IcedTea is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with IcedTea; see the file COPYING.  If not, write to the
Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301 USA.

Linking this library statically or dynamically with other modules is
making a combined work based on this library.  Thus, the terms and
conditions of the GNU General Public License cover the whole
combination.

As a special exception, the copyright holders of this library give you
permission to link this library with independent modules to produce an
executable, regardless of the license terms of these independent
modules, and to copy and distribute the resulting executable under
terms of your choice, provided that you also meet, for each linked
independent module, the terms and conditions of the license of that
module.  An independent module is a module which is not derived from
or based on this library.  If you modify this library, you may extend
this exception to your version of the library, but you are not
obligated to do so.  If you do not wish to do so, delete this
exception statement from your version. */

package sun.applet;

import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.StringTokenizer;

class Signature {
	private String signature;
	private int currentIndex;
	private List<Class> typeList;
	private static final char ARRAY = '[';
	private static final char OBJECT = 'L';
	private static final char SIGNATURE_ENDCLASS = ';';
	private static final char SIGNATURE_FUNC = '(';
	private static final char SIGNATURE_ENDFUNC = ')';
	private static final char VOID = 'V';
	private static final char BOOLEAN = 'Z';
	private static final char BYTE = 'B';
	private static final char CHARACTER = 'C';
	private static final char SHORT = 'S';
	private static final char INTEGER = 'I';
	private static final char LONG = 'J';
	private static final char FLOAT = 'F';
	private static final char DOUBLE = 'D';

	private String nextTypeName() {
		char key = signature.charAt(currentIndex++);

		switch (key) {
		case ARRAY:
			return nextTypeName() + "[]";

		case OBJECT:
			int endClass = signature.indexOf(SIGNATURE_ENDCLASS, currentIndex);
			String retVal = signature.substring(currentIndex, endClass);
			retVal = retVal.replace('/', '.');
			currentIndex = endClass + 1;
			return retVal;

			// FIXME: generated bytecode with classes named after
			// primitives will not work in this scheme -- those
			// classes will be incorrectly treated as primitive
			// types.
		case VOID:
			return "void";
		case BOOLEAN:
			return "boolean";
		case BYTE:
			return "byte";
		case CHARACTER:
			return "char";
		case SHORT:
			return "short";
		case INTEGER:
			return "int";
		case LONG:
			return "long";
		case FLOAT:
			return "float";
		case DOUBLE:
			return "double";

		case SIGNATURE_ENDFUNC:
		case SIGNATURE_FUNC:
			return nextTypeName();

		default:
			throw new IllegalArgumentException(
					"Invalid JNI signature character '" + key + "'");
		}
	}

	public Signature(String signature, String src) {
		this.signature = signature;
		currentIndex = 0;
		typeList = new ArrayList<Class>(10);

		String elem;
		while (currentIndex < signature.length()) {
			elem = nextTypeName();
			// System.out.println ("NEXT TYPE: " + elem);
			Class primitive = primitiveNameToType(elem);
			if (primitive != null)
				typeList.add(primitive);
			else {
				// System.out.println ("HERE1");
				int dimsize = 0;
				int n = elem.indexOf('[');
				if (n != -1) {
					// System.out.println ("HERE2");
					String arrayType = elem.substring(0, n);
					dimsize++;
					n = elem.indexOf('[', n + 1);
					// System.out.println ("HERE2.5");
					while (n != -1) {
						dimsize++;
						n = elem.indexOf('[', n + 1);
						// System.out.println ("HERE2.8");
					}
					int[] dims = new int[dimsize];
					primitive = primitiveNameToType(arrayType);
					// System.out.println ("HERE3");
					if (primitive != null) {
						typeList.add(Array.newInstance(primitive, dims)
								.getClass());
						// System.out.println ("HERE4");
					} else
						typeList.add(Array.newInstance(
								getClass(arrayType, src), dims).getClass());
				} else {
					typeList.add(getClass(elem, src));
				}
			}
		}
		if (typeList.size() == 0) {
			throw new IllegalArgumentException("Invalid JNI signature '"
					+ signature + "'");
		}
	}

	public static Class getClass(String name, String src) {

		Class c = null;
		
		try {
			c = Class.forName(name);
		} catch (ClassNotFoundException cnfe) {

			StringTokenizer st = new StringTokenizer(src, ",");

			while (st.hasMoreTokens()) {

				String tok = st.nextToken();
				System.err.println("Searching for " + name  + " at key " + tok);

				try {
					c = PluginAppletSecurityContext.classLoaders.get(tok).loadClass(name);
				} catch (ClassNotFoundException e) {
					// do nothing .. thrown below
				}
				
				if (c != null)
					break;
			}
		}

		if (c == null) {
			throw (new RuntimeException(new ClassNotFoundException("Unable to find class " + name)));
		}

		return c;
	}
	
	public static Class primitiveNameToType(String name) {
		if (name.equals("void"))
			return Void.TYPE;
		else if (name.equals("boolean"))
			return Boolean.TYPE;
		else if (name.equals("byte"))
			return Byte.TYPE;
		else if (name.equals("char"))
			return Character.TYPE;
		else if (name.equals("short"))
			return Short.TYPE;
		else if (name.equals("int"))
			return Integer.TYPE;
		else if (name.equals("long"))
			return Long.TYPE;
		else if (name.equals("float"))
			return Float.TYPE;
		else if (name.equals("double"))
			return Double.TYPE;
		else
			return null;
	}

	public Class[] getClassArray() {
		return typeList.subList(0, typeList.size() - 1).toArray(new Class[] {});
	}
}

public class PluginAppletSecurityContext {
	// Context identifier -> PluginAppletSecurityContext object.
	// FIXME: make private
	public static HashMap<Integer, PluginAppletSecurityContext> contexts = new HashMap();
	
	public static HashMap<String, ClassLoader> classLoaders = new HashMap<String, ClassLoader>();

	// FIXME: make private
	public PluginObjectStore store = new PluginObjectStore();
	private Throwable throwable = null;
	private ClassLoader liveconnectLoader = ClassLoader.getSystemClassLoader();
	int identifier = 0;

	static {
		// FIXME: when should we add each new security context? but how would 
		// we be able to know which context applies to which request from nspr? 
		// the nspr jni functions do not know what applet they are being called
		// in reference to
		contexts.put(0, new PluginAppletSecurityContext(0));
	}

	public PluginAppletSecurityContext(int identifier) {
		this.identifier = identifier;
	}

	public static <V> V parseCall(String s, String src, Class<V> c) {
		if (c == Integer.class)
			return (V) new Integer(s);
		else if (c == String.class)
			return (V) new String(s);
		else if (c == Signature.class)
			return (V) new Signature(s, src);
		else
			throw new RuntimeException("Unexpected call value.");
	}

	public Object parseArgs(String s, Class c) {
		if (c == Boolean.TYPE || c == Boolean.class)
			return new Boolean(s);
		else if (c == Byte.TYPE || c == Byte.class)
			return new Byte(s);
		else if (c == Character.TYPE || c == Character.class) {
			String[] bytes = s.split("_");
			int low = Integer.parseInt(bytes[0]);
			int high = Integer.parseInt(bytes[1]);
			int full = ((high << 8) & 0x0ff00) | (low & 0x0ff);
			return new Character((char) full);
		} else if (c == Short.TYPE || c == Short.class)
			return new Short(s);
		else if (c == Integer.TYPE || c == Integer.class)
			return new Integer(s);
		else if (c == Long.TYPE || c == Long.class)
			return new Long(s);
		else if (c == Float.TYPE || c == Float.class)
			return new Float(s);
		else if (c == Double.TYPE || c == Double.class)
			return new Double(s);
		else
			return store.getObject(new Integer(s));
	}

	public static void handleMessage(int identifier, String src, int reference,
			String message) {
		contexts.get(identifier).handleMessage(reference, src, message);
	}

	public void handleMessage(int reference, String src, String message) {

		try {
			if (message.startsWith("FindClass")) {
				ClassLoader cl = null;
				Class c = null;
				cl = liveconnectLoader;
				String className = message.substring("FindClass".length() + 1)
						.replace('/', '.');

				try {
					c = cl.loadClass(className);
					store.reference(c);
					write(reference, "FindClass " + store.getIdentifier(c));
				} catch (ClassNotFoundException cnfe) {
					write(reference, "FindClass 0");
				}

			} else if (message.startsWith("GetStaticMethodID")
					|| message.startsWith("GetMethodID")) {
				String[] args = message.split(" ");
				Integer classID = parseCall(args[1], src, Integer.class);
				String methodName = parseCall(args[2], src, String.class);
				Signature signature = parseCall(args[3], src, Signature.class);
				Object[] a = signature.getClassArray();

				Class c = (Class) store.getObject(classID);
				Method m = null;
				Constructor cs = null;
				Object o = null;
				if (methodName.equals("<init>")
						|| methodName.equals("<clinit>")) {
					o = cs = c.getConstructor(signature.getClassArray());
					store.reference(cs);
				} else {
					o = m = c.getMethod(methodName, signature.getClassArray());
					store.reference(m);
				}
				PluginDebug.debug(o + " has id " + store.getIdentifier(o));
				write(reference, args[0] + " " + store.getIdentifier(o));
			} else if (message.startsWith("GetStaticFieldID")
					|| message.startsWith("GetFieldID")) {
				String[] args = message.split(" ");
				Integer classID = parseCall(args[1], src, Integer.class);
				String fieldName = parseCall(args[2], src, String.class);
				Signature signature = parseCall(args[3], src, Signature.class);

				Class c = (Class) store.getObject(classID);
				Field f = null;
				f = c.getField(fieldName);

				store.reference(f);

				write(reference, "GetStaticFieldID " + store.getIdentifier(f));
			} else if (message.startsWith("GetStaticField")) {
				String[] args = message.split(" ");
				String type = parseCall(args[1], src, String.class);
				Integer classID = parseCall(args[1], src, Integer.class);
				Integer fieldID = parseCall(args[2], src, Integer.class);

				Class c = (Class) store.getObject(classID);
				Field f = (Field) store.getObject(fieldID);

				Object ret = null;
				ret = f.get(c);

				// System.out.println ("FIELD VALUE: " + ret);
				if (ret == null) {
					write(reference, "GetStaticField 0");
				} else if (f.getType() == Boolean.TYPE
						|| f.getType() == Byte.TYPE
						|| f.getType() == Character.TYPE
						|| f.getType() == Short.TYPE
						|| f.getType() == Integer.TYPE
						|| f.getType() == Long.TYPE
						|| f.getType() == Float.TYPE
						|| f.getType() == Double.TYPE) {
					write(reference, "GetStaticField " + ret);
				} else {
					// Track returned object.
					store.reference(ret);
					write(reference, "GetStaticField "
							+ store.getIdentifier(ret));
				}
			} else if (message.startsWith("SetStaticField")) {
				String[] args = message.split(" ");
				String type = parseCall(args[1], src, String.class);
				Integer classID = parseCall(args[2], src, Integer.class);
				Integer fieldID = parseCall(args[3], src, Integer.class);

				Object value = null;
				if (Signature.primitiveNameToType(type) != null) {
					value = parseArgs(args[4], Signature
							.primitiveNameToType(type));
					// System.out.println ("HERE1: " + value);
				} else {
					value = parseArgs(args[3], Object.class);
					// System.out.println ("HERE2: " + value);
				}

				Class c = (Class) store.getObject(classID);
				Field f = (Field) store.getObject(fieldID);

				f.set(c, value);

				write(reference, "SetStaticField");
			} else if (message.startsWith("SetField")) {
				String[] args = message.split(" ");
				String type = parseCall(args[1], src, String.class);
				Integer objectID = parseCall(args[2], src, Integer.class);
				Integer fieldID = parseCall(args[3], src, Integer.class);

				Object value = null;
				if (Signature.primitiveNameToType(type) != null) {
					value = parseArgs(args[4], Signature
							.primitiveNameToType(type));
					// System.out.println ("HERE1: " + value);
				} else {
					value = parseArgs(args[3], Object.class);
					// System.out.println ("HERE2: " + value);
				}

				Object o = (Object) store.getObject(objectID);
				Field f = (Field) store.getObject(fieldID);

				f.set(o, value);

				write(reference, "SetField");
			} else if (message.startsWith("GetObjectArrayElement")) {
				String[] args = message.split(" ");
				Integer arrayID = parseCall(args[1], src, Integer.class);
				Integer index = parseCall(args[2], src, Integer.class);

				Object[] o = (Object[]) store.getObject(arrayID);
				Object ret = null;

				ret = o[index];

				// Track returned object.
				store.reference(ret);
				// System.out.println ("array element: " + index + " " + ret);
				write(reference, "GetObjectArrayElement "
						+ store.getIdentifier(ret));
			} else if (message.startsWith("SetObjectArrayElement")) {
				String[] args = message.split(" ");
				Integer arrayID = parseCall(args[1], src, Integer.class);
				Integer index = parseCall(args[2], src, Integer.class);
				Integer objectID = parseCall(args[3], src, Integer.class);

				Object[] o = (Object[]) store.getObject(arrayID);
				Object toSet = (Object) store.getObject(objectID);

				o[index] = toSet;

				write(reference, "SetObjectArrayElement");
			} else if (message.startsWith("GetArrayLength")) {
				String[] args = message.split(" ");
				Integer arrayID = parseCall(args[1], src, Integer.class);

				System.out.println("ARRAYID: " + arrayID);
				Object o = (Object) store.getObject(arrayID);
				int len = 0;
				len = Array.getLength(o);
				// System.out.println ("Returning array length: " + len);

				// System.out.println ("array length: " + o + " " + len);
				write(reference, "GetArrayLength " + Array.getLength(o));
			} else if (message.startsWith("GetField")) {
				String[] args = message.split(" ");
				String type = parseCall(args[1], src, String.class);
				Integer objectID = parseCall(args[1], src, Integer.class);
				Integer fieldID = parseCall(args[2], src, Integer.class);

				Object o = (Object) store.getObject(objectID);
				Field f = (Field) store.getObject(fieldID);

				Object ret = null;
				ret = f.get(o);

				// System.out.println ("FIELD VALUE: " + ret);
				if (ret == null) {
					write(reference, "GetField 0");
				} else if (f.getType() == Boolean.TYPE
						|| f.getType() == Byte.TYPE
						|| f.getType() == Character.TYPE
						|| f.getType() == Short.TYPE
						|| f.getType() == Integer.TYPE
						|| f.getType() == Long.TYPE
						|| f.getType() == Float.TYPE
						|| f.getType() == Double.TYPE) {
					write(reference, "GetField " + ret);
				} else {
					// Track returned object.
					store.reference(ret);
					write(reference, "GetField " + store.getIdentifier(ret));
				}
			} else if (message.startsWith("GetObjectClass")) {
				int oid = Integer.parseInt(message.substring("GetObjectClass"
						.length() + 1));
				// System.out.println ("GETTING CLASS FOR: " + oid);
				Class c = store.getObject(oid).getClass();
				// System.out.println (" OBJ: " + store.getObject(oid));
				// System.out.println (" CLS: " + c);
				store.reference(c);

				write(reference, "GetObjectClass " + store.getIdentifier(c));
			} else if (message.startsWith("CallStaticMethod")) {
				String[] args = message.split(" ");
				Integer classID = parseCall(args[1], src, Integer.class);
				Integer methodID = parseCall(args[2], src, Integer.class);

				System.out.println("GETTING: " + methodID);
				Method m = (Method) store.getObject(methodID);
				System.out.println("GOT: " + m);
				Class[] argTypes = m.getParameterTypes();

				Object[] arguments = new Object[argTypes.length];
				for (int i = 0; i < argTypes.length; i++) {
					arguments[i] = parseArgs(args[3 + i], argTypes[i]);
					// System.out.println ("GOT ARG: " + argTypes[i] + " " +
					// arguments[i]);
				}

				// System.out.println ("Calling " + m);
				Object ret = null;
				ret = m.invoke(null, arguments);

				// if (ret != null)
				// System.out.println ("RETURN VALUE: " + ret + " " +
				// ret.getClass());
				// else
				// System.out.println ("RETURN VALUE: " + ret);
				if (ret == null) {
					write(reference, "CallStaticMethod void");
				} else if (m.getReturnType() == Boolean.TYPE
						|| m.getReturnType() == Byte.TYPE
						|| m.getReturnType() == Short.TYPE
						|| m.getReturnType() == Integer.TYPE
						|| m.getReturnType() == Long.TYPE
						|| m.getReturnType() == Float.TYPE
						|| m.getReturnType() == Double.TYPE) {
					write(reference, "CallStaticMethod " + ret);
				} else if (m.getReturnType() == Character.TYPE) {
					char ch = (Character) ret;
					int high = (((int) ch) >> 8) & 0x0ff;
					int low = ((int) ch) & 0x0ff;
					write(reference, "CallStaticMethod " + low + "_" + high);
				} else {
					// Track returned object.
					store.reference(ret);
					write(reference, "CallStaticMethod "
							+ store.getIdentifier(ret));
				}
			} else if (message.startsWith("CallMethod")) {
				String[] args = message.split(" ");
				Integer objectID = parseCall(args[1], src, Integer.class);
				Integer methodID = parseCall(args[2], src, Integer.class);

				Object o = (Object) store.getObject(objectID);
				Method m = (Method) store.getObject(methodID);
				Class[] argTypes = m.getParameterTypes();

				Object[] arguments = new Object[argTypes.length];
				for (int i = 0; i < argTypes.length; i++) {
					arguments[i] = parseArgs(args[3 + i], argTypes[i]);
					PluginDebug.debug("GOT ARG: " + argTypes[i] + " "
							+ arguments[i]);
				}

				String collapsedArgs = "";
				for (String s : args) {
					collapsedArgs += " " + s;
				}

				PluginDebug.debug("Calling method " + m + " on object " + o
						+ " with " + arguments);
				Object ret = null;
				ret = m.invoke(o, arguments);

				String retO;
				if (ret == null) {
					retO = "null";
				} else {
					retO = ret.getClass().toString();
				}

				PluginDebug.debug("Calling " + m + " on " + o + " with "
						+ collapsedArgs + " and that returned: " + ret
						+ " of type " + retO);

				if (ret == null) {
					write(reference, "CallMethod void");
				} else if (m.getReturnType() == Boolean.TYPE
						|| m.getReturnType() == Byte.TYPE
						|| m.getReturnType() == Short.TYPE
						|| m.getReturnType() == Integer.TYPE
						|| m.getReturnType() == Long.TYPE
						|| m.getReturnType() == Float.TYPE
						|| m.getReturnType() == Double.TYPE) {
					write(reference, "CallMethod " + ret);
				} else if (m.getReturnType() == Character.TYPE) {
					char ch = (Character) ret;
					int high = (((int) ch) >> 8) & 0x0ff;
					int low = ((int) ch) & 0x0ff;
					write(reference, "CallMethod " + low + "_" + high);
				} else {
					// Track returned object.
					store.reference(ret);
					write(reference, "CallMethod " + store.getIdentifier(ret));
				}
			} else if (message.startsWith("GetSuperclass")) {
				String[] args = message.split(" ");
				Integer classID = parseCall(args[1], src, Integer.class);
				Class c = null;
				Class ret = null;

				c = (Class) store.getObject(classID);
				ret = c.getSuperclass();
				store.reference(ret);

				write(reference, "GetSuperclass " + store.getIdentifier(ret));
			} else if (message.startsWith("IsAssignableFrom")) {
				String[] args = message.split(" ");
				Integer classID = parseCall(args[1], src, Integer.class);
				Integer superclassID = parseCall(args[2], src, Integer.class);

				boolean result = false;
				Class clz = (Class) store.getObject(classID);
				Class sup = (Class) store.getObject(superclassID);

				result = sup.isAssignableFrom(clz);

				write(reference, "IsAssignableFrom " + (result ? "1" : "0"));
			} else if (message.startsWith("IsInstanceOf")) {
				String[] args = message.split(" ");
				Integer objectID = parseCall(args[1], src, Integer.class);
				Integer classID = parseCall(args[2], src, Integer.class);

				boolean result = false;
				Object o = (Object) store.getObject(objectID);
				Class c = (Class) store.getObject(classID);

				result = c.isInstance(o);

				write(reference, "IsInstanceOf " + (result ? "1" : "0"));
			} else if (message.startsWith("GetStringUTFLength")) {
				String[] args = message.split(" ");
				Integer stringID = parseCall(args[1], src, Integer.class);

				String o = null;
				byte[] b = null;
				o = (String) store.getObject(stringID);
				b = o.getBytes("UTF-8");
				// System.out.println ("STRING UTF-8 LENGTH: " + o + " " +
				// b.length);

				write(reference, "GetStringUTFLength " + o.length());
			} else if (message.startsWith("GetStringLength")) {
				String[] args = message.split(" ");
				Integer stringID = parseCall(args[1], src, Integer.class);

				String o = null;
				byte[] b = null;
				o = (String) store.getObject(stringID);
				b = o.getBytes("UTF-16LE");
				// System.out.println ("STRING UTF-16 LENGTH: " + o + " " +
				// b.length);

				// System.out.println ("Java: GetStringLength " + b.length);
				write(reference, "GetStringLength " + o.length());
			} else if (message.startsWith("GetStringUTFChars")) {
				String[] args = message.split(" ");
				Integer stringID = parseCall(args[1], src, Integer.class);

				String o = null;
				byte[] b = null;
				StringBuffer buf = null;
				o = (String) store.getObject(stringID);
				b = o.getBytes("UTF-8");
				buf = new StringBuffer(b.length * 2);
				buf.append(b.length);
				for (int i = 0; i < b.length; i++)
					buf
							.append(" "
									+ Integer
											.toString(((int) b[i]) & 0x0ff, 16));

				// System.out.println ("Java: GetStringUTFChars: " + o);
				// //System.out.println ("String UTF BYTES: " + buf);
				write(reference, "GetStringUTFChars " + buf);
			} else if (message.startsWith("GetStringChars")) {
				String[] args = message.split(" ");
				Integer stringID = parseCall(args[1], src, Integer.class);

				String o = null;
				byte[] b = null;
				StringBuffer buf = null;
				o = (String) store.getObject(stringID);
				// FIXME: LiveConnect uses UCS-2.
				b = o.getBytes("UTF-16LE");
				buf = new StringBuffer(b.length * 2);
				buf.append(b.length);
				for (int i = 0; i < b.length; i++)
					buf
							.append(" "
									+ Integer
											.toString(((int) b[i]) & 0x0ff, 16));

				System.out.println("Java: GetStringChars: " + o);
				System.out.println("  String BYTES: " + buf);
				write(reference, "GetStringChars " + buf);
			} else if (message.startsWith("NewArray")) {
				String[] args = message.split(" ");
				String type = parseCall(args[1], src, String.class);
				Integer length = parseCall(args[2], src, Integer.class);

				// System.out.println ("CALLING: NewArray: " + type + " " +
				// length + " "
				// + Signature.primitiveNameToType(type));

				Object newArray = null;
				newArray = Array.newInstance(Signature
						.primitiveNameToType(type), length);

				store.reference(newArray);
				write(reference, "NewArray " + store.getIdentifier(newArray));
			} else if (message.startsWith("NewObjectArray")) {
				String[] args = message.split(" ");
				Integer length = parseCall(args[1], src, Integer.class);
				Integer classID = parseCall(args[2], src, Integer.class);
				Integer objectID = parseCall(args[3], src, Integer.class);

				// System.out.println ("CALLING: NewObjectArray: " +
				// classID + " " + length + " "
				// + objectID);

				Object newArray = null;
				newArray = Array.newInstance((Class) store.getObject(classID),
						length);

				Object[] array = (Object[]) newArray;
				for (int i = 0; i < array.length; i++)
					array[i] = store.getObject(objectID);
				store.reference(newArray);
				write(reference, "NewObjectArray "
						+ store.getIdentifier(newArray));
			} else if (message.startsWith("NewObject")) {
				String[] args = message.split(" ");
				Integer classID = parseCall(args[1], src, Integer.class);
				Integer methodID = parseCall(args[2], src, Integer.class);

				Constructor m = (Constructor) store.getObject(methodID);
				Class[] argTypes = m.getParameterTypes();

				// System.out.println ("NEWOBJ: HERE1");
				Object[] arguments = new Object[argTypes.length];
				// System.out.println ("NEWOBJ: HERE2");
				for (int i = 0; i < argTypes.length; i++) {
					arguments[i] = parseArgs(args[3 + i], argTypes[i]);
					// System.out.println ("NEWOBJ: GOT ARG: " + arguments[i]);
				}

				// System.out.println ("NEWOBJ: Calling " + m);
				Object ret = null;
				ret = m.newInstance(arguments);

				// System.out.println ("NEWOBJ: CALLED: " + ret);
				// System.out.println ("NEWOBJ: CALLED: " +
				// store.getObject(ret));
				store.reference(ret);
				write(reference, "NewObject " + store.getIdentifier(ret));
			} else if (message.startsWith("NewString")) {
				System.out.println("MESSAGE: " + message);
				String[] args = message.split(" ");
				Integer strlength = parseCall(args[1], src, Integer.class);
				int bytelength = 2 * strlength;
				byte[] byteArray = new byte[bytelength];
				String ret = null;
				for (int i = 0; i < strlength; i++) {
					int c = parseCall(args[2 + i], src, Integer.class);
					System.out.println("char " + i + " " + c);
					// Low.
					byteArray[2 * i] = (byte) (c & 0x0ff);
					// High.
					byteArray[2 * i + 1] = (byte) ((c >> 8) & 0x0ff);
				}
				ret = new String(byteArray, 0, bytelength, "UTF-16LE");
				System.out.println("NEWSTRING: " + ret);

				// System.out.println ("NEWOBJ: CALLED: " + ret);
				// System.out.println ("NEWOBJ: CALLED: " +
				// store.getObject(ret));
				store.reference(ret);
				write(reference, "NewString " + store.getIdentifier(ret));
			} else if (message.startsWith("NewStringUTF")) {
				System.out.println("MESSAGE: " + message);
				String[] args = message.split(" ");
				byte[] byteArray = new byte[60];
				String ret = null;
				int i = 0;
				int c = 0;
				while (((byte) c) != 0) {
					c = parseCall(args[1 + i], src, Integer.class);
					byteArray[i] = (byte) c;
					i++;
					if (i == byteArray.length) {
						byte[] newByteArray = new byte[2 * byteArray.length];
						System.arraycopy(byteArray, 0, newByteArray, 0,
								byteArray.length);
						byteArray = newByteArray;
					}
				}
				byteArray[i] = (byte) 0;
				ret = new String(byteArray, "UTF-8");
				System.out.println("NEWSTRINGUTF: " + ret);

				store.reference(ret);
				write(reference, "NewStringUTF " + store.getIdentifier(ret));
			} else if (message.startsWith("ExceptionOccurred")) {
				System.out.println("EXCEPTION: " + throwable);
				if (throwable != null)
					store.reference(throwable);
				write(reference, "ExceptionOccurred "
						+ store.getIdentifier(throwable));
			} else if (message.startsWith("ExceptionClear")) {
				if (throwable != null)
					store.unreference(store.getIdentifier(throwable));
				throwable = null;
				write(reference, "ExceptionClear");
			} else if (message.startsWith("DeleteGlobalRef")) {
				String[] args = message.split(" ");
				Integer id = parseCall(args[1], src, Integer.class);
				store.unreference(id);
				write(reference, "DeleteGlobalRef");
			} else if (message.startsWith("DeleteLocalRef")) {
				String[] args = message.split(" ");
				Integer id = parseCall(args[1], src, Integer.class);
				store.unreference(id);
				write(reference, "DeleteLocalRef");
			} else if (message.startsWith("NewGlobalRef")) {
				String[] args = message.split(" ");
				Integer id = parseCall(args[1], src, Integer.class);
				store.reference(store.getObject(id));
				write(reference, "NewGlobalRef " + id);
			}
		} catch (Throwable t) {
			t.printStackTrace();
			throwable = t;
			PluginException p = new PluginException(identifier, reference, t);
		}
	}

	public void write(int reference, String message) {
		PluginDebug.debug("appletviewer writing " + message);
		PluginMain.write("context " + identifier + " reference " + reference
				+ " " + message);
	}
}
